"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // virtual:isaaccss:css:virtual:isaaccss.css
  var init_ = __esm({
    "virtual:isaaccss:css:virtual:isaaccss.css"() {
    }
  });

  // ../lib/esbuild/inject.js
  var init_inject = __esm({
    "../lib/esbuild/inject.js"() {
      "use strict";
      init_();
    }
  });

  // ../node_modules/known-css-properties/data/all.json
  var require_all = __commonJS({
    "../node_modules/known-css-properties/data/all.json"(exports, module) {
      module.exports = {
        properties: [
          "-epub-caption-side",
          "-epub-hyphens",
          "-epub-text-combine",
          "-epub-text-emphasis",
          "-epub-text-emphasis-color",
          "-epub-text-emphasis-style",
          "-epub-text-orientation",
          "-epub-text-transform",
          "-epub-word-break",
          "-epub-writing-mode",
          "-internal-text-autosizing-status",
          "accelerator",
          "accent-color",
          "-wap-accesskey",
          "additive-symbols",
          "align-content",
          "-webkit-align-content",
          "align-items",
          "-webkit-align-items",
          "align-self",
          "-webkit-align-self",
          "alignment-baseline",
          "all",
          "alt",
          "-webkit-alt",
          "animation",
          "animation-delay",
          "-moz-animation-delay",
          "-ms-animation-delay",
          "-webkit-animation-delay",
          "animation-direction",
          "-moz-animation-direction",
          "-ms-animation-direction",
          "-webkit-animation-direction",
          "animation-duration",
          "-moz-animation-duration",
          "-ms-animation-duration",
          "-webkit-animation-duration",
          "animation-fill-mode",
          "-moz-animation-fill-mode",
          "-ms-animation-fill-mode",
          "-webkit-animation-fill-mode",
          "animation-iteration-count",
          "-moz-animation-iteration-count",
          "-ms-animation-iteration-count",
          "-webkit-animation-iteration-count",
          "-moz-animation",
          "-ms-animation",
          "animation-name",
          "-moz-animation-name",
          "-ms-animation-name",
          "-webkit-animation-name",
          "animation-play-state",
          "-moz-animation-play-state",
          "-ms-animation-play-state",
          "-webkit-animation-play-state",
          "animation-timing-function",
          "-moz-animation-timing-function",
          "-ms-animation-timing-function",
          "-webkit-animation-timing-function",
          "-webkit-animation-trigger",
          "-webkit-animation",
          "app-region",
          "-webkit-app-region",
          "appearance",
          "-moz-appearance",
          "-webkit-appearance",
          "ascent-override",
          "aspect-ratio",
          "-webkit-aspect-ratio",
          "audio-level",
          "azimuth",
          "backdrop-filter",
          "-webkit-backdrop-filter",
          "backface-visibility",
          "-moz-backface-visibility",
          "-ms-backface-visibility",
          "-webkit-backface-visibility",
          "background",
          "background-attachment",
          "-webkit-background-attachment",
          "background-blend-mode",
          "background-clip",
          "-moz-background-clip",
          "-webkit-background-clip",
          "background-color",
          "-webkit-background-color",
          "-webkit-background-composite",
          "background-image",
          "-webkit-background-image",
          "-moz-background-inline-policy",
          "background-origin",
          "-moz-background-origin",
          "-webkit-background-origin",
          "background-position",
          "-webkit-background-position",
          "background-position-x",
          "-webkit-background-position-x",
          "background-position-y",
          "-webkit-background-position-y",
          "background-repeat",
          "-webkit-background-repeat",
          "background-repeat-x",
          "background-repeat-y",
          "background-size",
          "-moz-background-size",
          "-webkit-background-size",
          "-webkit-background",
          "base-palette",
          "baseline-shift",
          "baseline-source",
          "behavior",
          "-moz-binding",
          "block-ellipsis",
          "-ms-block-progression",
          "block-size",
          "block-step",
          "block-step-align",
          "block-step-insert",
          "block-step-round",
          "block-step-size",
          "bookmark-label",
          "bookmark-level",
          "bookmark-state",
          "border",
          "-webkit-border-after-color",
          "-webkit-border-after-style",
          "-webkit-border-after",
          "-webkit-border-after-width",
          "-webkit-border-before-color",
          "-webkit-border-before-style",
          "-webkit-border-before",
          "-webkit-border-before-width",
          "border-block",
          "border-block-color",
          "border-block-end",
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width",
          "border-block-start",
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width",
          "border-block-style",
          "border-block-width",
          "border-bottom",
          "border-bottom-color",
          "-moz-border-bottom-colors",
          "border-bottom-left-radius",
          "-webkit-border-bottom-left-radius",
          "border-bottom-right-radius",
          "-webkit-border-bottom-right-radius",
          "border-bottom-style",
          "border-bottom-width",
          "border-boundary",
          "border-collapse",
          "border-color",
          "-moz-border-end-color",
          "-webkit-border-end-color",
          "border-end-end-radius",
          "-moz-border-end",
          "border-end-start-radius",
          "-moz-border-end-style",
          "-webkit-border-end-style",
          "-webkit-border-end",
          "-moz-border-end-width",
          "-webkit-border-end-width",
          "-webkit-border-fit",
          "-webkit-border-horizontal-spacing",
          "border-image",
          "-moz-border-image",
          "-o-border-image",
          "border-image-outset",
          "-webkit-border-image-outset",
          "border-image-repeat",
          "-webkit-border-image-repeat",
          "border-image-slice",
          "-webkit-border-image-slice",
          "border-image-source",
          "-webkit-border-image-source",
          "-webkit-border-image",
          "border-image-width",
          "-webkit-border-image-width",
          "border-inline",
          "border-inline-color",
          "border-inline-end",
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width",
          "border-inline-start",
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width",
          "border-inline-style",
          "border-inline-width",
          "border-left",
          "border-left-color",
          "-moz-border-left-colors",
          "border-left-style",
          "border-left-width",
          "border-radius",
          "-moz-border-radius-bottomleft",
          "-moz-border-radius-bottomright",
          "-moz-border-radius",
          "-moz-border-radius-topleft",
          "-moz-border-radius-topright",
          "-webkit-border-radius",
          "border-right",
          "border-right-color",
          "-moz-border-right-colors",
          "border-right-style",
          "border-right-width",
          "border-spacing",
          "-moz-border-start-color",
          "-webkit-border-start-color",
          "border-start-end-radius",
          "-moz-border-start",
          "border-start-start-radius",
          "-moz-border-start-style",
          "-webkit-border-start-style",
          "-webkit-border-start",
          "-moz-border-start-width",
          "-webkit-border-start-width",
          "border-style",
          "border-top",
          "border-top-color",
          "-moz-border-top-colors",
          "border-top-left-radius",
          "-webkit-border-top-left-radius",
          "border-top-right-radius",
          "-webkit-border-top-right-radius",
          "border-top-style",
          "border-top-width",
          "-webkit-border-vertical-spacing",
          "border-width",
          "bottom",
          "-moz-box-align",
          "-webkit-box-align",
          "box-decoration-break",
          "-webkit-box-decoration-break",
          "-moz-box-direction",
          "-webkit-box-direction",
          "-webkit-box-flex-group",
          "-moz-box-flex",
          "-webkit-box-flex",
          "-webkit-box-lines",
          "-moz-box-ordinal-group",
          "-webkit-box-ordinal-group",
          "-moz-box-orient",
          "-webkit-box-orient",
          "-moz-box-pack",
          "-webkit-box-pack",
          "-webkit-box-reflect",
          "box-shadow",
          "-moz-box-shadow",
          "-webkit-box-shadow",
          "box-sizing",
          "-moz-box-sizing",
          "-webkit-box-sizing",
          "box-snap",
          "break-after",
          "break-before",
          "break-inside",
          "buffered-rendering",
          "caption-side",
          "caret",
          "caret-color",
          "caret-shape",
          "chains",
          "clear",
          "clip",
          "clip-path",
          "-webkit-clip-path",
          "clip-rule",
          "color",
          "color-adjust",
          "-webkit-color-correction",
          "-apple-color-filter",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "color-scheme",
          "-webkit-column-axis",
          "-webkit-column-break-after",
          "-webkit-column-break-before",
          "-webkit-column-break-inside",
          "column-count",
          "-moz-column-count",
          "-webkit-column-count",
          "column-fill",
          "-moz-column-fill",
          "-webkit-column-fill",
          "column-gap",
          "-moz-column-gap",
          "-webkit-column-gap",
          "column-progression",
          "-webkit-column-progression",
          "column-rule",
          "column-rule-color",
          "-moz-column-rule-color",
          "-webkit-column-rule-color",
          "-moz-column-rule",
          "column-rule-style",
          "-moz-column-rule-style",
          "-webkit-column-rule-style",
          "-webkit-column-rule",
          "column-rule-width",
          "-moz-column-rule-width",
          "-webkit-column-rule-width",
          "column-span",
          "-moz-column-span",
          "-webkit-column-span",
          "column-width",
          "-moz-column-width",
          "-webkit-column-width",
          "columns",
          "-moz-columns",
          "-webkit-columns",
          "-webkit-composition-fill-color",
          "-webkit-composition-frame-color",
          "contain",
          "contain-intrinsic-block-size",
          "contain-intrinsic-height",
          "contain-intrinsic-inline-size",
          "contain-intrinsic-size",
          "contain-intrinsic-width",
          "container",
          "container-name",
          "container-type",
          "content",
          "content-visibility",
          "-ms-content-zoom-chaining",
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min",
          "-ms-content-zoom-limit",
          "-ms-content-zoom-snap",
          "-ms-content-zoom-snap-points",
          "-ms-content-zoom-snap-type",
          "-ms-content-zooming",
          "continue",
          "counter-increment",
          "counter-reset",
          "counter-set",
          "cue",
          "cue-after",
          "cue-before",
          "cursor",
          "-webkit-cursor-visibility",
          "cx",
          "cy",
          "d",
          "-apple-dashboard-region",
          "-webkit-dashboard-region",
          "descent-override",
          "direction",
          "display",
          "display-align",
          "dominant-baseline",
          "elevation",
          "empty-cells",
          "enable-background",
          "epub-caption-side",
          "epub-hyphens",
          "epub-text-combine",
          "epub-text-emphasis",
          "epub-text-emphasis-color",
          "epub-text-emphasis-style",
          "epub-text-orientation",
          "epub-text-transform",
          "epub-word-break",
          "epub-writing-mode",
          "fallback",
          "fill",
          "fill-break",
          "fill-color",
          "fill-image",
          "fill-opacity",
          "fill-origin",
          "fill-position",
          "fill-repeat",
          "fill-rule",
          "fill-size",
          "filter",
          "-ms-filter",
          "-webkit-filter",
          "flex",
          "-ms-flex-align",
          "-webkit-flex-align",
          "flex-basis",
          "-webkit-flex-basis",
          "flex-direction",
          "-ms-flex-direction",
          "-webkit-flex-direction",
          "flex-flow",
          "-ms-flex-flow",
          "-webkit-flex-flow",
          "flex-grow",
          "-webkit-flex-grow",
          "-ms-flex-item-align",
          "-webkit-flex-item-align",
          "-ms-flex-line-pack",
          "-webkit-flex-line-pack",
          "-ms-flex",
          "-ms-flex-negative",
          "-ms-flex-order",
          "-webkit-flex-order",
          "-ms-flex-pack",
          "-webkit-flex-pack",
          "-ms-flex-positive",
          "-ms-flex-preferred-size",
          "flex-shrink",
          "-webkit-flex-shrink",
          "-webkit-flex",
          "flex-wrap",
          "-ms-flex-wrap",
          "-webkit-flex-wrap",
          "float",
          "float-defer",
          "-moz-float-edge",
          "float-offset",
          "float-reference",
          "flood-color",
          "flood-opacity",
          "flow",
          "flow-from",
          "-ms-flow-from",
          "-webkit-flow-from",
          "flow-into",
          "-ms-flow-into",
          "-webkit-flow-into",
          "font",
          "font-display",
          "font-family",
          "font-feature-settings",
          "-moz-font-feature-settings",
          "-ms-font-feature-settings",
          "-webkit-font-feature-settings",
          "font-kerning",
          "-webkit-font-kerning",
          "font-language-override",
          "-moz-font-language-override",
          "font-optical-sizing",
          "font-palette",
          "font-size",
          "font-size-adjust",
          "-webkit-font-size-delta",
          "-webkit-font-smoothing",
          "font-stretch",
          "font-style",
          "font-synthesis",
          "font-synthesis-small-caps",
          "font-synthesis-style",
          "font-synthesis-weight",
          "font-variant",
          "font-variant-alternates",
          "font-variant-caps",
          "font-variant-east-asian",
          "font-variant-emoji",
          "font-variant-ligatures",
          "-webkit-font-variant-ligatures",
          "font-variant-numeric",
          "font-variant-position",
          "font-variation-settings",
          "font-weight",
          "footnote-display",
          "footnote-policy",
          "-moz-force-broken-image-icon",
          "forced-color-adjust",
          "gap",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "grid",
          "-webkit-grid-after",
          "grid-area",
          "grid-auto-columns",
          "-webkit-grid-auto-columns",
          "grid-auto-flow",
          "-webkit-grid-auto-flow",
          "grid-auto-rows",
          "-webkit-grid-auto-rows",
          "-webkit-grid-before",
          "grid-column",
          "-ms-grid-column-align",
          "grid-column-end",
          "grid-column-gap",
          "-ms-grid-column",
          "-ms-grid-column-span",
          "grid-column-start",
          "-webkit-grid-column",
          "-ms-grid-columns",
          "-webkit-grid-columns",
          "-webkit-grid-end",
          "grid-gap",
          "grid-row",
          "-ms-grid-row-align",
          "grid-row-end",
          "grid-row-gap",
          "-ms-grid-row",
          "-ms-grid-row-span",
          "grid-row-start",
          "-webkit-grid-row",
          "-ms-grid-rows",
          "-webkit-grid-rows",
          "-webkit-grid-start",
          "grid-template",
          "grid-template-areas",
          "grid-template-columns",
          "grid-template-rows",
          "hanging-punctuation",
          "height",
          "-ms-high-contrast-adjust",
          "-webkit-highlight",
          "hyphenate-character",
          "-webkit-hyphenate-character",
          "-webkit-hyphenate-limit-after",
          "-webkit-hyphenate-limit-before",
          "hyphenate-limit-chars",
          "-ms-hyphenate-limit-chars",
          "hyphenate-limit-last",
          "hyphenate-limit-lines",
          "-ms-hyphenate-limit-lines",
          "-webkit-hyphenate-limit-lines",
          "hyphenate-limit-zone",
          "-ms-hyphenate-limit-zone",
          "hyphens",
          "-moz-hyphens",
          "-ms-hyphens",
          "-webkit-hyphens",
          "image-orientation",
          "-moz-image-region",
          "image-rendering",
          "image-resolution",
          "-ms-ime-align",
          "ime-mode",
          "inherits",
          "initial-letter",
          "initial-letter-align",
          "-webkit-initial-letter",
          "initial-letter-wrap",
          "initial-value",
          "inline-size",
          "inline-sizing",
          "input-format",
          "-wap-input-format",
          "-wap-input-required",
          "input-security",
          "inset",
          "inset-block",
          "inset-block-end",
          "inset-block-start",
          "inset-inline",
          "inset-inline-end",
          "inset-inline-start",
          "-ms-interpolation-mode",
          "isolation",
          "justify-content",
          "-webkit-justify-content",
          "justify-items",
          "-webkit-justify-items",
          "justify-self",
          "-webkit-justify-self",
          "kerning",
          "layout-flow",
          "layout-grid",
          "layout-grid-char",
          "layout-grid-line",
          "layout-grid-mode",
          "layout-grid-type",
          "leading-trim",
          "left",
          "letter-spacing",
          "lighting-color",
          "-webkit-line-align",
          "-webkit-line-box-contain",
          "line-break",
          "-webkit-line-break",
          "line-clamp",
          "-webkit-line-clamp",
          "line-gap-override",
          "line-grid",
          "-webkit-line-grid-snap",
          "-webkit-line-grid",
          "line-height",
          "line-height-step",
          "line-increment",
          "line-padding",
          "line-snap",
          "-webkit-line-snap",
          "-o-link",
          "-o-link-source",
          "list-style",
          "list-style-image",
          "list-style-position",
          "list-style-type",
          "-webkit-locale",
          "-webkit-logical-height",
          "-webkit-logical-width",
          "margin",
          "-webkit-margin-after-collapse",
          "-webkit-margin-after",
          "-webkit-margin-before-collapse",
          "-webkit-margin-before",
          "margin-block",
          "margin-block-end",
          "margin-block-start",
          "margin-bottom",
          "-webkit-margin-bottom-collapse",
          "margin-break",
          "-webkit-margin-collapse",
          "-moz-margin-end",
          "-webkit-margin-end",
          "margin-inline",
          "margin-inline-end",
          "margin-inline-start",
          "margin-left",
          "margin-right",
          "-moz-margin-start",
          "-webkit-margin-start",
          "margin-top",
          "-webkit-margin-top-collapse",
          "margin-trim",
          "marker",
          "marker-end",
          "marker-knockout-left",
          "marker-knockout-right",
          "marker-mid",
          "marker-offset",
          "marker-pattern",
          "marker-segment",
          "marker-side",
          "marker-start",
          "marks",
          "-wap-marquee-dir",
          "-webkit-marquee-direction",
          "-webkit-marquee-increment",
          "-wap-marquee-loop",
          "-webkit-marquee-repetition",
          "-wap-marquee-speed",
          "-webkit-marquee-speed",
          "-wap-marquee-style",
          "-webkit-marquee-style",
          "-webkit-marquee",
          "mask",
          "-webkit-mask-attachment",
          "mask-border",
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width",
          "-webkit-mask-box-image-outset",
          "-webkit-mask-box-image-repeat",
          "-webkit-mask-box-image-slice",
          "-webkit-mask-box-image-source",
          "-webkit-mask-box-image",
          "-webkit-mask-box-image-width",
          "mask-clip",
          "-webkit-mask-clip",
          "mask-composite",
          "-webkit-mask-composite",
          "mask-image",
          "-webkit-mask-image",
          "mask-mode",
          "mask-origin",
          "-webkit-mask-origin",
          "mask-position",
          "-webkit-mask-position",
          "mask-position-x",
          "-webkit-mask-position-x",
          "mask-position-y",
          "-webkit-mask-position-y",
          "mask-repeat",
          "-webkit-mask-repeat",
          "-webkit-mask-repeat-x",
          "-webkit-mask-repeat-y",
          "mask-size",
          "-webkit-mask-size",
          "mask-source-type",
          "-webkit-mask-source-type",
          "mask-type",
          "-webkit-mask",
          "-webkit-match-nearest-mail-blockquote-color",
          "math-style",
          "max-block-size",
          "max-height",
          "max-inline-size",
          "max-lines",
          "-webkit-max-logical-height",
          "-webkit-max-logical-width",
          "max-width",
          "max-zoom",
          "min-block-size",
          "min-height",
          "min-inline-size",
          "min-intrinsic-sizing",
          "-webkit-min-logical-height",
          "-webkit-min-logical-width",
          "min-width",
          "min-zoom",
          "mix-blend-mode",
          "motion",
          "motion-offset",
          "motion-path",
          "motion-rotation",
          "nav-down",
          "nav-index",
          "nav-left",
          "nav-right",
          "nav-up",
          "-webkit-nbsp-mode",
          "negative",
          "object-fit",
          "-o-object-fit",
          "object-overflow",
          "object-position",
          "-o-object-position",
          "object-view-box",
          "offset",
          "offset-anchor",
          "offset-block-end",
          "offset-block-start",
          "offset-distance",
          "offset-inline-end",
          "offset-inline-start",
          "offset-path",
          "offset-position",
          "offset-rotate",
          "offset-rotation",
          "opacity",
          "-moz-opacity",
          "-webkit-opacity",
          "order",
          "-webkit-order",
          "-moz-orient",
          "orientation",
          "orphans",
          "-moz-osx-font-smoothing",
          "outline",
          "outline-color",
          "-moz-outline-color",
          "-moz-outline",
          "outline-offset",
          "-moz-outline-offset",
          "-moz-outline-radius-bottomleft",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius",
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "outline-style",
          "-moz-outline-style",
          "outline-width",
          "-moz-outline-width",
          "overflow",
          "overflow-anchor",
          "overflow-block",
          "overflow-clip-margin",
          "overflow-inline",
          "-webkit-overflow-scrolling",
          "-ms-overflow-style",
          "overflow-wrap",
          "overflow-x",
          "overflow-y",
          "override-colors",
          "overscroll-behavior",
          "overscroll-behavior-block",
          "overscroll-behavior-inline",
          "overscroll-behavior-x",
          "overscroll-behavior-y",
          "pad",
          "padding",
          "-webkit-padding-after",
          "-webkit-padding-before",
          "padding-block",
          "padding-block-end",
          "padding-block-start",
          "padding-bottom",
          "-moz-padding-end",
          "-webkit-padding-end",
          "padding-inline",
          "padding-inline-end",
          "padding-inline-start",
          "padding-left",
          "padding-right",
          "-moz-padding-start",
          "-webkit-padding-start",
          "padding-top",
          "page",
          "page-break-after",
          "page-break-before",
          "page-break-inside",
          "page-orientation",
          "paint-order",
          "pause",
          "pause-after",
          "pause-before",
          "-apple-pay-button-style",
          "-apple-pay-button-type",
          "pen-action",
          "perspective",
          "-moz-perspective",
          "-ms-perspective",
          "perspective-origin",
          "-moz-perspective-origin",
          "-ms-perspective-origin",
          "-webkit-perspective-origin",
          "perspective-origin-x",
          "-webkit-perspective-origin-x",
          "perspective-origin-y",
          "-webkit-perspective-origin-y",
          "-webkit-perspective",
          "pitch",
          "pitch-range",
          "place-content",
          "place-items",
          "place-self",
          "play-during",
          "pointer-events",
          "position",
          "prefix",
          "print-color-adjust",
          "-webkit-print-color-adjust",
          "property-name",
          "quotes",
          "r",
          "range",
          "-webkit-region-break-after",
          "-webkit-region-break-before",
          "-webkit-region-break-inside",
          "region-fragment",
          "-webkit-region-fragment",
          "-webkit-region-overflow",
          "resize",
          "rest",
          "rest-after",
          "rest-before",
          "richness",
          "right",
          "rotate",
          "row-gap",
          "-webkit-rtl-ordering",
          "ruby-align",
          "ruby-merge",
          "ruby-overhang",
          "ruby-position",
          "-webkit-ruby-position",
          "running",
          "rx",
          "ry",
          "scale",
          "scroll-behavior",
          "-ms-scroll-chaining",
          "-ms-scroll-limit",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-max",
          "-ms-scroll-limit-y-min",
          "scroll-margin",
          "scroll-margin-block",
          "scroll-margin-block-end",
          "scroll-margin-block-start",
          "scroll-margin-bottom",
          "scroll-margin-inline",
          "scroll-margin-inline-end",
          "scroll-margin-inline-start",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top",
          "scroll-padding",
          "scroll-padding-block",
          "scroll-padding-block-end",
          "scroll-padding-block-start",
          "scroll-padding-bottom",
          "scroll-padding-inline",
          "scroll-padding-inline-end",
          "scroll-padding-inline-start",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top",
          "-ms-scroll-rails",
          "scroll-snap-align",
          "scroll-snap-coordinate",
          "-webkit-scroll-snap-coordinate",
          "scroll-snap-destination",
          "-webkit-scroll-snap-destination",
          "scroll-snap-margin",
          "scroll-snap-margin-bottom",
          "scroll-snap-margin-left",
          "scroll-snap-margin-right",
          "scroll-snap-margin-top",
          "scroll-snap-points-x",
          "-ms-scroll-snap-points-x",
          "-webkit-scroll-snap-points-x",
          "scroll-snap-points-y",
          "-ms-scroll-snap-points-y",
          "-webkit-scroll-snap-points-y",
          "scroll-snap-stop",
          "scroll-snap-type",
          "-ms-scroll-snap-type",
          "-webkit-scroll-snap-type",
          "scroll-snap-type-x",
          "scroll-snap-type-y",
          "-ms-scroll-snap-x",
          "-ms-scroll-snap-y",
          "-ms-scroll-translation",
          "scrollbar-arrow-color",
          "scrollbar-base-color",
          "scrollbar-color",
          "scrollbar-dark-shadow-color",
          "scrollbar-darkshadow-color",
          "scrollbar-face-color",
          "scrollbar-gutter",
          "scrollbar-highlight-color",
          "scrollbar-shadow-color",
          "scrollbar-track-color",
          "scrollbar-width",
          "scrollbar3d-light-color",
          "scrollbar3dlight-color",
          "shape-image-threshold",
          "-webkit-shape-image-threshold",
          "shape-inside",
          "-webkit-shape-inside",
          "shape-margin",
          "-webkit-shape-margin",
          "shape-outside",
          "-webkit-shape-outside",
          "-webkit-shape-padding",
          "shape-rendering",
          "size",
          "size-adjust",
          "snap-height",
          "solid-color",
          "solid-opacity",
          "spatial-navigation-action",
          "spatial-navigation-contain",
          "spatial-navigation-function",
          "speak",
          "speak-as",
          "speak-header",
          "speak-numeral",
          "speak-punctuation",
          "speech-rate",
          "src",
          "-moz-stack-sizing",
          "stop-color",
          "stop-opacity",
          "stress",
          "string-set",
          "stroke",
          "stroke-align",
          "stroke-alignment",
          "stroke-break",
          "stroke-color",
          "stroke-dash-corner",
          "stroke-dash-justify",
          "stroke-dashadjust",
          "stroke-dasharray",
          "stroke-dashcorner",
          "stroke-dashoffset",
          "stroke-image",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-origin",
          "stroke-position",
          "stroke-repeat",
          "stroke-size",
          "stroke-width",
          "suffix",
          "supported-color-schemes",
          "-webkit-svg-shadow",
          "symbols",
          "syntax",
          "system",
          "tab-size",
          "-moz-tab-size",
          "-o-tab-size",
          "-o-table-baseline",
          "table-layout",
          "-webkit-tap-highlight-color",
          "text-align",
          "text-align-all",
          "text-align-last",
          "-moz-text-align-last",
          "text-anchor",
          "text-autospace",
          "-moz-text-blink",
          "-ms-text-combine-horizontal",
          "text-combine-upright",
          "-webkit-text-combine",
          "text-decoration",
          "text-decoration-blink",
          "text-decoration-color",
          "-moz-text-decoration-color",
          "-webkit-text-decoration-color",
          "text-decoration-line",
          "-moz-text-decoration-line",
          "text-decoration-line-through",
          "-webkit-text-decoration-line",
          "text-decoration-none",
          "text-decoration-overline",
          "text-decoration-skip",
          "text-decoration-skip-box",
          "text-decoration-skip-ink",
          "text-decoration-skip-inset",
          "text-decoration-skip-self",
          "text-decoration-skip-spaces",
          "-webkit-text-decoration-skip",
          "text-decoration-style",
          "-moz-text-decoration-style",
          "-webkit-text-decoration-style",
          "text-decoration-thickness",
          "text-decoration-underline",
          "-webkit-text-decoration",
          "-webkit-text-decorations-in-effect",
          "text-edge",
          "text-emphasis",
          "text-emphasis-color",
          "-webkit-text-emphasis-color",
          "text-emphasis-position",
          "-webkit-text-emphasis-position",
          "text-emphasis-skip",
          "text-emphasis-style",
          "-webkit-text-emphasis-style",
          "-webkit-text-emphasis",
          "-webkit-text-fill-color",
          "text-group-align",
          "text-indent",
          "text-justify",
          "text-justify-trim",
          "text-kashida",
          "text-kashida-space",
          "text-line-through",
          "text-line-through-color",
          "text-line-through-mode",
          "text-line-through-style",
          "text-line-through-width",
          "text-orientation",
          "-webkit-text-orientation",
          "text-overflow",
          "text-overline",
          "text-overline-color",
          "text-overline-mode",
          "text-overline-style",
          "text-overline-width",
          "text-rendering",
          "-webkit-text-security",
          "text-shadow",
          "text-size-adjust",
          "-moz-text-size-adjust",
          "-ms-text-size-adjust",
          "-webkit-text-size-adjust",
          "text-space-collapse",
          "text-space-trim",
          "text-spacing",
          "-webkit-text-stroke-color",
          "-webkit-text-stroke",
          "-webkit-text-stroke-width",
          "text-transform",
          "text-underline",
          "text-underline-color",
          "text-underline-mode",
          "text-underline-offset",
          "text-underline-position",
          "-webkit-text-underline-position",
          "text-underline-style",
          "text-underline-width",
          "text-wrap",
          "-webkit-text-zoom",
          "top",
          "touch-action",
          "touch-action-delay",
          "-ms-touch-action",
          "-webkit-touch-callout",
          "-ms-touch-select",
          "-apple-trailing-word",
          "transform",
          "transform-box",
          "-moz-transform",
          "-ms-transform",
          "-o-transform",
          "transform-origin",
          "-moz-transform-origin",
          "-ms-transform-origin",
          "-o-transform-origin",
          "-webkit-transform-origin",
          "transform-origin-x",
          "-webkit-transform-origin-x",
          "transform-origin-y",
          "-webkit-transform-origin-y",
          "transform-origin-z",
          "-webkit-transform-origin-z",
          "transform-style",
          "-moz-transform-style",
          "-ms-transform-style",
          "-webkit-transform-style",
          "-webkit-transform",
          "transition",
          "transition-delay",
          "-moz-transition-delay",
          "-ms-transition-delay",
          "-o-transition-delay",
          "-webkit-transition-delay",
          "transition-duration",
          "-moz-transition-duration",
          "-ms-transition-duration",
          "-o-transition-duration",
          "-webkit-transition-duration",
          "-moz-transition",
          "-ms-transition",
          "-o-transition",
          "transition-property",
          "-moz-transition-property",
          "-ms-transition-property",
          "-o-transition-property",
          "-webkit-transition-property",
          "transition-timing-function",
          "-moz-transition-timing-function",
          "-ms-transition-timing-function",
          "-o-transition-timing-function",
          "-webkit-transition-timing-function",
          "-webkit-transition",
          "translate",
          "uc-alt-skin",
          "uc-skin",
          "unicode-bidi",
          "unicode-range",
          "-webkit-user-drag",
          "-moz-user-focus",
          "-moz-user-input",
          "-moz-user-modify",
          "-webkit-user-modify",
          "user-select",
          "-moz-user-select",
          "-ms-user-select",
          "-webkit-user-select",
          "user-zoom",
          "vector-effect",
          "vertical-align",
          "viewport-fill",
          "viewport-fill-opacity",
          "viewport-fit",
          "visibility",
          "voice-balance",
          "voice-duration",
          "voice-family",
          "voice-pitch",
          "voice-range",
          "voice-rate",
          "voice-stress",
          "voice-volume",
          "volume",
          "white-space",
          "-webkit-widget-region",
          "widows",
          "width",
          "will-change",
          "-moz-window-dragging",
          "-moz-window-shadow",
          "word-boundary-detection",
          "word-boundary-expansion",
          "word-break",
          "word-spacing",
          "word-wrap",
          "wrap-after",
          "wrap-before",
          "wrap-flow",
          "-ms-wrap-flow",
          "-webkit-wrap-flow",
          "wrap-inside",
          "-ms-wrap-margin",
          "-webkit-wrap-margin",
          "-webkit-wrap-padding",
          "-webkit-wrap-shape-inside",
          "-webkit-wrap-shape-outside",
          "wrap-through",
          "-ms-wrap-through",
          "-webkit-wrap-through",
          "-webkit-wrap",
          "writing-mode",
          "-webkit-writing-mode",
          "x",
          "y",
          "z-index",
          "zoom"
        ]
      };
    }
  });

  // ../node_modules/known-css-properties/index.js
  var require_known_css_properties = __commonJS({
    "../node_modules/known-css-properties/index.js"(exports, module) {
      init_inject();
      module.exports.all = require_all().properties;
    }
  });

  // ../node_modules/@babel/parser/lib/index.js
  var require_lib = __commonJS({
    "../node_modules/@babel/parser/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var Position = class {
        constructor(line, col, index) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index;
        }
      };
      var SourceLocation = class {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      };
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index
        } = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      var ParseErrorCode = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      };
      var reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce((object, key) => object[key], this);
        },
        set(value) {
          keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);
        }
      });
      var instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties));
      var ModuleErrors = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        }
      };
      var NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      var toNodeDescription = ({
        type,
        prefix: prefix2
      }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
      var StandardErrors = {
        AccessorIsGenerator: ({
          kind
        }) => `A ${kind}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accesor must not have any formal parameters.",
        BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({
          kind
        }) => `Missing initializer in ${kind} declaration.`,
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({
          type
        }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({
          type
        }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: ({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({
          radix
        }) => `Expected number in radix ${radix}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`,
        InvalidIdentifier: ({
          identifierName
        }) => `Invalid identifier ${identifierName}.`,
        InvalidLhs: ({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidLhsBinding: ({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({
          unexpected
        }) => `Unexpected character '${unexpected}'.`,
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({
          identifierName
        }) => `Private name #${identifierName} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({
          labelName
        }) => `Label '${labelName}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingOneOfPlugins: ({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
        ModuleExportUndefined: ({
          localName
        }) => `Export '${localName}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
        PrivateNameRedeclaration: ({
          identifierName
        }) => `Duplicate private name #${identifierName}.`,
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({
          keyword
        }) => `Unexpected keyword '${keyword}'.`,
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        VarRedeclaration: ({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      };
      var StrictModeErrors = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`,
        StrictEvalArgumentsBinding: ({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`,
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode."
      };
      var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = {
        PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
        PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({
          type
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
      };
      var _excluded$1 = ["toMessage"];
      var _excluded2$1 = ["message"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
        }
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(argument)) {
          const template2 = argument[reasonCode];
          const _ref2 = typeof template2 === "string" ? {
            message: () => template2
          } : typeof template2 === "function" ? {
            message: template2
          } : template2, {
            message
          } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          const toMessage = typeof message === "string" ? () => message : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        }
        return ParseErrorConstructors;
      }
      var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      var {
        defineProperty
      } = Object;
      var toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
      function toESTreeLocation(node) {
        node.loc.start && toUnenumerable(node.loc.start, "index");
        node.loc.end && toUnenumerable(node.loc.end, "index");
        return node;
      }
      var estree = (superClass) => class ESTreeParserMixin extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex = null;
          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {
          }
          const node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern,
            flags
          };
          return node;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const directiveLiteral = directive.value;
          const stmt = this.startNodeAt(directive.start, directive.loc.start);
          const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.extra.expressionValue;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
        }
        initFunction(node, isAsync) {
          super.initFunction(node, isAsync);
          node.expression = false;
        }
        checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            super.checkDeclaration(node);
          }
        }
        getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
          const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(method);
        }
        parsePrivateName() {
          const node = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
          const name = super.getPrivateNameSV(node);
          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
        isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node);
            }
          }
          return node.name;
        }
        parseLiteral(value, type) {
          const node = super.parseLiteral(value, type);
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          super.parseFunctionBody(node, allowExpression, isMethod);
          node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }
          return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node) {
            node.type = "Property";
            if (node.kind === "method") {
              node.kind = "init";
            }
            node.shorthand = false;
          }
          return node;
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }
          return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
          if (node != null && this.isObjectProperty(node)) {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
        }
        finishCallExpression(unfinished, optional) {
          const node = super.finishCallExpression(unfinished, optional);
          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node.arguments;
            delete node.callee;
          }
          return node;
        }
        toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node);
        }
        parseExport(unfinished) {
          const node = super.parseExport(unfinished);
          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }
              break;
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }
          return node;
        }
        hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }
          return super.hasPropertyAsPrivateName(node);
        }
        isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
        isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, start, startLoc) {
          super.resetStartLocation(node, start, startLoc);
          toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node, endLoc);
          toESTreeLocation(node);
        }
      };
      var TokContext = class {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      };
      var types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types.template = new TokContext("`", true);
      }
      var beforeExpr = true;
      var startsExpr = true;
      var isLoop = true;
      var isAssign = true;
      var prefix = true;
      var postfix = true;
      var ExportedTokenType = class {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      };
      var keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name, options = {}) {
        options.keyword = name;
        const token = createToken(name, options);
        keywords$1.set(name, token);
        return token;
      }
      function createBinop(name, binop) {
        return createToken(name, {
          beforeExpr,
          binop
        });
      }
      var tokenTypeCounter = -1;
      var tokenTypes = [];
      var tokenLabels = [];
      var tokenBinops = [];
      var tokenBeforeExprs = [];
      var tokenStartsExprs = [];
      var tokenPrefixes = [];
      function createToken(name, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name);
        tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
        tokenTypes.push(new ExportedTokenType(name, options));
        return tokenTypeCounter;
      }
      function createKeywordLike(name, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name, tokenTypeCounter);
        tokenLabels.push(name);
        tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
        tokenTypes.push(new ExportedTokenType("name", options));
        return tokenTypeCounter;
      }
      var tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 128;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 128;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 132;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 125 && token <= 127;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 117 && token <= 119;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 120 && token <= 126;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      {
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        };
        tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types.brace);
        };
        tokenTypes[22].updateContext = (context) => {
          if (context[context.length - 1] === types.template) {
            context.pop();
          } else {
            context.push(types.template);
          }
        };
        tokenTypes[138].updateContext = (context) => {
          context.push(types.j_expr, types.j_oTag);
        };
      }
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code)
            return false;
          pos += set[i + 1];
          if (pos >= code)
            return true;
        }
        return false;
      }
      function isIdentifierStart(code) {
        if (code < 65)
          return code === 36;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code) {
        if (code < 48)
          return code === 36;
        if (code < 58)
          return true;
        if (code < 65)
          return false;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword(word) {
        return keywords.has(word);
      }
      function isIteratorStart(current, next, next2) {
        return current === 64 && next === 64 && isIdentifierStart(next2);
      }
      var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word) {
        return reservedWordLikeSet.has(word);
      }
      var SCOPE_OTHER = 0;
      var SCOPE_PROGRAM = 1;
      var SCOPE_FUNCTION = 2;
      var SCOPE_ARROW = 4;
      var SCOPE_SIMPLE_CATCH = 8;
      var SCOPE_SUPER = 16;
      var SCOPE_DIRECT_SUPER = 32;
      var SCOPE_CLASS = 64;
      var SCOPE_STATIC_BLOCK = 128;
      var SCOPE_TS_MODULE = 256;
      var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
      var BIND_KIND_VALUE = 1;
      var BIND_KIND_TYPE = 2;
      var BIND_SCOPE_VAR = 4;
      var BIND_SCOPE_LEXICAL = 8;
      var BIND_SCOPE_FUNCTION = 16;
      var BIND_FLAGS_NONE = 64;
      var BIND_FLAGS_CLASS = 128;
      var BIND_FLAGS_TS_ENUM = 256;
      var BIND_FLAGS_TS_CONST_ENUM = 512;
      var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
      var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
      var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
      var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
      var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
      var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
      var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
      var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
      var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
      var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      var CLASS_ELEMENT_FLAG_STATIC = 4;
      var CLASS_ELEMENT_KIND_GETTER = 2;
      var CLASS_ELEMENT_KIND_SETTER = 1;
      var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
      var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_OTHER = 0;
      var BaseParser = class {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin, name) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
        }
      };
      function setTrailingComments(node, comments) {
        if (node.trailingComments === void 0) {
          node.trailingComments = comments;
        } else {
          node.trailingComments.unshift(...comments);
        }
      }
      function setLeadingComments(node, comments) {
        if (node.leadingComments === void 0) {
          node.leadingComments = comments;
        } else {
          node.leadingComments.unshift(...comments);
        }
      }
      function setInnerComments(node, comments) {
        if (node.innerComments === void 0) {
          node.innerComments = comments;
        } else {
          node.innerComments.unshift(...comments);
        }
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null;
        let i = elements.length;
        while (lastElement === null && i > 0) {
          lastElement = elements[--i];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      var CommentsParser = class extends BaseParser {
        addComment(comment) {
          if (this.filename)
            comment.loc.filename = this.filename;
          this.state.comments.push(comment);
        }
        processComment(node) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          const lastCommentWS = commentStack[i];
          if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
          }
          const {
            start: nodeStart
          } = node;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
              commentWS.containingNode = node;
              this.finalizeComment(commentWS);
              commentStack.splice(i, 1);
            } else {
              if (commentEnd === nodeStart) {
                commentWS.trailingNode = node;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments);
            }
          } else {
            const {
              containingNode: node,
              start: commentStart
            } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) {
              switch (node.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node, node.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node, node.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node, node.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node, comments);
                }
              }
            } else {
              setInnerComments(node, comments);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
          }
        }
        takeSurroundingComments(node, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) {
              commentWS.leadingNode = node;
            } else if (commentEnd === start) {
              commentWS.trailingNode = node;
            } else if (commentEnd < start) {
              break;
            }
          }
        }
      };
      var lineBreak = /\r\n?|[\n\u2028\u2029]/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        switch (code) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
      var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace2(code) {
        switch (code) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      var State2 = class {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.decoratorStack = [[]];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 135;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State2();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      };
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let containsInvalid = false;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            let escaped;
            ({
              ch: escaped,
              pos,
              lineStart,
              curLine
            } = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors));
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          containsInvalid,
          lineStart,
          curLine
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code;
            ({
              code,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            let code;
            ({
              code,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCodePoint(code));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = input.charCodeAt(pos);
          let val;
          if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code;
        if (ch === 123) {
          ++pos;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code,
          pos
        };
      }
      var _excluded = ["at"];
      var _excluded2 = ["at"];
      function buildPosition(pos, lineStart, curLine) {
        return new Position(curLine, pos - lineStart, pos);
      }
      var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      var Token = class {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      };
      var Tokenizer2 = class extends CommentsParser {
        constructor(options, input) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix) => {
              if (!this.options.errorRecovery)
                return false;
              this.raise(Errors.InvalidDigit, {
                at: buildPosition(pos, lineStart, curLine),
                radix
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
          };
          this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
          });
          this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: buildPosition(pos, lineStart, curLine)
              });
            },
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, {
                at: buildPosition(pos - 1, lineStart, curLine)
              });
            }
          });
          this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: buildPosition(pos, lineStart, curLine)
              });
            }
          });
          this.state = new State2();
          this.state.init(options);
          this.input = input;
          this.length = input.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type) {
          if (this.match(type)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
              at
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(135);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf("*/", start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + 2;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead)
            return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead)
            return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments = [];
          loop:
            while (this.state.pos < this.length) {
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const comment = this.skipBlockComment();
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    case 47: {
                      const comment = this.skipLineComment(2);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (isWhitespace2(ch)) {
                    ++this.state.pos;
                  } else if (ch === 45 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                      const comment = this.skipLineComment(3);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else if (ch === 60 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                      const comment = this.skipLineComment(4);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else {
                    break loop;
                  }
              }
            }
          if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
              start: spaceStart,
              end,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type) {
          this.state.type = type;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
              throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1(next));
          } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
          }
          if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2)
            return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33)
            return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code) {
          let type = code === 42 ? 55 : 54;
          let width = 1;
          let next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
          }
          if (next === 61 && !this.state.inType) {
            width++;
            type = code === 37 ? 33 : 30;
          }
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code === 124) {
            if (next === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              throw this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            this.finishOp(34, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          const next2 = this.input.charCodeAt(this.state.pos + 2);
          if (next === 63) {
            if (next2 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code) {
          switch (code) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(code)) {
                this.readWord(code);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                this.expectPlugin("regexpUnicodeSets", nextPos());
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(133, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen = false, allowNumSeparator = true) {
          const {
            n,
            pos
          } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt);
          this.state.pos = pos;
          return n;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next = this.input.charCodeAt(this.state.pos);
          if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(131, str);
            return;
          }
          this.finishToken(130, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if (next === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(131, str);
            return;
          }
          if (isDecimal) {
            this.finishToken(132, str);
            return;
          }
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(130, val);
        }
        readCodePoint(throwOnInvalid) {
          const {
            code,
            pos
          } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
          this.state.pos = pos;
          return code;
        }
        readString(quote) {
          const {
            str,
            pos,
            curLine,
            lineStart
          } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          this.finishToken(129, str);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const opening = this.input[this.state.pos];
          const {
            str,
            containsInvalid,
            pos,
            curLine,
            lineStart
          } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, containsInvalid ? null : opening + str + "`");
          } else {
            this.state.pos++;
            this.finishToken(25, containsInvalid ? null : opening + str + "${");
          }
        }
        recordStrictModeErrors(toParseError, {
          at
        }) {
          const index = at.index;
          if (this.state.strict && !this.state.strictErrors.has(index)) {
            this.raise(toParseError, {
              at
            });
          } else {
            this.state.strictErrors.set(index, [toParseError, at]);
          }
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode);
          const type = keywords$1.get(word);
          if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
          } else {
            this.finishToken(128, word);
          }
        }
        checkKeywordEscapes() {
          const {
            type
          } = this.state;
          if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at instanceof Position ? at : at.loc.start;
          const error = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery)
            throw error;
          if (!this.isLookahead)
            this.state.errors.push(error);
          return error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at instanceof Position ? at : at.loc.start;
          const pos = loc.index;
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.loc.index === pos) {
              return errors[i] = toParseError({
                loc,
                details
              });
            }
            if (error.loc.index < pos)
              break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
        errorBuilder(error) {
          return (pos, lineStart, curLine) => {
            this.raise(error, {
              at: buildPosition(pos, lineStart, curLine)
            });
          };
        }
      };
      var Scope = class {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      };
      var ScopeHandler = class {
        constructor(parser, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser;
          this.inModule = inModule;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
        }
        declareName(name, bindingType, loc) {
          let scope = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope.functions.add(name);
            } else {
              scope.lexical.add(name);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope, name);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
              scope = this.scopeStack[i];
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              scope.var.add(name);
              this.maybeExportDefined(scope, name);
              if (scope.flags & SCOPE_VAR)
                break;
            }
          }
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        maybeExportDefined(scope, name) {
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        checkRedeclarationInScope(scope, name, bindingType, loc) {
          if (this.isRedeclaredInScope(scope, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE))
            return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
          }
          return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
        }
        checkLocalExport(id) {
          const {
            name
          } = id;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      };
      var FlowScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      };
      var FlowScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
            scope.declareFunctions.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (super.isRedeclaredInScope(scope, name, bindingType))
            return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
          }
          return false;
        }
        checkLocalExport(id) {
          if (!this.scopeStack[0].declareFunctions.has(id.name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var ClassScope = class {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      };
      var ClassScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name)) {
                current.undefinedPrivateNames.set(name, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name
              });
            }
          }
        }
        declarePrivateName(name, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined)
                loneAccessors.delete(name);
            } else if (!redefined) {
              loneAccessors.set(name, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
          privateNames.add(name);
          undefinedPrivateNames.delete(name);
        }
        usePrivateName(name, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name))
              return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name
            });
          }
        }
      };
      var kExpression = 0;
      var kMaybeArrowParameterDeclaration = 1;
      var kMaybeAsyncArrowParameterDeclaration = 2;
      var kParameterDeclaration = 3;
      var ExpressionScope = class {
        constructor(type = kExpression) {
          this.type = void 0;
          this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      };
      var ArrowHeadParsingScope = class extends ExpressionScope {
        constructor(type) {
          super(type);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at
        }) {
          const index = at.index;
          this.declarationErrors.set(index, [ParsingErrorClass, at]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      };
      var ExpressionScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node
        }) {
          const origin = {
            at: node.loc.start
          };
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (!scope.isCertainlyParameterDeclaration()) {
            if (scope.canBeArrowParameterDeclaration()) {
              scope.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope = stack[--i];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParemeterBindingError(error, {
          at: node
        }) {
          const {
            stack
          } = this;
          const scope = stack[stack.length - 1];
          const origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
          } else if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(error, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at
        }) {
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
              scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
              });
            }
            scope = stack[--i];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration())
            return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i = stack.length - 2;
            let scope = stack[i];
            while (scope.canBeArrowParameterDeclaration()) {
              scope.clearDeclarationError(loc.index);
              scope = stack[--i];
            }
          });
        }
      };
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      var PARAM = 0;
      var PARAM_YIELD = 1;
      var PARAM_AWAIT = 2;
      var PARAM_RETURN = 4;
      var PARAM_IN = 8;
      var ProductionParameterHandler = class {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      };
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      var UtilParser = class extends Tokenizer2 {
        addExtra(node, key, value, enumerable = true) {
          if (!node)
            return;
          const extra = node.extra = node.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name) {
          const nameEnd = nameStart + name.length;
          if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn((node2 = null) => {
              abortSignal.node = node2;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) {
              return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors)
            return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return node.type === "PrivateName";
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
        }
        isOptionalChain(node) {
          return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
        }
        isObjectProperty(node) {
          return node.type === "ObjectProperty";
        }
        isObjectMethod(node) {
          return node.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      };
      var ExpressionErrors = class {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      };
      var Node2 = class {
        constructor(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser != null && parser.options.ranges)
            this.range = [pos, 0];
          if (parser != null && parser.filename)
            this.loc.filename = parser.filename;
        }
      };
      var NodePrototype = Node2.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node2();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node) {
        return cloneIdentifier(node);
      }
      function cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra,
          name
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.name = name;
        if (type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        if (type === "Placeholder") {
          return clonePlaceholder(node);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        if (node.raw !== void 0) {
          cloned.raw = node.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node.value;
        return cloned;
      }
      var NodeUtils = class extends UtilParser {
        startNode() {
          return new Node2(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(pos, loc) {
          return new Node2(this, pos, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.start, type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          node.type = type;
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
          if (this.options.attachComment)
            this.processComment(node);
          return node;
        }
        resetStartLocation(node, start, startLoc) {
          node.start = start;
          node.loc.start = startLoc;
          if (this.options.ranges)
            node.range[0] = start;
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
        }
      };
      var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      var FlowErrors = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`,
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
        EnumDuplicateMemberName: ({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
        EnumInconsistentMemberValues: ({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
        EnumInvalidMemberName: ({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
        EnumNumberMemberNotInitialized: ({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign({
          message: "A binding pattern parameter cannot be optional in an implementation signature."
        }, {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`,
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      });
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node) {
        return node.importKind === "type" || node.importKind === "typeof";
      }
      function isMaybeDefaultImport(type) {
        return tokenIsKeywordOrIdentifier(type) && type !== 97;
      }
      var exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list, test) {
        const list1 = [];
        const list2 = [];
        for (let i = 0; i < list.length; i++) {
          (test(list[i], i, list) ? list1 : list2).push(list[i]);
        }
        return [list1, list2];
      }
      var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow = (superClass) => class FlowParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
          if (type !== 129 && type !== 13 && type !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          return super.finishToken(type, val);
        }
        addComment(comment) {
          if (this.flowPragma === void 0) {
            const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches)
              ;
            else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          return super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
        flowParsePredicate() {
          const node = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(107);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node.value = super.parseExpression();
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type, predicate];
        }
        flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
          this.next();
          const id = node.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(123)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(126)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(125)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
        flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(129)) {
            node.id = super.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }
          const bodyNode = node.body = this.startNode();
          const body = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(126) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              super.parseImport(bodyNode2);
            } else {
              this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }
            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
              node = this.parseExport(node);
              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }
              node.type = "Declare" + node.type;
              return node;
            }
          }
          throw this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(108);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
          this.next();
          const finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
        flowParseDeclareOpaqueType(node) {
          this.next();
          const finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
        flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass = false) {
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.extends = [];
          node.implements = [];
          node.mixins = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (this.isContextual(114)) {
            this.next();
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.isContextual(110)) {
            this.next();
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word))
            return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
          this.expectContextual(126);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.supertype = null;
          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }
          node.impltype = null;
          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node = this.startNode();
          node.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node = this.startNode();
          this.expectContextual(125);
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(130) || this.match(129) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;
          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }
          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;
            if (this.eat(17)) {
              node.optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node.this = null;
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node.this = this.flowParseFunctionTypeParam(true);
            node.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
          const valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node = this.startNode();
            if (allowProto && this.isContextual(115)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
              if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value.this
                });
              }
            } else {
              if (kind !== "init")
                this.unexpected();
              node.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }
            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property) {
          const paramCount = property.kind === "get" ? 0 : 1;
          const length = property.value.params.length + (property.value.rest ? 1 : 0);
          if (property.value.this) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }
          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          let node = id || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }
          return node;
        }
        flowParseGenericType(startPos, startLoc, id) {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node = this.startNode();
          node.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3))
              break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name = null;
          let optional = false;
          let typeAnnotation = null;
          const node = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }
            name = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
          const node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
        flowParsePrimaryType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.startNode();
          let tmp;
          let type;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;
            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(130)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }
                if (this.match(131)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();
            case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(125)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
              }
          }
          throw this.unexpected();
        }
        flowParsePostfixType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let type = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node = this.startNodeAt(startPos, startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }
          return type;
        }
        flowParsePrefixType() {
          const node = this.startNode();
          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.this = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node = this.startNode();
          this.eat(45);
          const type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];
          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node = this.startNode();
          this.eat(43);
          const type = this.flowParseIntersectionType();
          node.types = [type];
          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 128 && this.state.value === "_") {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            return this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          }
          return super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatement(context, topLevel) {
          if (this.state.strict && this.isContextual(125)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          const stmt = super.parseStatement(context, topLevel);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.match(17))
            return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node = this.startNodeAt(startPos, startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
          const stack = [node];
          const arrows = [];
          while (stack.length !== 0) {
            const node2 = stack.pop();
            if (node2.type === "ArrowFunctionExpression") {
              if (node2.typeParameters || !node2.returnType) {
                this.finishArrowValidation(node2);
              } else {
                arrows.push(node2);
              }
              stack.push(node2.body);
            } else if (node2.type === "ConditionalExpression") {
              stack.push(node2.consequent);
              stack.push(node2.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node2) => this.finishArrowValidation(node2));
            return [arrows, []];
          }
          return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
          var _node$extra;
          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse3) {
          let result;
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse3();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse3();
          }
          return result;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        }
        assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node);
        }
        parseExport(node) {
          const decl = super.parseExport(node);
          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }
          return decl;
        }
        parseExportDeclaration(node) {
          if (this.isContextual(126)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);
              super.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(127)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(125)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            node.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node);
          }
        }
        eatExportStar(node) {
          if (super.eatExportStar(node))
            return true;
          if (this.isContextual(126) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
          super.parseClassId(node, isStatement, optionalId);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(121)) {
            if (super.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
          const word = super.readWord1();
          const fullWord = "@@" + word;
          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(128, fullWord);
        }
        getTokenFromCode(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 123 && next === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(code === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code === 63) {
            if (next === 46) {
              return this.finishOp(18, 2);
            }
            return this.finishOp(17, 1);
          } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return super.getTokenFromCode(code);
          }
        }
        isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
          super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i = 0; i < exprList.length; i++) {
            var _expr$extra;
            const expr = exprList[i];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }
          return node;
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
          return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method.params && isConstructor) {
            const params = method.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            const params = method.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(110)) {
            this.next();
            const implemented = node.implements = [];
            do {
              const node2 = this.startNode();
              node2.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              implemented.push(this.finishNode(node2, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method) {
          super.checkGetterSetterParams(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10))
              this.unexpected();
          }
          const result = super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }
          return result;
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return super.shouldParseDefaultImport(node);
          }
          return isMaybeDefaultImport(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          let kind = null;
          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(126)) {
            kind = "type";
          }
          if (kind) {
            const lh = this.lookahead();
            const {
              type
            } = lh;
            if (kind === "type" && type === 55) {
              this.unexpected(null, lh.type);
            }
            if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
              this.next();
              node.importKind = kind;
            }
          }
          return super.maybeParseDefaultImportSpecifier(node);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node, allowModifiers) {
          const kind = node.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
                abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression")
                abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(19))
                this.unexpected();
              return typeNode;
            });
            if (result.thrown)
              return null;
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            super.setArrowFunctionParameters(node, params);
          }
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }
          for (let i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
            }
          }
          return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = super.parseCallExpressionArguments(11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
            if (result.node && !result.error)
              return result.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result.node) {
              this.state = result.failState;
              return result.node;
            }
            throw arrow.error || result.error;
          }
          return super.parseSubscripts(base, startPos, startLoc, noCalls);
        }
        parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const result = this.tryParse(() => {
              node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node.arguments = super.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember) {
                node.optional = false;
              }
              return this.finishCallExpression(node, subscriptState.optionalChainMember);
            });
            if (result.node) {
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
          super.parseNewCallee(node);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node))
            return;
          return super.parseArrowExpression(node, void 0, true);
        }
        readToken_mult_modulo(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code);
        }
        parseTopLevel(file, program) {
          const fileNode = super.parseTopLevel(file, program);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            const commentSkip = this.skipFlowComment();
            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }
            return;
          }
          if (this.state.hasFlowComment) {
            const end = this.input.indexOf("*-/", this.state.pos + 2);
            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }
            this.state.pos = end + 2 + 3;
            return;
          }
          return super.skipBlockComment();
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 130: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 129: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id = this.parseIdentifier(true);
          const init = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id,
            init
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          const {
            explicitType
          } = context;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id,
              init
            } = this.flowEnumMemberRaw();
            const memberName = id.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id;
            switch (init.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101))
            return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node, id) {
          const enumName = id.name;
          const nameLoc = id.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");
            default: {
              const empty = () => {
                node.members = [];
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node) {
          const id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next = this.nextTokenStart();
          if (this.input.charCodeAt(next) === 60) {
            const afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      };
      var entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
      var JsxErrors = ParseErrorEnum`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      });
      function isFragment(object) {
        return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object) {
        if (object.type === "JSXIdentifier") {
          return object.name;
        }
        if (object.type === "JSXNamespacedName") {
          return object.namespace.name + ":" + object.name.name;
        }
        if (object.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        }
        throw new Error("Node had unexpected type: " + object.type);
      }
      var jsx = (superClass) => class JSXParserMixin extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(138);
                  }
                  return super.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(137, out);
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(129, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(136, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node = this.startNode();
          if (this.match(136)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const name = this.jsxParseIdentifier();
          if (!this.eat(14))
            return name;
          const node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let node = this.jsxParseNamespacedName();
          if (node.type === "JSXNamespacedName") {
            return node;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsxParseAttributeValue() {
          let node;
          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);
              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }
              return node;
            case 138:
            case 129:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node = this.startNode();
          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }
          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
          const attributes = [];
          while (!this.match(56) && !this.match(139)) {
            attributes.push(this.jsxParseAttribute());
          }
          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(139);
          return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXClosingFragment");
          }
          node.name = this.jsxParseElementName();
          this.expect(139);
          return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          const children2 = [];
          const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.state.type) {
                  case 138:
                    startPos = this.state.start;
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children2.push(this.jsxParseElementAt(startPos, startLoc));
                    break;
                  case 137:
                    children2.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const node2 = this.startNode();
                    this.setContext(types.brace);
                    this.next();
                    if (this.match(21)) {
                      children2.push(this.jsxParseSpreadChild(node2));
                    } else {
                      children2.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                    }
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }
          node.children = children2;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
        setContext(newContext) {
          const {
            context
          } = this.state;
          context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(137)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(138)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace)
            super.skipSpace();
        }
        getTokenFromCode(code) {
          const context = this.curContext();
          if (context === types.j_expr) {
            return this.jsxReadToken();
          }
          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }
            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(139);
            }
            if ((code === 34 || code === 39) && context === types.j_oTag) {
              return this.jsxReadString(code);
            }
          }
          if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(138);
          }
          return super.getTokenFromCode(code);
        }
        updateContext(prevType) {
          const {
            context,
            type
          } = this.state;
          if (type === 56 && prevType === 138) {
            context.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 138) {
            context.push(types.j_oTag);
          } else if (type === 139) {
            const out = context[context.length - 1];
            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      };
      var TypeScriptScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      };
      var TypeScriptScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new TypeScriptScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name);
            scope.exportOnlyBindings.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              this.maybeExportDefined(scope, name);
            }
            scope.types.add(name);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM)
            scope.enums.add(name);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
            scope.constEnums.add(name);
          if (bindingType & BIND_FLAGS_CLASS)
            scope.classes.add(name);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (scope.enums.has(name)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope.constEnums.has(name);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
            if (scope.lexical.has(name)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
            return true;
          }
          return super.isRedeclaredInScope(scope, name, bindingType);
        }
        checkLocalExport(id) {
          const topLevelScope = this.scopeStack[0];
          const {
            name
          } = id;
          if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      function nonNull(x) {
        if (x == null) {
          throw new Error(`Unexpected ${x} value.`);
        }
        return x;
      }
      function assert(x) {
        if (!x) {
          throw new Error("Assert fail");
        }
      }
      var TSErrors = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        CannotFindName: ({
          name
        }) => `Cannot find name '${name}'.`,
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({
          modifier
        }) => `Accessibility modifier already seen.`,
        DuplicateModifier: ({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`,
        EmptyHeritageClauseType: ({
          token
        }) => `'${token}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        IncompatibleModifiers: ({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({
          type
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
      });
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          modified,
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier)
              break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(kind, parseElement) {
          const result = [];
          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }
          return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          const result = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement();
            if (element == null) {
              return void 0;
            }
            result.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result;
        }
        tsParseImportType() {
          const node = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(129)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node.argument = super.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node = this.startNode();
          node.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
          const node = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeQuery");
        }
        tsParseInOutModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        tsParseNoneModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
        tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
          const node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node.default = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node = this.startNode();
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75)
            return null;
          this.next();
          const typeReference = this.tsParseTypeReference();
          if (typeReference.typeParameters) {
            this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            });
          }
          return typeReference;
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          return super.parseBindingList(11, 41).map((pattern) => {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }
            return pattern;
          });
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return void 0;
          }
          this.expect(0);
          const id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17))
            node.optional = true;
          const nodeAny = node;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }
            const method = nodeAny;
            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }
            return this.finishNode(method, "TSMethodSignature");
          } else {
            const property = nodeAny;
            if (readonly)
              property.readonly = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type)
              property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }
          if (this.match(77)) {
            const id = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          const idx = this.tsTryParseIndexSignature(node);
          if (idx) {
            return idx;
          }
          super.parsePropertyName(node);
          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
          }
          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
          const node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(118);
          }
          if (this.isContextual(118)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
          } else if (this.eatContextual(118)) {
            node.readonly = true;
          }
          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }
          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
          const node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            const {
              type
            } = elementNode;
            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            let checkType = type;
            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }
            const isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            start: startPos,
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let type = this.tsParseType();
          const optional = this.eat(17);
          const labeled = this.eat(14);
          if (labeled) {
            const labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
            }
            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }
          return type;
        }
        tsParseParenthesizedType() {
          const node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
          const node = this.startNode();
          if (type === "TSConstructorType") {
            node.abstract = !!abstract;
            if (abstract)
              this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
          return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
          const node = this.startNode();
          node.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return super.parseExprAtom();
              default:
                throw this.unexpected();
            }
          })();
          return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType)
            return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 130 && nextToken.type !== 131) {
                  throw this.unexpected();
                }
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type
              } = this.state;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node = this.startNode();
                  this.next();
                  return this.finishNode(node, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type;
              node.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(node, "TSIndexedAccessType");
            }
          }
          return type;
        }
        tsParseTypeOperator() {
          const node = this.startNode();
          const operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }
          return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
        tsParseInferType() {
          const node = this.startNode();
          this.expectContextual(112);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node.types = types2;
          return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              super.parseBindingList(3, 93, true);
              return errors.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node);
                thisTypePredicate.asserts = true;
              }
              t.typeAnnotation = thisTypePredicate;
              return this.finishNode(t, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t);
              }
              node.parameterName = this.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
              return this.finishNode(t, "TSTypeAnnotation");
            }
            const type = this.tsParseTypeAnnotation(false);
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id = this.parseIdentifier();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
          this.tsInType(() => {
            if (eatColon)
              this.expect(14);
            t.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        }
        tsParseType() {
          assert(this.state.inType);
          const type = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }
          const node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node = this.startNode();
            node.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties = {}) {
          if (this.hasFollowingLineBreak())
            return null;
          this.expectContextual(125);
          if (properties.declare)
            node.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause("extends");
          }
          const body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
            this.expect(29);
            if (this.isContextual(111) && this.lookahead().type !== 16) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          return !this.match(token) ? void 0 : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
          return this.tsDoThenParseType(() => this.expect(token));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(cb) {
          return this.tsInType(() => {
            cb();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node = this.startNode();
          node.id = this.match(129) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
          if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties = {}) {
          if (properties.const)
            node.const = true;
          if (properties.declare)
            node.declare = true;
          this.expectContextual(122);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
          node.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(109)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(129)) {
            node.id = super.parseStringLiteral(this.state.value);
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_LEXICAL);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node = this.startNode();
          this.expectContextual(116);
          this.expect(10);
          if (!this.match(129)) {
            throw this.unexpected();
          }
          node.expression = super.parseExprAtom();
          this.expect(11);
          return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
          const state = this.state.clone();
          const res = f();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f) {
          const result = this.tryParse((abort) => f() || abort());
          if (result.aborted || !result.node)
            return void 0;
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        tsTryParse(f) {
          const state = this.state.clone();
          const result = f();
          if (result !== void 0 && result !== false) {
            return result;
          } else {
            this.state = state;
            return void 0;
          }
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let starttype = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            if (starttype === 68) {
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, true);
            }
            if (starttype === 80) {
              nany.declare = true;
              return this.parseClass(nany, true, false);
            }
            if (starttype === 122) {
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }
            if (starttype === 109) {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            }
            if (starttype === 75 || starttype === 74) {
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            }
            if (starttype === 125) {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result)
                return result;
            }
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true);
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
        tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare": {
              const declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
                return declaration;
              }
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
        tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(129)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
          }
        }
        tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak())
              return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          if (!this.match(47)) {
            return void 0;
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startPos, startLoc);
            node.typeParameters = this.tsParseTypeParameters();
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res) {
            return void 0;
          }
          return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return void 0;
          }
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node = this.startNode();
          node.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          }
          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart())
            return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let accessibility;
          let readonly = false;
          let override = false;
          if (allowModifiers !== void 0) {
            const modified = {};
            this.tsParseModifiers({
              modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;
            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startPos, startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility)
              pp.accessibility = accessibility;
            if (readonly)
              pp.readonly = readonly;
            if (override)
              pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });
            if (node.declare) {
              return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(node);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node) => {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments)
                return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result2 = super.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
              if (!noCalls && this.eat(10)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node2.arguments);
                node2.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node2.optional = isOptionalCall;
                }
                return this.finishCallExpression(node2, state.optionalChainMember);
              }
              const tokenType = this.state.type;
              if (tokenType === 48 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node = this.startNodeAt(startPos, startLoc);
              node.expression = base;
              node.typeParameters = typeArguments;
              return this.finishNode(node, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
          var _callee$extra;
          super.parseNewCallee(node);
          const {
            callee
          } = node;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        checkDuplicateExports() {
        }
        parseImport(node) {
          node.importKind = "value";
          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            let ahead = this.lookahead();
            if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }
            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }
          const importNode = super.parseImport(node);
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node) {
          if (this.match(83)) {
            this.next();
            if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(29)) {
            const assign = node;
            assign.expression = super.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(126) && this.lookahead().type === 5) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }
            return super.parseExport(node);
          }
        }
        isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
          }
          if (this.match(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext)
            return declaration;
          for (const {
            id,
            init
          } of declaration.declarations) {
            if (!init)
              continue;
            if (kind !== "const" || !!id.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init
              });
            } else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init
              });
            }
          }
          return declaration;
        }
        parseStatementContent(context, topLevel) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              const: true
            });
          }
          if (this.isContextual(122)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseStatementContent(context, topLevel);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              super.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional)
            methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node, expr) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
          return decl || super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart())
            return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
          }
          const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
          if (!result.node) {
            if (result.error) {
              super.setOptionalParametersError(refExpressionErrors, result.error);
            }
            return expr;
          }
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node;
        }
        parseExportDeclaration(node) {
          if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(121);
          if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier = tokenIsIdentifier(this.state.type);
          const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
          if (!declaration)
            return null;
          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }
          return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(110)) {
            return;
          }
          super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters)
            node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(35)) {
            node.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
        }
        parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node.abstract && this.match(29)) {
            const {
              key
            } = node;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }
          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node);
          return super.parseClassPrivateProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            });
          }
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod")
            return;
          if (node.type === "MethodDefinition" && !node.value.body)
            return;
          super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(110)) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            prop.typeParameters = typeParameters;
          return super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, allowModifiers) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            node.typeParameters = typeParameters;
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          if (!state || state === this.state)
            state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters();
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!typeCast.error)
              return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
            throw typeCast.error;
          throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node) {
          var _node$extra;
          if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return super.parseMaybeUnary(refExpressionErrors, sawUnary);
          }
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19))
                abort();
              return returnType;
            });
            if (result.aborted)
              return;
            if (!result.thrown) {
              if (result.error)
                this.state = result.failState;
              node.returnType = result.node;
            }
          }
          return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }
              this.toAssignable(node.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }
            default:
              super.toAssignable(node, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;
            default:
              super.toAssignable(node, isLHS);
          }
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;
            default:
              super.checkToRestConversion(node, allowPattern);
          }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return super.checkCommaAfterRest(close);
          }
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        getTokenFromCode(code) {
          if (this.state.inType) {
            if (code === 62) {
              return this.finishOp(48, 1);
            }
            if (code === 60) {
              return this.finishOp(47, 1);
            }
          }
          return super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
          const {
            type
          } = this.state;
          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type
          } = this.state;
          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments)
              node.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
          const baseCount = super.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node, isStatement, optionalId) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node.abstract;
          try {
            return super.parseClass(node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node) {
          if (this.match(80)) {
            node.abstract = true;
            return this.parseClass(node, true, false);
          } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
              node.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          if (method.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
            if (hasBody) {
              const {
                key
              } = method;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }
          node.exportKind = "value";
          return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], BIND_LEXICAL);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression")
          return false;
        const {
          computed,
          property
        } = expression;
        if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier")
          return true;
        if (expression.type !== "MemberExpression")
          return false;
        if (expression.computed)
          return false;
        return isUncomputedMemberExpressionChain(expression.object);
      }
      var PlaceholderErrors = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
      });
      var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(140)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(140);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
        finishPlaceholder(node, expectedNode) {
          const isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(140, 2);
          }
          return super.getTokenFromCode(code);
        }
        parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        isLet(context) {
          if (super.isLet(context)) {
            return true;
          }
          if (!this.isContextual(99)) {
            return false;
          }
          if (context)
            return false;
          const nextToken = this.lookahead();
          if (nextToken.type === 140) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder")
            return;
          super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(node, expr);
          }
          if (this.match(14)) {
            const stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = super.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
          const type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(140) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }
          super.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
        parseExport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseExport(node);
          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next = this.nextTokenStart();
            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(node);
        }
        checkExport(node) {
          const {
            specifiers
          } = node;
          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
          }
          super.checkExport(node);
          node.specifiers = specifiers;
        }
        parseImport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseImport(node);
          node.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport)
              this.parseNamedImportSpecifiers(node);
          }
          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name = this.parseIdentifierName(this.state.start);
              const identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p) => {
          if (typeof p === "string") {
            return expectedOptionsIsEmpty && p === expectedName;
          } else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name, option) {
        const plugin = plugins.find((plugin2) => {
          if (Array.isArray(plugin2)) {
            return plugin2[0] === name;
          } else {
            return plugin2 === name;
          }
        });
        if (plugin && Array.isArray(plugin) && plugin.length > 1) {
          return plugin[1][option];
        }
        return null;
      }
      var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport == null) {
            throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
          } else if (typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error.missingPlugins = "doExpressions";
          throw error;
        }
      }
      var mixinPlugins = {
        estree,
        jsx,
        flow,
        typescript,
        v8intrinsic,
        placeholders
      };
      var mixinPluginNames = Object.keys(mixinPlugins);
      var defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true
      };
      function getOptions(opts) {
        const options = {};
        for (const key of Object.keys(defaultOptions)) {
          options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options;
      }
      var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      var unwrapParenthesizedExpression = (node) => {
        return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
      };
      var LValParser = class extends NodeUtils {
        toAssignable(node, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          }
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                var _node$extra2;
                const prop = node.properties[i];
                const isLast = i === last;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node.left.loc.end
                });
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            if (!elt)
              continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last = node.properties.length - 1;
              return node.properties.every((prop, i) => {
                return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node.value);
            case "SpreadElement":
              return this.isAssignable(node.argument);
            case "ArrayExpression":
              return node.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors) {
          const node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
          return this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          this.next();
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(3, 93, true);
              return this.finishNode(node, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type,
            start: startPos,
            startLoc
          } = this.state;
          if (type === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type === 134) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          return this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          var _startLoc, _startPos, _left;
          startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
          startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29))
            return left;
          const node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type);
        }
        checkLVal(expression, {
          in: ancestor,
          binding = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression))
            return;
          if (type === "MemberExpression") {
            if (binding !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (expression.type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
            const {
              name
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name);
              }
            }
            return;
          }
          const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
          if (validity === true)
            return;
          if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor: ancestor.type === "UpdateExpression" ? {
                type: "UpdateExpression",
                prefix: ancestor.prefix
              } : {
                type: ancestor.type
              }
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
          const nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding,
                checkClashes,
                allowingSloppyLetBinding,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
              });
            }
          }
          if (!allowLetBinding && at.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at, bindingType);
          }
        }
        declareNameFromIdentifier(identifier, binding) {
          this.scope.declareName(identifier.name, binding, identifier.loc.start);
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern)
                break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      };
      var ExpressionParser = class extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name = key.type === "Identifier" ? key.name : key.value;
          if (name === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(135)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(12)) {
              node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          if (this.isContextual(105)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startPos, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type
          } = this.state;
          if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startPos, startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node.left = left;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node.left = left;
            }
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startPos, startLoc, -1);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.left = left;
              node.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node.right = this.parseExprOpRightExpr(op, prec);
              const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(finishedNode, leftStartPos, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(105)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
          if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body;
        }
        checkExponentialAfterUnary(node) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startPos, startLoc);
            if (!sawUnary)
              this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node
                });
              }
            }
            if (!update) {
              if (!sawUnary) {
                this.checkExponentialAfterUnary(node);
              }
              return this.finishNode(node, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {
              type
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startPos, startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
              in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node2, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startPos, startLoc);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
          };
          do {
            base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const {
            type
          } = this.state;
          if (!noCalls && type === 15) {
            return this.parseBind(base, startPos, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
          }
          let optional = false;
          if (type === 18) {
            if (noCalls && this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
          } else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) {
              return this.parseMember(base, startPos, startLoc, state, computed, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
        }
        parseMember(base, startPos, startLoc, state, computed, optional) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.computed = computed;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(134)) {
            if (base.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
          } else {
            node.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
          } else {
            return this.finishNode(node, "MemberExpression");
          }
        }
        parseBind(base, startPos, startLoc, noCalls, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          this.next();
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node.optional = optional;
          }
          if (optional) {
            node.arguments = this.parseCallExpressionArguments(11);
          } else {
            node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
          }
          let finishedNode = this.finishCallExpression(node, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), finishedNode);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return finishedNode;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startPos, startLoc, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node, optional) {
          if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node, call.callee.trailingComments);
          }
          return node;
        }
        parseNoCallExpr() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          const {
            type
          } = this.state;
          switch (type) {
            case 79:
              return this.parseSuper();
            case 83:
              node = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node, "Import");
            case 78:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 130:
              return this.parseNumericLiteral(this.state.value);
            case 131:
              return this.parseBigIntLiteral(this.state.value);
            case 132:
              return this.parseDecimalLiteral(this.state.value);
            case 129:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              this.parseDecorators();
            case 80:
              node = this.startNode();
              this.takeDecorators(node);
              return this.parseClass(node, false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node = this.startNode();
              this.next();
              node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 134: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              } else {
                throw this.unexpected();
              }
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else {
                throw this.unexpected();
              }
            }
            default:
              if (tokenIsIdentifier(type)) {
                if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type2
                  } = this.state;
                  if (type2 === 68) {
                    this.resetPreviousNodeTrailingComments(id);
                    this.next();
                    return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                  } else if (tokenIsIdentifier(type2)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                    } else {
                      return id;
                    }
                  } else if (type2 === 90) {
                    this.resetPreviousNodeTrailingComments(id);
                    return this.parseDo(this.startNodeAtNode(id), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              } else {
                throw this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            throw this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType = this.state.type;
          this.next();
          return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType)
              }]);
            }
            case "smart":
              return tokenType === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          return this.parseArrowExpression(node, params, true);
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node
            });
          }
          return this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode();
          const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
          const name = this.state.value;
          this.next();
          node.id = this.createIdentifier(id, name);
          return this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          node.property = this.parseIdentifier(true);
          if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          this.addExtra(node, "rawValue", value);
          this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
          node.value = value;
          this.next();
          return this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          node.value = value;
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartPos = this.state.start;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartPos = this.state.start;
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startPos, startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startPos, startLoc, val);
        }
        wrapParenthesis(startPos, startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startPos);
            this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startPos, startLoc);
          parenExpression.expression = expression;
          return this.finishNode(parenExpression, "ParenthesizedExpression");
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) {
            return node;
          }
        }
        parseParenItem(node, startPos, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          this.parseNewCallee(node);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
          } else {
            node.arguments = [];
          }
          return this.finishNode(node, "NewExpression");
        }
        parseNewCallee(node) {
          node.callee = this.parseNoCallExpr();
          if (node.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node.callee
            });
          } else if (this.isOptionalChain(node.callee)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.lastTokEndLoc
            });
          } else if (this.eat(18)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(startLoc, 2)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          const finishedNode = this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return finishedNode;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node.quasis = [curElt];
          while (!curElt.tail) {
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node = this.startNode();
          node.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          if (isPattern) {
            type = "ObjectPattern";
          } else if (isRecord) {
            type = "RecordExpression";
          }
          return this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startPos;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length)
              this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startPos = this.state.start;
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        }
        getGetterSetterExpectedParamCount(method) {
          return method.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length !== paramCount) {
            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method
            });
          }
          if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern)
              this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (!node)
            this.unexpected();
          return node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type) {
                case 130:
                  key = this.parseNumericLiteral(value);
                  break;
                case 129:
                  key = this.parseStringLiteral(value);
                  break;
                case 131:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 132:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 134: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            prop.key = key;
            if (type !== 134) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null;
          node.generator = false;
          node.async = !!isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          this.initFunction(node, isAsync);
          node.generator = !!isGenerator;
          const allowModifiers = isConstructor;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          this.parseFunctionParams(node, allowModifiers);
          const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
          this.prodParam.exit();
          this.scope.exit();
          return finishedNode;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node.params = params;
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          this.parseFunctionBody(node, false, isMethod);
          return this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return node.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
              return false;
          }
          return true;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode();
          const name = this.parseIdentifierName(node.start, liberal);
          return this.createIdentifier(node, name);
        }
        createIdentifier(node, name) {
          node.name = name;
          node.loc.identifierName = name;
          return this.finishNode(node, "Identifier");
        }
        parseIdentifierName(pos, liberal) {
          let name;
          const {
            startLoc,
            type
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
          } else {
            throw this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(128);
            }
          } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) {
            return;
          }
          if (!canBeReservedWord(word)) {
            return;
          }
          if (word === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
          if (checkKeywords && isKeyword(word)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word
            });
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait)
            return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak())
            return true;
          const {
            type
          } = this.state;
          return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 135:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating)
                  break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node.delegate = delegating;
          node.argument = argument;
          return this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
          if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next();
          this.eat(5);
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          const program = this.startNode();
          try {
            node.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          this.eat(8);
          return this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      };
      var loopLabel = {
        kind: "loop"
      };
      var switchLabel = {
        kind: "switch"
      };
      var FUNC_NO_FLAGS = 0;
      var FUNC_STATEMENT = 1;
      var FUNC_HANGING_STATEMENT = 2;
      var FUNC_NULLABLE_ID = 4;
      var loneSurrogate = /[\uD800-\uDFFF]/u;
      var keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input) {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          const {
            type
          } = token;
          if (typeof type === "number") {
            {
              if (type === 134) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(128),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i++;
                continue;
              }
              if (tokenIsTemplate(type)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i += 2;
                continue;
              }
            }
            token.type = getExportedToken(type);
          }
        }
        return tokens;
      }
      var StatementParser = class extends ExpressionParser {
        parseTopLevel(file, program) {
          file.program = this.parseProgram(program);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program, end = 135, sourceType = this.options.sourceType) {
          program.sourceType = sourceType;
          program.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at,
                localName
              });
            }
          }
          return this.finishNode(program, "Program");
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node = this.startNode();
          node.value = this.state.value;
          this.next();
          return this.finishNode(node, "InterpreterDirective");
        }
        isLet(context) {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.isLetKeyword(context);
        }
        isLetKeyword(context) {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh === 92 || nextCh === 91) {
            return true;
          }
          if (context)
            return false;
          if (nextCh === 123)
            return true;
          if (isIdentifierStart(nextCh)) {
            keywordRelationalOperator.lastIndex = next;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        parseStatement(context, topLevel) {
          if (this.match(26)) {
            this.parseDecorators(true);
          }
          return this.parseStatementContent(context, topLevel);
        }
        parseStatementContent(context, topLevel) {
          let starttype = this.state.type;
          const node = this.startNode();
          let kind;
          if (this.isLet(context)) {
            starttype = 74;
            kind = "let";
          }
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node, true);
            case 63:
              return this.parseBreakContinueStatement(node, false);
            case 64:
              return this.parseDebuggerStatement(node);
            case 90:
              return this.parseDoStatement(node);
            case 91:
              return this.parseForStatement(node);
            case 68:
              if (this.lookaheadCharCode() === 46)
                break;
              if (context) {
                if (this.state.strict) {
                  this.raise(Errors.StrictFunction, {
                    at: this.state.startLoc
                  });
                } else if (context !== "if" && context !== "label") {
                  this.raise(Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
              }
              return this.parseFunctionStatement(node, false, !context);
            case 80:
              if (context)
                this.unexpected();
              return this.parseClass(node, true);
            case 69:
              return this.parseIfStatement(node);
            case 70:
              return this.parseReturnStatement(node);
            case 71:
              return this.parseSwitchStatement(node);
            case 72:
              return this.parseThrowStatement(node);
            case 73:
              return this.parseTryStatement(node);
            case 75:
            case 74:
              kind = kind || this.state.value;
              if (context && kind !== "var") {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node, kind);
            case 92:
              return this.parseWhileStatement(node);
            case 76:
              return this.parseWithStatement(node);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result;
              if (starttype === 83) {
                result = this.parseImport(node);
                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node);
                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(result);
              return result;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (context) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node, true, !context);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
        assertModuleNodeAllowed(node) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node
            });
          }
        }
        takeDecorators(node) {
          const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (decorators.length) {
            node.decorators = decorators;
            this.resetStartLocationFromNode(node, decorators[0]);
            this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
          }
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          while (this.match(26)) {
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
          }
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startPos2 = this.state.start;
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startPos2, startLoc2, expr);
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.object = expr;
                node2.property = this.parseIdentifier(true);
                node2.computed = false;
                expr = this.finishNode(node2, "MemberExpression");
              }
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
            this.state.decoratorStack.pop();
          } else {
            node.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node.label = null;
          } else {
            node.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node, isBreak);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop"))
                break;
              if (node.label && isBreak)
                break;
            }
          }
          if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
          this.state.labels.pop();
          this.expect(92);
          node.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          const startsWithLet = this.isContextual(99);
          const isLet = startsWithLet && this.isLetKeyword();
          if (this.match(74) || this.match(75) || isLet) {
            const initNode = this.startNode();
            const kind = isLet ? "let" : this.state.value;
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            if ((this.match(58) || this.isContextual(101)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init
              });
            }
            if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init, {
              in: {
                type
              }
            });
            return this.parseForIn(node, init, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        }
        parseFunctionStatement(node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
        }
        parseIfStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(66) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next();
          node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur)
                this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatement(null));
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur)
            this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          const simple = param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_LEXICAL,
            allowingSloppyLetBinding: true
          });
          return param;
        }
        parseTryStatement(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node
            });
          }
          return this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
          this.state.labels.pop();
          return this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.object = this.parseHeaderExpression();
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
          return this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, context) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            if (label.statementStart === node.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.state.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node.body = [];
          const directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = this.parseStatement(null, topLevel);
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node, init) {
          node.init = init;
          this.semicolon(false);
          node.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null)
              this.unexpected(awaitAt);
          } else {
            node.await = awaitAt !== null;
          }
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = false) {
          const declarations = node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12))
              break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
        }
        parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
          const isStatement = statement & FUNC_STATEMENT;
          const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
          const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
          this.initFunction(node, isAsync);
          if (this.match(55) && isHangingStatement) {
            this.raise(Errors.GeneratorInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          node.generator = this.eat(55);
          if (isStatement) {
            node.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          if (!isStatement) {
            node.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isStatement && !isHangingStatement) {
            this.registerFunctionStatementId(node);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, allowModifiers) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node.params = this.parseBindingList(11, 41, false, allowModifiers);
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          if (!node.id)
            return;
          this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node, isStatement, optionalId);
          this.parseClassSuper(node);
          node.body = this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(134);
            this.parseClassElementName(method);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(134);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method.kind = "method";
            const isPrivate2 = this.match(134);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type,
            value
          } = this.state;
          if ((type === 128 || type === 129) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type === 134) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
          }
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node);
          const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault)
              this.unexpected();
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
            throw this.unexpected(null, 5);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            this.parseExportFrom(node, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            this.checkExport(node, true, false, !!node.source);
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            node.declaration = this.parseExportDefaultExpression();
            this.checkExport(node, true, true);
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          throw this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            if (!node.specifiers)
              node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            if (!node.specifiers)
              node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node) {
          if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95))
            return false;
          const next = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          const isAsync = this.isAsyncFunction();
          if (this.match(68) || isAsync) {
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            this.parseDecorators(false);
            return this.parseClass(expr, true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) {
              return false;
            }
            if ((type === 126 || type === 125) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next, "from");
          if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node.assertions = assertions;
              this.checkJSONModuleImport(node);
            }
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (type === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                throw this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration = node.declaration;
                if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration
                  });
                }
              }
            } else if (node.specifiers && node.specifiers.length) {
              for (const specifier of node.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node.declaration) {
              if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                const id = node.declaration.id;
                if (!id)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(node, id.name);
              } else if (node.declaration.type === "VariableDeclaration") {
                for (const declaration of node.declaration.declarations) {
                  this.checkDeclaration(declaration.id);
                }
              }
            }
          }
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (currentContextDecorators.length) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
        }
        checkDeclaration(node) {
          if (node.type === "Identifier") {
            this.checkDuplicateExports(node, node.name);
          } else if (node.type === "ObjectPattern") {
            for (const prop of node.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node.type === "ArrayPattern") {
            for (const elem of node.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node.type === "ObjectProperty") {
            this.checkDeclaration(node.value);
          } else if (node.type === "RestElement") {
            this.checkDeclaration(node.argument);
          } else if (node.type === "AssignmentPattern") {
            this.checkDeclaration(node.left);
          }
        }
        checkDuplicateExports(node, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const isMaybeTypeOnly = this.isContextual(126);
            const isString = this.match(129);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
          } else if (isString) {
            node.exported = cloneStringLiteral(node.local);
          } else if (!node.exported) {
            node.exported = cloneIdentifier(node.local);
          }
          return this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(129)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node) {
          if (node.assertions != null) {
            return node.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkJSONModuleImport(node) {
          if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node;
            if (node.specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        parseImport(node) {
          node.specifiers = [];
          if (!this.match(129)) {
            const hasDefault = this.maybeParseDefaultImportSpecifier(node);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            if (parseNext && !hasStar)
              this.parseNamedImportSpecifiers(node);
            this.expectContextual(97);
          }
          node.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          } else {
            const attributes = this.maybeParseModuleAttributes();
            if (attributes) {
              node.attributes = attributes;
            }
          }
          this.checkJSONModuleImport(node);
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(129))
            this.unexpected();
          return this.parseExprAtom();
        }
        shouldParseDefaultImport(node) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type) {
          this.checkLVal(specifier.local, {
            in: specifier,
            binding: BIND_LEXICAL
          });
          return this.finishNode(specifier, type);
        }
        parseAssertEntries() {
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(129)) {
              node.key = this.parseStringLiteral(keyName);
            } else {
              node.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
          } else {
            if (this.hasPlugin("moduleAttributes"))
              return [];
            return null;
          }
          const attrs = [];
          const attributes = /* @__PURE__ */ new Set();
          do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
              });
            }
            if (attributes.has(node.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
              });
            }
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
          } else {
            if (this.hasPlugin("importAssertions"))
              return [];
            return null;
          }
          this.eat(5);
          const attrs = this.parseAssertEntries();
          this.eat(8);
          return attrs;
        }
        maybeParseDefaultImportSpecifier(node) {
          if (this.shouldParseDefaultImport(node)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(129);
            const isMaybeTypeOnly = this.isContextual(126);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      };
      var Parser2 = class extends StatementParser {
        constructor(options, input) {
          options = getOptions(options);
          super(options, input);
          this.options = options;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program);
          file.errors = this.state.errors;
          return file;
        }
      };
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin of plugins) {
          const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
          if (!pluginMap.has(name))
            pluginMap.set(name, options || {});
        }
        return pluginMap;
      }
      function parse2(input, options) {
        var _options;
        if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) {
              return ast;
            }
            if (parser.ambiguousScriptDifferentAst) {
              try {
                options.sourceType = "script";
                return getParser(options, input).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options, input).parse();
        }
      }
      function parseExpression(input, options) {
        const parser = getParser(options, input);
        if (parser.options.strictMode) {
          parser.state.strict = true;
        }
        return parser.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      var tokTypes = generateExportedTokenTypes(tt);
      function getParser(options, input) {
        let cls = Parser2;
        if (options != null && options.plugins) {
          validatePlugins(options.plugins);
          cls = getParserClass(options.plugins);
        }
        return new cls(options, input);
      }
      var parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser2;
          for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      exports.parse = parse2;
      exports.parseExpression = parseExpression;
      exports.tokTypes = tokTypes;
    }
  });

  // src/playground.tsx
  init_inject();

  // node_modules/solid-js/web/dist/web.js
  init_inject();

  // node_modules/solid-js/dist/solid.js
  init_inject();
  var sharedConfig = {};
  function setHydrateContext(context) {
    sharedConfig.context = context;
  }
  function nextHydrateContext() {
    return {
      ...sharedConfig.context,
      id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
      count: 0
    };
  }
  var equalFn = (a, b) => a === b;
  var $PROXY = Symbol("solid-proxy");
  var $TRACK = Symbol("solid-track");
  var $DEVCOMP = Symbol("solid-dev-component");
  var signalOptions = {
    equals: equalFn
  };
  var ERROR = null;
  var runEffects = runQueue;
  var NOTPENDING = {};
  var STALE = 1;
  var PENDING = 2;
  var UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  };
  var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
  var Owner = null;
  var Transition = null;
  var Scheduler = null;
  var ExternalSourceFactory = null;
  var Listener = null;
  var Pending = null;
  var Updates = null;
  var Effects = null;
  var ExecCount = 0;
  function createRoot(fn, detachedOwner) {
    const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned && true ? UNOWNED : {
      owned: null,
      cleanups: null,
      context: null,
      owner: detachedOwner || owner
    }, updateFn = unowned ? fn : () => fn(() => cleanNode(root));
    Owner = root;
    Listener = null;
    try {
      return runUpdates(updateFn, true);
    } finally {
      Listener = listener;
      Owner = owner;
    }
  }
  function createSignal(value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const s = {
      value,
      observers: null,
      observerSlots: null,
      pending: NOTPENDING,
      comparator: options.equals || void 0
    };
    const setter = (value2) => {
      if (typeof value2 === "function") {
        if (Transition && Transition.running && Transition.sources.has(s))
          value2 = value2(s.pending !== NOTPENDING ? s.pending : s.tValue);
        else
          value2 = value2(s.pending !== NOTPENDING ? s.pending : s.value);
      }
      return writeSignal(s, value2);
    };
    return [readSignal.bind(s), setter];
  }
  function createComputed(fn, value, options) {
    const c = createComputation(fn, value, true, STALE);
    if (Scheduler && Transition && Transition.running)
      Updates.push(c);
    else
      updateComputation(c);
  }
  function createRenderEffect(fn, value, options) {
    const c = createComputation(fn, value, false, STALE);
    if (Scheduler && Transition && Transition.running)
      Updates.push(c);
    else
      updateComputation(c);
  }
  function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const c = createComputation(fn, value, true, 0);
    c.pending = NOTPENDING;
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || void 0;
    if (Scheduler && Transition && Transition.running) {
      c.tState = STALE;
      Updates.push(c);
    } else
      updateComputation(c);
    return readSignal.bind(c);
  }
  function batch(fn) {
    if (Pending)
      return fn();
    let result;
    const q = Pending = [];
    try {
      result = fn();
    } finally {
      Pending = null;
    }
    runUpdates(() => {
      for (let i = 0; i < q.length; i += 1) {
        const data = q[i];
        if (data.pending !== NOTPENDING) {
          const pending = data.pending;
          data.pending = NOTPENDING;
          writeSignal(data, pending);
        }
      }
    }, false);
    return result;
  }
  function untrack(fn) {
    let result, listener = Listener;
    Listener = null;
    result = fn();
    Listener = listener;
    return result;
  }
  function onCleanup(fn) {
    if (Owner === null)
      ;
    else if (Owner.cleanups === null)
      Owner.cleanups = [fn];
    else
      Owner.cleanups.push(fn);
    return fn;
  }
  function startTransition(fn) {
    if (Transition && Transition.running) {
      fn();
      return Transition.done;
    }
    const l = Listener;
    const o = Owner;
    return Promise.resolve().then(() => {
      Listener = l;
      Owner = o;
      let t;
      if (Scheduler || SuspenseContext) {
        t = Transition || (Transition = {
          sources: /* @__PURE__ */ new Set(),
          effects: [],
          promises: /* @__PURE__ */ new Set(),
          disposed: /* @__PURE__ */ new Set(),
          queue: /* @__PURE__ */ new Set(),
          running: true
        });
        t.done || (t.done = new Promise((res) => t.resolve = res));
        t.running = true;
      }
      batch(fn);
      Listener = Owner = null;
      return t ? t.done : void 0;
    });
  }
  function createContext(defaultValue) {
    const id = Symbol("context");
    return {
      id,
      Provider: createProvider(id),
      defaultValue
    };
  }
  function children(fn) {
    const children2 = createMemo(fn);
    return createMemo(() => resolveChildren(children2()));
  }
  var SuspenseContext;
  function readSignal() {
    const runningTransition = Transition && Transition.running;
    if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {
      const updates = Updates;
      Updates = null;
      !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);
      Updates = updates;
    }
    if (Listener) {
      const sSlot = this.observers ? this.observers.length : 0;
      if (!Listener.sources) {
        Listener.sources = [this];
        Listener.sourceSlots = [sSlot];
      } else {
        Listener.sources.push(this);
        Listener.sourceSlots.push(sSlot);
      }
      if (!this.observers) {
        this.observers = [Listener];
        this.observerSlots = [Listener.sources.length - 1];
      } else {
        this.observers.push(Listener);
        this.observerSlots.push(Listener.sources.length - 1);
      }
    }
    if (runningTransition && Transition.sources.has(this))
      return this.tValue;
    return this.value;
  }
  function writeSignal(node, value, isComp) {
    if (Pending) {
      if (node.pending === NOTPENDING)
        Pending.push(node);
      node.pending = value;
      return value;
    }
    if (node.comparator) {
      if (Transition && Transition.running && Transition.sources.has(node)) {
        if (node.comparator(node.tValue, value))
          return value;
      } else if (node.comparator(node.value, value))
        return value;
    }
    let TransitionRunning = false;
    if (Transition) {
      TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value;
      }
      if (!TransitionRunning)
        node.value = value;
    } else
      node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          if (TransitionRunning && Transition.disposed.has(o))
            continue;
          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
            if (o.pure)
              Updates.push(o);
            else
              Effects.push(o);
            if (o.observers)
              markDownstream(o);
          }
          if (TransitionRunning)
            o.tState = STALE;
          else
            o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false)
            ;
          throw new Error();
        }
      }, false);
    }
    return value;
  }
  function updateComputation(node) {
    if (!node.fn)
      return;
    cleanNode(node);
    const owner = Owner, listener = Listener, time = ExecCount;
    Listener = Owner = node;
    runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
    if (Transition && !Transition.running && Transition.sources.has(node)) {
      queueMicrotask(() => {
        runUpdates(() => {
          Transition && (Transition.running = true);
          runComputation(node, node.tValue, time);
        }, false);
      });
    }
    Listener = listener;
    Owner = owner;
  }
  function runComputation(node, value, time) {
    let nextValue;
    try {
      nextValue = node.fn(value);
    } catch (err) {
      handleError(err);
    }
    if (!node.updatedAt || node.updatedAt <= time) {
      if (node.observers && node.observers.length) {
        writeSignal(node, nextValue, true);
      } else if (Transition && Transition.running && node.pure) {
        Transition.sources.add(node);
        node.tValue = nextValue;
      } else
        node.value = nextValue;
      node.updatedAt = time;
    }
  }
  function createComputation(fn, init, pure, state = STALE, options) {
    const c = {
      fn,
      state,
      updatedAt: null,
      owned: null,
      sources: null,
      sourceSlots: null,
      cleanups: null,
      value: init,
      owner: Owner,
      context: null,
      pure
    };
    if (Transition && Transition.running) {
      c.state = 0;
      c.tState = state;
    }
    if (Owner === null)
      ;
    else if (Owner !== UNOWNED) {
      if (Transition && Transition.running && Owner.pure) {
        if (!Owner.tOwned)
          Owner.tOwned = [c];
        else
          Owner.tOwned.push(c);
      } else {
        if (!Owner.owned)
          Owner.owned = [c];
        else
          Owner.owned.push(c);
      }
    }
    if (ExternalSourceFactory) {
      const [track, trigger] = createSignal(void 0, {
        equals: false
      });
      const ordinary = ExternalSourceFactory(c.fn, trigger);
      onCleanup(() => ordinary.dispose());
      const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
      const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);
      c.fn = (x) => {
        track();
        return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
      };
    }
    return c;
  }
  function runTop(node) {
    const runningTransition = Transition && Transition.running;
    if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0)
      return;
    if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING)
      return lookUpstream(node);
    if (node.suspense && untrack(node.suspense.inFallback))
      return node.suspense.effects.push(node);
    const ancestors = [node];
    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
      if (runningTransition && Transition.disposed.has(node))
        return;
      if (!runningTransition && node.state || runningTransition && node.tState)
        ancestors.push(node);
    }
    for (let i = ancestors.length - 1; i >= 0; i--) {
      node = ancestors[i];
      if (runningTransition) {
        let top = node, prev = ancestors[i + 1];
        while ((top = top.owner) && top !== prev) {
          if (Transition.disposed.has(top))
            return;
        }
      }
      if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {
        updateComputation(node);
      } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {
        const updates = Updates;
        Updates = null;
        lookUpstream(node, ancestors[0]);
        Updates = updates;
      }
    }
  }
  function runUpdates(fn, init) {
    if (Updates)
      return fn();
    let wait = false;
    if (!init)
      Updates = [];
    if (Effects)
      wait = true;
    else
      Effects = [];
    ExecCount++;
    try {
      const res = fn();
      completeUpdates(wait);
      return res;
    } catch (err) {
      if (!Updates)
        Effects = null;
      handleError(err);
    }
  }
  function completeUpdates(wait) {
    if (Updates) {
      if (Scheduler && Transition && Transition.running)
        scheduleQueue(Updates);
      else
        runQueue(Updates);
      Updates = null;
    }
    if (wait)
      return;
    let res;
    if (Transition && Transition.running) {
      if (Transition.promises.size || Transition.queue.size) {
        Transition.running = false;
        Transition.effects.push.apply(Transition.effects, Effects);
        Effects = null;
        setTransPending(true);
        return;
      }
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      res = Transition.resolve;
      for (const e of Effects) {
        "tState" in e && (e.state = e.tState);
        delete e.tState;
      }
      Transition = null;
      batch(() => {
        for (const d of disposed)
          cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i = 0, len = v.owned.length; i < len; i++)
              cleanNode(v.owned[i]);
          }
          if (v.tOwned)
            v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      });
    }
    if (Effects.length)
      batch(() => {
        runEffects(Effects);
        Effects = null;
      });
    else {
      Effects = null;
    }
    if (res)
      res();
  }
  function runQueue(queue) {
    for (let i = 0; i < queue.length; i++)
      runTop(queue[i]);
  }
  function scheduleQueue(queue) {
    for (let i = 0; i < queue.length; i++) {
      const item = queue[i];
      const tasks = Transition.queue;
      if (!tasks.has(item)) {
        tasks.add(item);
        Scheduler(() => {
          tasks.delete(item);
          runUpdates(() => {
            Transition.running = true;
            runTop(item);
            if (!tasks.size) {
              Effects.push.apply(Effects, Transition.effects);
              Transition.effects = [];
            }
          }, false);
          Transition && (Transition.running = false);
        });
      }
    }
  }
  function lookUpstream(node, ignore) {
    const runningTransition = Transition && Transition.running;
    if (runningTransition)
      node.tState = 0;
    else
      node.state = 0;
    for (let i = 0; i < node.sources.length; i += 1) {
      const source = node.sources[i];
      if (source.sources) {
        if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {
          if (source !== ignore)
            runTop(source);
        } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING)
          lookUpstream(source, ignore);
      }
    }
  }
  function markDownstream(node) {
    const runningTransition = Transition && Transition.running;
    for (let i = 0; i < node.observers.length; i += 1) {
      const o = node.observers[i];
      if (!runningTransition && !o.state || runningTransition && !o.tState) {
        if (runningTransition)
          o.tState = PENDING;
        else
          o.state = PENDING;
        if (o.pure)
          Updates.push(o);
        else
          Effects.push(o);
        o.observers && markDownstream(o);
      }
    }
  }
  function cleanNode(node) {
    let i;
    if (node.sources) {
      while (node.sources.length) {
        const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
        if (obs && obs.length) {
          const n = obs.pop(), s = source.observerSlots.pop();
          if (index < obs.length) {
            n.sourceSlots[s] = index;
            obs[index] = n;
            source.observerSlots[index] = s;
          }
        }
      }
    }
    if (Transition && Transition.running && node.pure) {
      if (node.tOwned) {
        for (i = 0; i < node.tOwned.length; i++)
          cleanNode(node.tOwned[i]);
        delete node.tOwned;
      }
      reset(node, true);
    } else if (node.owned) {
      for (i = 0; i < node.owned.length; i++)
        cleanNode(node.owned[i]);
      node.owned = null;
    }
    if (node.cleanups) {
      for (i = 0; i < node.cleanups.length; i++)
        node.cleanups[i]();
      node.cleanups = null;
    }
    if (Transition && Transition.running)
      node.tState = 0;
    else
      node.state = 0;
    node.context = null;
  }
  function reset(node, top) {
    if (!top) {
      node.tState = 0;
      Transition.disposed.add(node);
    }
    if (node.owned) {
      for (let i = 0; i < node.owned.length; i++)
        reset(node.owned[i]);
    }
  }
  function handleError(err) {
    const fns = ERROR && lookup(Owner, ERROR);
    if (!fns)
      throw err;
    for (const f of fns)
      f(err);
  }
  function lookup(owner, key) {
    return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
  }
  function resolveChildren(children2) {
    if (typeof children2 === "function" && !children2.length)
      return resolveChildren(children2());
    if (Array.isArray(children2)) {
      const results = [];
      for (let i = 0; i < children2.length; i++) {
        const result = resolveChildren(children2[i]);
        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
      }
      return results;
    }
    return children2;
  }
  function createProvider(id) {
    return function provider(props) {
      let res;
      createComputed(() => res = untrack(() => {
        Owner.context = {
          [id]: props.value
        };
        return children(() => props.children);
      }));
      return res;
    };
  }
  var FALLBACK = Symbol("fallback");
  var hydrationEnabled = false;
  function createComponent(Comp, props) {
    if (hydrationEnabled) {
      if (sharedConfig.context) {
        const c = sharedConfig.context;
        setHydrateContext(nextHydrateContext());
        const r = untrack(() => Comp(props || {}));
        setHydrateContext(c);
        return r;
      }
    }
    return untrack(() => Comp(props || {}));
  }
  var SuspenseListContext = createContext();

  // node_modules/solid-js/web/dist/web.js
  var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
  var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
  function reconcileArrays(parentNode, a, b) {
    let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
    while (aStart < aEnd || bStart < bEnd) {
      if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
        continue;
      }
      while (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      }
      if (aEnd === aStart) {
        const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
        while (bStart < bEnd)
          parentNode.insertBefore(b[bStart++], node);
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart]))
            a[aStart].remove();
          aStart++;
        }
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        const node = a[--aEnd].nextSibling;
        parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
        parentNode.insertBefore(b[--bEnd], node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = /* @__PURE__ */ new Map();
          let i = bStart;
          while (i < bEnd)
            map.set(b[i], i++);
        }
        const index = map.get(a[aStart]);
        if (index != null) {
          if (bStart < index && index < bEnd) {
            let i = aStart, sequence = 1, t;
            while (++i < aEnd && i < bEnd) {
              if ((t = map.get(a[i])) == null || t !== index + sequence)
                break;
              sequence++;
            }
            if (sequence > index - bStart) {
              const node = a[aStart];
              while (bStart < index)
                parentNode.insertBefore(b[bStart++], node);
            } else
              parentNode.replaceChild(b[bStart++], a[aStart++]);
          } else
            aStart++;
        } else
          a[aStart++].remove();
      }
    }
  }
  var $$EVENTS = "_$DX_DELEGATE";
  function render(code, element, init) {
    let disposer;
    createRoot((dispose) => {
      disposer = dispose;
      element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
    });
    return () => {
      disposer();
      element.textContent = "";
    };
  }
  function template(html, check, isSVG) {
    const t = document.createElement("template");
    t.innerHTML = html;
    let node = t.content.firstChild;
    if (isSVG)
      node = node.firstChild;
    return node;
  }
  function delegateEvents(eventNames, document2 = window.document) {
    const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
    for (let i = 0, l = eventNames.length; i < l; i++) {
      const name = eventNames[i];
      if (!e.has(name)) {
        e.add(name);
        document2.addEventListener(name, eventHandler);
      }
    }
  }
  function setAttribute(node, name, value) {
    if (value == null)
      node.removeAttribute(name);
    else
      node.setAttribute(name, value);
  }
  function insert(parent, accessor, marker, initial) {
    if (marker !== void 0 && !initial)
      initial = [];
    if (typeof accessor !== "function")
      return insertExpression(parent, accessor, initial, marker);
    createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
  }
  function eventHandler(e) {
    const key = `$$${e.type}`;
    let node = e.composedPath && e.composedPath()[0] || e.target;
    if (e.target !== node) {
      Object.defineProperty(e, "target", {
        configurable: true,
        value: node
      });
    }
    Object.defineProperty(e, "currentTarget", {
      configurable: true,
      get() {
        return node || document;
      }
    });
    if (sharedConfig.registry && !sharedConfig.done) {
      sharedConfig.done = true;
      document.querySelectorAll("[id^=pl-]").forEach((elem) => elem.remove());
    }
    while (node !== null) {
      const handler = node[key];
      if (handler && !node.disabled) {
        const data = node[`${key}Data`];
        data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
        if (e.cancelBubble)
          return;
      }
      node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;
    }
  }
  function insertExpression(parent, value, current, marker, unwrapArray) {
    if (sharedConfig.context && !current)
      current = [...parent.childNodes];
    while (typeof current === "function")
      current = current();
    if (value === current)
      return current;
    const t = typeof value, multi = marker !== void 0;
    parent = multi && current[0] && current[0].parentNode || parent;
    if (t === "string" || t === "number") {
      if (sharedConfig.context)
        return current;
      if (t === "number")
        value = value.toString();
      if (multi) {
        let node = current[0];
        if (node && node.nodeType === 3) {
          node.data = value;
        } else
          node = document.createTextNode(value);
        current = cleanChildren(parent, current, marker, node);
      } else {
        if (current !== "" && typeof current === "string") {
          current = parent.firstChild.data = value;
        } else
          current = parent.textContent = value;
      }
    } else if (value == null || t === "boolean") {
      if (sharedConfig.context)
        return current;
      current = cleanChildren(parent, current, marker);
    } else if (t === "function") {
      createRenderEffect(() => {
        let v = value();
        while (typeof v === "function")
          v = v();
        current = insertExpression(parent, v, current, marker);
      });
      return () => current;
    } else if (Array.isArray(value)) {
      const array = [];
      const currentArray = current && Array.isArray(current);
      if (normalizeIncomingArray(array, value, current, unwrapArray)) {
        createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
        return () => current;
      }
      if (sharedConfig.context) {
        for (let i = 0; i < array.length; i++) {
          if (array[i].parentNode)
            return current = array;
        }
      }
      if (array.length === 0) {
        current = cleanChildren(parent, current, marker);
        if (multi)
          return current;
      } else if (currentArray) {
        if (current.length === 0) {
          appendNodes(parent, array, marker);
        } else
          reconcileArrays(parent, current, array);
      } else {
        current && cleanChildren(parent);
        appendNodes(parent, array);
      }
      current = array;
    } else if (value instanceof Node) {
      if (sharedConfig.context && value.parentNode)
        return current = multi ? [value] : value;
      if (Array.isArray(current)) {
        if (multi)
          return current = cleanChildren(parent, current, marker, value);
        cleanChildren(parent, current, null, value);
      } else if (current == null || current === "" || !parent.firstChild) {
        parent.appendChild(value);
      } else
        parent.replaceChild(value, parent.firstChild);
      current = value;
    } else
      ;
    return current;
  }
  function normalizeIncomingArray(normalized, array, current, unwrap) {
    let dynamic = false;
    for (let i = 0, len = array.length; i < len; i++) {
      let item = array[i], prev = current && current[i];
      if (item instanceof Node) {
        normalized.push(item);
      } else if (item == null || item === true || item === false)
        ;
      else if (Array.isArray(item)) {
        dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
      } else if (typeof item === "function") {
        if (unwrap) {
          while (typeof item === "function")
            item = item();
          dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], prev) || dynamic;
        } else {
          normalized.push(item);
          dynamic = true;
        }
      } else {
        const value = String(item);
        if (prev && prev.nodeType === 3 && prev.data === value) {
          normalized.push(prev);
        } else
          normalized.push(document.createTextNode(value));
      }
    }
    return dynamic;
  }
  function appendNodes(parent, array, marker) {
    for (let i = 0, len = array.length; i < len; i++)
      parent.insertBefore(array[i], marker);
  }
  function cleanChildren(parent, current, marker, replacement) {
    if (marker === void 0)
      return parent.textContent = "";
    const node = replacement || document.createTextNode("");
    if (current.length) {
      let inserted = false;
      for (let i = current.length - 1; i >= 0; i--) {
        const el = current[i];
        if (node !== el) {
          const isParent = el.parentNode === parent;
          if (!inserted && !i)
            isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
          else
            isParent && el.remove();
        } else
          inserted = true;
      }
    } else
      parent.insertBefore(node, marker);
    return [node];
  }

  // src/App.tsx
  init_inject();

  // ../src/index.browser.ts
  init_inject();

  // ../src/core/index.ts
  init_inject();

  // ../src/core/cssify.ts
  init_inject();
  var groupToMap = (array, keySelector) => {
    const map = /* @__PURE__ */ new Map();
    for (const element of array) {
      const key = keySelector(element);
      const values = map.get(key);
      values ? values.push(element) : map.set(key, [element]);
    }
    return map;
  };
  var joinGroup = (separator, array, groupKeySelector, joinedValueSelector) => {
    const grouped = groupToMap(array, groupKeySelector);
    return [...grouped.keys()].sort().map((key) => joinedValueSelector(key, grouped.get(key))).join(separator);
  };
  var mediaSelector = (c) => c.media ?? "";
  var layerSelector = (c) => c.layer;
  var selectorSelector = (c) => `.${CSS.escape(c.className)}${":not(#\\0)".repeat(c.specificity ?? 0)}${c.selector ?? ""}`;
  var propertySelector = (c) => `${c.property}:${c.value}${c.important ? "!important" : ""}`;
  var cssify = (classes2, options) => {
    const [singleIndent, newline] = options?.pretty ? ["  ", "\n"] : ["", ""];
    return joinGroup(newline, classes2.values(), mediaSelector, (media, mediaRecords) => {
      const indent1 = media ? singleIndent : "";
      const content = joinGroup(newline, mediaRecords, layerSelector, (layer, layerRecords) => {
        const hasLayer = layer !== void 0;
        const indent2 = indent1 + (hasLayer ? singleIndent : "");
        const content2 = joinGroup(newline, layerRecords, propertySelector, (propertyList, selectorRecords) => {
          const selector = selectorRecords.sort().map(selectorSelector).join(`,${newline}${indent2}`);
          return `${indent2}${selector}{${newline}${indent2}${singleIndent}${propertyList}${newline}${indent2}}${newline}`;
        });
        return hasLayer ? `${indent1}@layer${layer ? " " : ""}${layer}{${newline}${content2}${indent1}}${newline}` : content2;
      });
      return media ? `@media${media.startsWith("(") ? "" : " "}${media}{${newline}${content}}${newline}` : content;
    });
  };

  // ../src/core/parseClass.ts
  init_inject();
  var import_known_css_properties = __toESM(require_known_css_properties(), 1);
  var knownCssPropertySet = new Set(import_known_css_properties.all);
  var unescape = (s) => s.replace(/\\(.)/g, "$1");
  var replace = (s, replacements) => {
    for (const [search, replacer] of replacements ?? []) {
      s = typeof replacer === "function" ? s.replace(search, (...args) => replacer(args)) : s.replace(search, replacer);
    }
    return s.replace(/(^|[^\\])(\\\\)*_/g, "$1$2 ");
  };
  var transformMedia = (media, replacements) => media && unescape(replace(media, replacements).replace(/(^| )([^ ()]+\b[^ ()]+)($| )/g, "$1($2)$3"));
  var transformSelector = (selector, replacements) => selector && unescape(replace(selector, replacements));
  var transformValue = (value, replacements) => unescape(replace(value, replacements).replace(/\$([a-zA-Z-]+[a-zA-Z])/g, "var(--$1)"));
  var transformProperty = (property, replacements) => {
    for (const [search, replacer] of replacements ?? []) {
      property = property.replace(search, replacer);
    }
    if (property.startsWith("--") || knownCssPropertySet.has(property)) {
      return property;
    }
  };
  var parseClass = (className, options, collectTo = /* @__PURE__ */ new Map()) => {
    const replacements = options?.replacements;
    for (const s of className.split(" ")) {
      const match = !collectTo.has(s) && s.match(/^(?:@((?:[^/\\]|\\.)+?)\/)?(?:((?:[^/\\]|\\.)+?)\/)?([^:]+?):(.+?)(\**)(!?)(\??)$/);
      const property = match && transformProperty(match[3], replacements?.property);
      property && collectTo.set(s, {
        className: s,
        media: transformMedia(match[1], replacements?.media),
        layer: match[7] === "?" ? "" : void 0,
        selector: transformSelector(match[2], replacements?.selector),
        property,
        value: transformValue(match[4], replacements?.value),
        specificity: (match[7] === "?" ? 0 : 1) + match[5].length,
        important: match[6] === "!" || void 0
      });
    }
    return collectTo;
  };

  // ../src/core/parseHtml.ts
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/index.js
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/Parser.js
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/Tokenizer.js
  init_inject();

  // ../node_modules/entities/lib/esm/decode.js
  init_inject();

  // ../node_modules/entities/lib/esm/generated/decode-data-html.js
  init_inject();
  var decode_data_html_default = new Uint16Array([7489, 60, 213, 305, 650, 1181, 1403, 1488, 1653, 1758, 1954, 2006, 2063, 2634, 2705, 3489, 3693, 3849, 3878, 4298, 4648, 4833, 5141, 5277, 5315, 5343, 5413, 0, 0, 0, 0, 0, 0, 5483, 5837, 6541, 7186, 7645, 8062, 8288, 8624, 8845, 9152, 9211, 9282, 10276, 10514, 11528, 11848, 12238, 12310, 12986, 13881, 14252, 14590, 14888, 14961, 15072, 15150, 2048, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 98, 102, 109, 115, 127, 132, 139, 144, 149, 152, 166, 179, 185, 200, 207, 108, 105, 103, 32827, 198, 16582, 80, 32827, 38, 16422, 99, 117, 116, 101, 32827, 193, 16577, 114, 101, 118, 101, 59, 16642, 256, 105, 121, 120, 125, 114, 99, 32827, 194, 16578, 59, 17424, 114, 59, 49152, 55349, 56580, 114, 97, 118, 101, 32827, 192, 16576, 112, 104, 97, 59, 17297, 97, 99, 114, 59, 16640, 100, 59, 27219, 256, 103, 112, 157, 161, 111, 110, 59, 16644, 102, 59, 49152, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 24673, 105, 110, 103, 32827, 197, 16581, 256, 99, 115, 190, 195, 114, 59, 49152, 55349, 56476, 105, 103, 110, 59, 25172, 105, 108, 100, 101, 32827, 195, 16579, 109, 108, 32827, 196, 16580, 1024, 97, 99, 101, 102, 111, 114, 115, 117, 229, 251, 254, 279, 284, 290, 295, 298, 256, 99, 114, 234, 242, 107, 115, 108, 97, 115, 104, 59, 25110, 374, 246, 248, 59, 27367, 101, 100, 59, 25350, 121, 59, 17425, 384, 99, 114, 116, 261, 267, 276, 97, 117, 115, 101, 59, 25141, 110, 111, 117, 108, 108, 105, 115, 59, 24876, 97, 59, 17298, 114, 59, 49152, 55349, 56581, 112, 102, 59, 49152, 55349, 56633, 101, 118, 101, 59, 17112, 99, 242, 275, 109, 112, 101, 113, 59, 25166, 1792, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 333, 337, 342, 384, 414, 418, 437, 439, 442, 476, 533, 627, 632, 638, 99, 121, 59, 17447, 80, 89, 32827, 169, 16553, 384, 99, 112, 121, 349, 354, 378, 117, 116, 101, 59, 16646, 256, 59, 105, 359, 360, 25298, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24901, 108, 101, 121, 115, 59, 24877, 512, 97, 101, 105, 111, 393, 398, 404, 408, 114, 111, 110, 59, 16652, 100, 105, 108, 32827, 199, 16583, 114, 99, 59, 16648, 110, 105, 110, 116, 59, 25136, 111, 116, 59, 16650, 256, 100, 110, 423, 429, 105, 108, 108, 97, 59, 16568, 116, 101, 114, 68, 111, 116, 59, 16567, 242, 383, 105, 59, 17319, 114, 99, 108, 101, 512, 68, 77, 80, 84, 455, 459, 465, 470, 111, 116, 59, 25241, 105, 110, 117, 115, 59, 25238, 108, 117, 115, 59, 25237, 105, 109, 101, 115, 59, 25239, 111, 256, 99, 115, 482, 504, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25138, 101, 67, 117, 114, 108, 121, 256, 68, 81, 515, 527, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24605, 117, 111, 116, 101, 59, 24601, 512, 108, 110, 112, 117, 542, 552, 583, 597, 111, 110, 256, 59, 101, 549, 550, 25143, 59, 27252, 384, 103, 105, 116, 559, 566, 570, 114, 117, 101, 110, 116, 59, 25185, 110, 116, 59, 25135, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25134, 256, 102, 114, 588, 590, 59, 24834, 111, 100, 117, 99, 116, 59, 25104, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25139, 111, 115, 115, 59, 27183, 99, 114, 59, 49152, 55349, 56478, 112, 256, 59, 67, 644, 645, 25299, 97, 112, 59, 25165, 1408, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 672, 684, 688, 692, 696, 715, 727, 737, 742, 819, 1165, 256, 59, 111, 377, 677, 116, 114, 97, 104, 100, 59, 26897, 99, 121, 59, 17410, 99, 121, 59, 17413, 99, 121, 59, 17423, 384, 103, 114, 115, 703, 708, 711, 103, 101, 114, 59, 24609, 114, 59, 24993, 104, 118, 59, 27364, 256, 97, 121, 720, 725, 114, 111, 110, 59, 16654, 59, 17428, 108, 256, 59, 116, 733, 734, 25095, 97, 59, 17300, 114, 59, 49152, 55349, 56583, 256, 97, 102, 747, 807, 256, 99, 109, 752, 802, 114, 105, 116, 105, 99, 97, 108, 512, 65, 68, 71, 84, 768, 774, 790, 796, 99, 117, 116, 101, 59, 16564, 111, 372, 779, 781, 59, 17113, 98, 108, 101, 65, 99, 117, 116, 101, 59, 17117, 114, 97, 118, 101, 59, 16480, 105, 108, 100, 101, 59, 17116, 111, 110, 100, 59, 25284, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24902, 1136, 829, 0, 0, 0, 834, 852, 0, 1029, 102, 59, 49152, 55349, 56635, 384, 59, 68, 69, 840, 841, 845, 16552, 111, 116, 59, 24796, 113, 117, 97, 108, 59, 25168, 98, 108, 101, 768, 67, 68, 76, 82, 85, 86, 867, 882, 898, 975, 994, 1016, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 236, 569, 111, 628, 889, 0, 0, 891, 187, 841, 110, 65, 114, 114, 111, 119, 59, 25043, 256, 101, 111, 903, 932, 102, 116, 384, 65, 82, 84, 912, 918, 929, 114, 114, 111, 119, 59, 25040, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25044, 101, 229, 714, 110, 103, 256, 76, 82, 939, 964, 101, 102, 116, 256, 65, 82, 947, 953, 114, 114, 111, 119, 59, 26616, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26618, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26617, 105, 103, 104, 116, 256, 65, 84, 984, 990, 114, 114, 111, 119, 59, 25042, 101, 101, 59, 25256, 112, 577, 1001, 0, 0, 1007, 114, 114, 111, 119, 59, 25041, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25045, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25125, 110, 768, 65, 66, 76, 82, 84, 97, 1042, 1066, 1072, 1118, 1151, 892, 114, 114, 111, 119, 384, 59, 66, 85, 1053, 1054, 1058, 24979, 97, 114, 59, 26899, 112, 65, 114, 114, 111, 119, 59, 25077, 114, 101, 118, 101, 59, 17169, 101, 102, 116, 722, 1082, 0, 1094, 0, 1104, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 26960, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26974, 101, 99, 116, 111, 114, 256, 59, 66, 1113, 1114, 25021, 97, 114, 59, 26966, 105, 103, 104, 116, 468, 1127, 0, 1137, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26975, 101, 99, 116, 111, 114, 256, 59, 66, 1146, 1147, 25025, 97, 114, 59, 26967, 101, 101, 256, 59, 65, 1158, 1159, 25252, 114, 114, 111, 119, 59, 24999, 256, 99, 116, 1170, 1175, 114, 59, 49152, 55349, 56479, 114, 111, 107, 59, 16656, 2048, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1213, 1216, 1220, 1227, 1246, 1250, 1255, 1262, 1269, 1313, 1327, 1334, 1362, 1373, 1376, 1381, 71, 59, 16714, 72, 32827, 208, 16592, 99, 117, 116, 101, 32827, 201, 16585, 384, 97, 105, 121, 1234, 1239, 1244, 114, 111, 110, 59, 16666, 114, 99, 32827, 202, 16586, 59, 17453, 111, 116, 59, 16662, 114, 59, 49152, 55349, 56584, 114, 97, 118, 101, 32827, 200, 16584, 101, 109, 101, 110, 116, 59, 25096, 256, 97, 112, 1274, 1278, 99, 114, 59, 16658, 116, 121, 595, 1286, 0, 0, 1298, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26107, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26027, 256, 103, 112, 1318, 1322, 111, 110, 59, 16664, 102, 59, 49152, 55349, 56636, 115, 105, 108, 111, 110, 59, 17301, 117, 256, 97, 105, 1340, 1353, 108, 256, 59, 84, 1346, 1347, 27253, 105, 108, 100, 101, 59, 25154, 108, 105, 98, 114, 105, 117, 109, 59, 25036, 256, 99, 105, 1367, 1370, 114, 59, 24880, 109, 59, 27251, 97, 59, 17303, 109, 108, 32827, 203, 16587, 256, 105, 112, 1386, 1391, 115, 116, 115, 59, 25091, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 24903, 640, 99, 102, 105, 111, 115, 1413, 1416, 1421, 1458, 1484, 121, 59, 17444, 114, 59, 49152, 55349, 56585, 108, 108, 101, 100, 595, 1431, 0, 0, 1443, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26108, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26026, 880, 1466, 0, 1471, 0, 0, 1476, 102, 59, 49152, 55349, 56637, 65, 108, 108, 59, 25088, 114, 105, 101, 114, 116, 114, 102, 59, 24881, 99, 242, 1483, 1536, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1512, 1516, 1519, 1530, 1536, 1554, 1558, 1563, 1565, 1571, 1644, 1650, 99, 121, 59, 17411, 32827, 62, 16446, 109, 109, 97, 256, 59, 100, 1527, 1528, 17299, 59, 17372, 114, 101, 118, 101, 59, 16670, 384, 101, 105, 121, 1543, 1548, 1552, 100, 105, 108, 59, 16674, 114, 99, 59, 16668, 59, 17427, 111, 116, 59, 16672, 114, 59, 49152, 55349, 56586, 59, 25305, 112, 102, 59, 49152, 55349, 56638, 101, 97, 116, 101, 114, 768, 69, 70, 71, 76, 83, 84, 1589, 1604, 1614, 1622, 1627, 1638, 113, 117, 97, 108, 256, 59, 76, 1598, 1599, 25189, 101, 115, 115, 59, 25307, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25191, 114, 101, 97, 116, 101, 114, 59, 27298, 101, 115, 115, 59, 25207, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27262, 105, 108, 100, 101, 59, 25203, 99, 114, 59, 49152, 55349, 56482, 59, 25195, 1024, 65, 97, 99, 102, 105, 111, 115, 117, 1669, 1675, 1686, 1691, 1694, 1706, 1726, 1738, 82, 68, 99, 121, 59, 17450, 256, 99, 116, 1680, 1684, 101, 107, 59, 17095, 59, 16478, 105, 114, 99, 59, 16676, 114, 59, 24844, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 24843, 496, 1711, 0, 1714, 102, 59, 24845, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 25856, 256, 99, 116, 1731, 1733, 242, 1705, 114, 111, 107, 59, 16678, 109, 112, 324, 1744, 1752, 111, 119, 110, 72, 117, 109, 240, 303, 113, 117, 97, 108, 59, 25167, 1792, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1786, 1790, 1795, 1799, 1806, 1818, 1822, 1825, 1832, 1860, 1912, 1931, 1935, 1941, 99, 121, 59, 17429, 108, 105, 103, 59, 16690, 99, 121, 59, 17409, 99, 117, 116, 101, 32827, 205, 16589, 256, 105, 121, 1811, 1816, 114, 99, 32827, 206, 16590, 59, 17432, 111, 116, 59, 16688, 114, 59, 24849, 114, 97, 118, 101, 32827, 204, 16588, 384, 59, 97, 112, 1824, 1839, 1855, 256, 99, 103, 1844, 1847, 114, 59, 16682, 105, 110, 97, 114, 121, 73, 59, 24904, 108, 105, 101, 243, 989, 500, 1865, 0, 1890, 256, 59, 101, 1869, 1870, 25132, 256, 103, 114, 1875, 1880, 114, 97, 108, 59, 25131, 115, 101, 99, 116, 105, 111, 110, 59, 25282, 105, 115, 105, 98, 108, 101, 256, 67, 84, 1900, 1906, 111, 109, 109, 97, 59, 24675, 105, 109, 101, 115, 59, 24674, 384, 103, 112, 116, 1919, 1923, 1928, 111, 110, 59, 16686, 102, 59, 49152, 55349, 56640, 97, 59, 17305, 99, 114, 59, 24848, 105, 108, 100, 101, 59, 16680, 491, 1946, 0, 1950, 99, 121, 59, 17414, 108, 32827, 207, 16591, 640, 99, 102, 111, 115, 117, 1964, 1975, 1980, 1986, 2e3, 256, 105, 121, 1969, 1973, 114, 99, 59, 16692, 59, 17433, 114, 59, 49152, 55349, 56589, 112, 102, 59, 49152, 55349, 56641, 483, 1991, 0, 1996, 114, 59, 49152, 55349, 56485, 114, 99, 121, 59, 17416, 107, 99, 121, 59, 17412, 896, 72, 74, 97, 99, 102, 111, 115, 2020, 2024, 2028, 2033, 2045, 2050, 2056, 99, 121, 59, 17445, 99, 121, 59, 17420, 112, 112, 97, 59, 17306, 256, 101, 121, 2038, 2043, 100, 105, 108, 59, 16694, 59, 17434, 114, 59, 49152, 55349, 56590, 112, 102, 59, 49152, 55349, 56642, 99, 114, 59, 49152, 55349, 56486, 1408, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2085, 2089, 2092, 2128, 2147, 2483, 2488, 2503, 2509, 2615, 2631, 99, 121, 59, 17417, 32827, 60, 16444, 640, 99, 109, 110, 112, 114, 2103, 2108, 2113, 2116, 2125, 117, 116, 101, 59, 16697, 98, 100, 97, 59, 17307, 103, 59, 26602, 108, 97, 99, 101, 116, 114, 102, 59, 24850, 114, 59, 24990, 384, 97, 101, 121, 2135, 2140, 2145, 114, 111, 110, 59, 16701, 100, 105, 108, 59, 16699, 59, 17435, 256, 102, 115, 2152, 2416, 116, 1280, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2174, 2217, 2225, 2272, 2278, 2300, 2351, 2395, 912, 2410, 256, 110, 114, 2179, 2191, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26600, 114, 111, 119, 384, 59, 66, 82, 2201, 2202, 2206, 24976, 97, 114, 59, 25060, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25030, 101, 105, 108, 105, 110, 103, 59, 25352, 111, 501, 2231, 0, 2243, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26598, 110, 468, 2248, 0, 2258, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26977, 101, 99, 116, 111, 114, 256, 59, 66, 2267, 2268, 25027, 97, 114, 59, 26969, 108, 111, 111, 114, 59, 25354, 105, 103, 104, 116, 256, 65, 86, 2287, 2293, 114, 114, 111, 119, 59, 24980, 101, 99, 116, 111, 114, 59, 26958, 256, 101, 114, 2305, 2327, 101, 384, 59, 65, 86, 2313, 2314, 2320, 25251, 114, 114, 111, 119, 59, 24996, 101, 99, 116, 111, 114, 59, 26970, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 2340, 2341, 2345, 25266, 97, 114, 59, 27087, 113, 117, 97, 108, 59, 25268, 112, 384, 68, 84, 86, 2359, 2370, 2380, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26961, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26976, 101, 99, 116, 111, 114, 256, 59, 66, 2390, 2391, 25023, 97, 114, 59, 26968, 101, 99, 116, 111, 114, 256, 59, 66, 2405, 2406, 25020, 97, 114, 59, 26962, 105, 103, 104, 116, 225, 924, 115, 768, 69, 70, 71, 76, 83, 84, 2430, 2443, 2453, 2461, 2466, 2477, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 25306, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25190, 114, 101, 97, 116, 101, 114, 59, 25206, 101, 115, 115, 59, 27297, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27261, 105, 108, 100, 101, 59, 25202, 114, 59, 49152, 55349, 56591, 256, 59, 101, 2493, 2494, 25304, 102, 116, 97, 114, 114, 111, 119, 59, 25050, 105, 100, 111, 116, 59, 16703, 384, 110, 112, 119, 2516, 2582, 2587, 103, 512, 76, 82, 108, 114, 2526, 2551, 2562, 2576, 101, 102, 116, 256, 65, 82, 2534, 2540, 114, 114, 111, 119, 59, 26613, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26615, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26614, 101, 102, 116, 256, 97, 114, 947, 2570, 105, 103, 104, 116, 225, 959, 105, 103, 104, 116, 225, 970, 102, 59, 49152, 55349, 56643, 101, 114, 256, 76, 82, 2594, 2604, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24985, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24984, 384, 99, 104, 116, 2622, 2624, 2626, 242, 2124, 59, 25008, 114, 111, 107, 59, 16705, 59, 25194, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 2650, 2653, 2656, 2679, 2684, 2693, 2699, 2702, 112, 59, 26885, 121, 59, 17436, 256, 100, 108, 2661, 2671, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24671, 108, 105, 110, 116, 114, 102, 59, 24883, 114, 59, 49152, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 25107, 112, 102, 59, 49152, 55349, 56644, 99, 242, 2678, 59, 17308, 1152, 74, 97, 99, 101, 102, 111, 115, 116, 117, 2723, 2727, 2733, 2752, 2836, 2841, 3473, 3479, 3486, 99, 121, 59, 17418, 99, 117, 116, 101, 59, 16707, 384, 97, 101, 121, 2740, 2745, 2750, 114, 111, 110, 59, 16711, 100, 105, 108, 59, 16709, 59, 17437, 384, 103, 115, 119, 2759, 2800, 2830, 97, 116, 105, 118, 101, 384, 77, 84, 86, 2771, 2783, 2792, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24587, 104, 105, 256, 99, 110, 2790, 2776, 235, 2777, 101, 114, 121, 84, 104, 105, 238, 2777, 116, 101, 100, 256, 71, 76, 2808, 2822, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 242, 1651, 101, 115, 115, 76, 101, 115, 243, 2632, 76, 105, 110, 101, 59, 16394, 114, 59, 49152, 55349, 56593, 512, 66, 110, 112, 116, 2850, 2856, 2871, 2874, 114, 101, 97, 107, 59, 24672, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 16544, 102, 59, 24853, 1664, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 2901, 2902, 2922, 2940, 2977, 3051, 3076, 3166, 3204, 3238, 3288, 3425, 3461, 27372, 256, 111, 117, 2907, 2916, 110, 103, 114, 117, 101, 110, 116, 59, 25186, 112, 67, 97, 112, 59, 25197, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25126, 384, 108, 113, 120, 2947, 2954, 2971, 101, 109, 101, 110, 116, 59, 25097, 117, 97, 108, 256, 59, 84, 2962, 2963, 25184, 105, 108, 100, 101, 59, 49152, 8770, 824, 105, 115, 116, 115, 59, 25092, 114, 101, 97, 116, 101, 114, 896, 59, 69, 70, 71, 76, 83, 84, 2998, 2999, 3005, 3017, 3027, 3032, 3045, 25199, 113, 117, 97, 108, 59, 25201, 117, 108, 108, 69, 113, 117, 97, 108, 59, 49152, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 49152, 8811, 824, 101, 115, 115, 59, 25209, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10878, 824, 105, 108, 100, 101, 59, 25205, 117, 109, 112, 324, 3058, 3069, 111, 119, 110, 72, 117, 109, 112, 59, 49152, 8782, 824, 113, 117, 97, 108, 59, 49152, 8783, 824, 101, 256, 102, 115, 3082, 3111, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3098, 3099, 3105, 25322, 97, 114, 59, 49152, 10703, 824, 113, 117, 97, 108, 59, 25324, 115, 768, 59, 69, 71, 76, 83, 84, 3125, 3126, 3132, 3140, 3147, 3160, 25198, 113, 117, 97, 108, 59, 25200, 114, 101, 97, 116, 101, 114, 59, 25208, 101, 115, 115, 59, 49152, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10877, 824, 105, 108, 100, 101, 59, 25204, 101, 115, 116, 101, 100, 256, 71, 76, 3176, 3193, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 49152, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 49152, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 384, 59, 69, 83, 3218, 3219, 3227, 25216, 113, 117, 97, 108, 59, 49152, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25312, 256, 101, 105, 3243, 3257, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 25100, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3275, 3276, 3282, 25323, 97, 114, 59, 49152, 10704, 824, 113, 117, 97, 108, 59, 25325, 256, 113, 117, 3293, 3340, 117, 97, 114, 101, 83, 117, 256, 98, 112, 3304, 3321, 115, 101, 116, 256, 59, 69, 3312, 3315, 49152, 8847, 824, 113, 117, 97, 108, 59, 25314, 101, 114, 115, 101, 116, 256, 59, 69, 3331, 3334, 49152, 8848, 824, 113, 117, 97, 108, 59, 25315, 384, 98, 99, 112, 3347, 3364, 3406, 115, 101, 116, 256, 59, 69, 3355, 3358, 49152, 8834, 8402, 113, 117, 97, 108, 59, 25224, 99, 101, 101, 100, 115, 512, 59, 69, 83, 84, 3378, 3379, 3387, 3398, 25217, 113, 117, 97, 108, 59, 49152, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25313, 105, 108, 100, 101, 59, 49152, 8831, 824, 101, 114, 115, 101, 116, 256, 59, 69, 3416, 3419, 49152, 8835, 8402, 113, 117, 97, 108, 59, 25225, 105, 108, 100, 101, 512, 59, 69, 70, 84, 3438, 3439, 3445, 3455, 25153, 113, 117, 97, 108, 59, 25156, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25159, 105, 108, 100, 101, 59, 25161, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25124, 99, 114, 59, 49152, 55349, 56489, 105, 108, 100, 101, 32827, 209, 16593, 59, 17309, 1792, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3517, 3522, 3529, 3541, 3547, 3552, 3559, 3580, 3586, 3616, 3618, 3634, 3647, 3652, 108, 105, 103, 59, 16722, 99, 117, 116, 101, 32827, 211, 16595, 256, 105, 121, 3534, 3539, 114, 99, 32827, 212, 16596, 59, 17438, 98, 108, 97, 99, 59, 16720, 114, 59, 49152, 55349, 56594, 114, 97, 118, 101, 32827, 210, 16594, 384, 97, 101, 105, 3566, 3570, 3574, 99, 114, 59, 16716, 103, 97, 59, 17321, 99, 114, 111, 110, 59, 17311, 112, 102, 59, 49152, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 256, 68, 81, 3598, 3610, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24604, 117, 111, 116, 101, 59, 24600, 59, 27220, 256, 99, 108, 3623, 3628, 114, 59, 49152, 55349, 56490, 97, 115, 104, 32827, 216, 16600, 105, 364, 3639, 3644, 100, 101, 32827, 213, 16597, 101, 115, 59, 27191, 109, 108, 32827, 214, 16598, 101, 114, 256, 66, 80, 3659, 3680, 256, 97, 114, 3664, 3667, 114, 59, 24638, 97, 99, 256, 101, 107, 3674, 3676, 59, 25566, 101, 116, 59, 25524, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25564, 1152, 97, 99, 102, 104, 105, 108, 111, 114, 115, 3711, 3719, 3722, 3727, 3730, 3732, 3741, 3760, 3836, 114, 116, 105, 97, 108, 68, 59, 25090, 121, 59, 17439, 114, 59, 49152, 55349, 56595, 105, 59, 17318, 59, 17312, 117, 115, 77, 105, 110, 117, 115, 59, 16561, 256, 105, 112, 3746, 3757, 110, 99, 97, 114, 101, 112, 108, 97, 110, 229, 1693, 102, 59, 24857, 512, 59, 101, 105, 111, 3769, 3770, 3808, 3812, 27323, 99, 101, 100, 101, 115, 512, 59, 69, 83, 84, 3784, 3785, 3791, 3802, 25210, 113, 117, 97, 108, 59, 27311, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25212, 105, 108, 100, 101, 59, 25214, 109, 101, 59, 24627, 256, 100, 112, 3817, 3822, 117, 99, 116, 59, 25103, 111, 114, 116, 105, 111, 110, 256, 59, 97, 549, 3833, 108, 59, 25117, 256, 99, 105, 3841, 3846, 114, 59, 49152, 55349, 56491, 59, 17320, 512, 85, 102, 111, 115, 3857, 3862, 3867, 3871, 79, 84, 32827, 34, 16418, 114, 59, 49152, 55349, 56596, 112, 102, 59, 24858, 99, 114, 59, 49152, 55349, 56492, 1536, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 3902, 3907, 3911, 3936, 3955, 4007, 4010, 4013, 4246, 4265, 4276, 4286, 97, 114, 114, 59, 26896, 71, 32827, 174, 16558, 384, 99, 110, 114, 3918, 3923, 3926, 117, 116, 101, 59, 16724, 103, 59, 26603, 114, 256, 59, 116, 3932, 3933, 24992, 108, 59, 26902, 384, 97, 101, 121, 3943, 3948, 3953, 114, 111, 110, 59, 16728, 100, 105, 108, 59, 16726, 59, 17440, 256, 59, 118, 3960, 3961, 24860, 101, 114, 115, 101, 256, 69, 85, 3970, 3993, 256, 108, 113, 3975, 3982, 101, 109, 101, 110, 116, 59, 25099, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 25035, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26991, 114, 187, 3961, 111, 59, 17313, 103, 104, 116, 1024, 65, 67, 68, 70, 84, 85, 86, 97, 4033, 4075, 4083, 4130, 4136, 4187, 4231, 984, 256, 110, 114, 4038, 4050, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26601, 114, 111, 119, 384, 59, 66, 76, 4060, 4061, 4065, 24978, 97, 114, 59, 25061, 101, 102, 116, 65, 114, 114, 111, 119, 59, 25028, 101, 105, 108, 105, 110, 103, 59, 25353, 111, 501, 4089, 0, 4101, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26599, 110, 468, 4106, 0, 4116, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26973, 101, 99, 116, 111, 114, 256, 59, 66, 4125, 4126, 25026, 97, 114, 59, 26965, 108, 111, 111, 114, 59, 25355, 256, 101, 114, 4141, 4163, 101, 384, 59, 65, 86, 4149, 4150, 4156, 25250, 114, 114, 111, 119, 59, 24998, 101, 99, 116, 111, 114, 59, 26971, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 4176, 4177, 4181, 25267, 97, 114, 59, 27088, 113, 117, 97, 108, 59, 25269, 112, 384, 68, 84, 86, 4195, 4206, 4216, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26959, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26972, 101, 99, 116, 111, 114, 256, 59, 66, 4226, 4227, 25022, 97, 114, 59, 26964, 101, 99, 116, 111, 114, 256, 59, 66, 4241, 4242, 25024, 97, 114, 59, 26963, 256, 112, 117, 4251, 4254, 102, 59, 24861, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 26992, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25051, 256, 99, 104, 4281, 4284, 114, 59, 24859, 59, 25009, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 27124, 1664, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4324, 4337, 4343, 4349, 4377, 4382, 4433, 4438, 4449, 4455, 4533, 4539, 4543, 256, 67, 99, 4329, 4334, 72, 99, 121, 59, 17449, 121, 59, 17448, 70, 84, 99, 121, 59, 17452, 99, 117, 116, 101, 59, 16730, 640, 59, 97, 101, 105, 121, 4360, 4361, 4366, 4371, 4375, 27324, 114, 111, 110, 59, 16736, 100, 105, 108, 59, 16734, 114, 99, 59, 16732, 59, 17441, 114, 59, 49152, 55349, 56598, 111, 114, 116, 512, 68, 76, 82, 85, 4394, 4404, 4414, 4425, 111, 119, 110, 65, 114, 114, 111, 119, 187, 1054, 101, 102, 116, 65, 114, 114, 111, 119, 187, 2202, 105, 103, 104, 116, 65, 114, 114, 111, 119, 187, 4061, 112, 65, 114, 114, 111, 119, 59, 24977, 103, 109, 97, 59, 17315, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 25112, 112, 102, 59, 49152, 55349, 56650, 626, 4461, 0, 0, 4464, 116, 59, 25114, 97, 114, 101, 512, 59, 73, 83, 85, 4475, 4476, 4489, 4527, 26017, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 25235, 117, 256, 98, 112, 4495, 4510, 115, 101, 116, 256, 59, 69, 4503, 4504, 25231, 113, 117, 97, 108, 59, 25233, 101, 114, 115, 101, 116, 256, 59, 69, 4520, 4521, 25232, 113, 117, 97, 108, 59, 25234, 110, 105, 111, 110, 59, 25236, 99, 114, 59, 49152, 55349, 56494, 97, 114, 59, 25286, 512, 98, 99, 109, 112, 4552, 4571, 4617, 4619, 256, 59, 115, 4557, 4558, 25296, 101, 116, 256, 59, 69, 4557, 4565, 113, 117, 97, 108, 59, 25222, 256, 99, 104, 4576, 4613, 101, 101, 100, 115, 512, 59, 69, 83, 84, 4589, 4590, 4596, 4607, 25211, 113, 117, 97, 108, 59, 27312, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25213, 105, 108, 100, 101, 59, 25215, 84, 104, 225, 3980, 59, 25105, 384, 59, 101, 115, 4626, 4627, 4643, 25297, 114, 115, 101, 116, 256, 59, 69, 4636, 4637, 25219, 113, 117, 97, 108, 59, 25223, 101, 116, 187, 4627, 1408, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 4670, 4676, 4681, 4693, 4702, 4721, 4726, 4767, 4802, 4808, 4817, 79, 82, 78, 32827, 222, 16606, 65, 68, 69, 59, 24866, 256, 72, 99, 4686, 4690, 99, 121, 59, 17419, 121, 59, 17446, 256, 98, 117, 4698, 4700, 59, 16393, 59, 17316, 384, 97, 101, 121, 4709, 4714, 4719, 114, 111, 110, 59, 16740, 100, 105, 108, 59, 16738, 59, 17442, 114, 59, 49152, 55349, 56599, 256, 101, 105, 4731, 4745, 498, 4736, 0, 4743, 101, 102, 111, 114, 101, 59, 25140, 97, 59, 17304, 256, 99, 110, 4750, 4760, 107, 83, 112, 97, 99, 101, 59, 49152, 8287, 8202, 83, 112, 97, 99, 101, 59, 24585, 108, 100, 101, 512, 59, 69, 70, 84, 4779, 4780, 4786, 4796, 25148, 113, 117, 97, 108, 59, 25155, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25157, 105, 108, 100, 101, 59, 25160, 112, 102, 59, 49152, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 24795, 256, 99, 116, 4822, 4827, 114, 59, 49152, 55349, 56495, 114, 111, 107, 59, 16742, 2785, 4855, 4878, 4890, 4902, 0, 4908, 4913, 0, 0, 0, 0, 0, 4920, 4925, 4983, 4997, 0, 5119, 5124, 5130, 5136, 256, 99, 114, 4859, 4865, 117, 116, 101, 32827, 218, 16602, 114, 256, 59, 111, 4871, 4872, 24991, 99, 105, 114, 59, 26953, 114, 483, 4883, 0, 4886, 121, 59, 17422, 118, 101, 59, 16748, 256, 105, 121, 4894, 4899, 114, 99, 32827, 219, 16603, 59, 17443, 98, 108, 97, 99, 59, 16752, 114, 59, 49152, 55349, 56600, 114, 97, 118, 101, 32827, 217, 16601, 97, 99, 114, 59, 16746, 256, 100, 105, 4929, 4969, 101, 114, 256, 66, 80, 4936, 4957, 256, 97, 114, 4941, 4944, 114, 59, 16479, 97, 99, 256, 101, 107, 4951, 4953, 59, 25567, 101, 116, 59, 25525, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25565, 111, 110, 256, 59, 80, 4976, 4977, 25283, 108, 117, 115, 59, 25230, 256, 103, 112, 4987, 4991, 111, 110, 59, 16754, 102, 59, 49152, 55349, 56652, 1024, 65, 68, 69, 84, 97, 100, 112, 115, 5013, 5038, 5048, 5060, 1e3, 5074, 5079, 5107, 114, 114, 111, 119, 384, 59, 66, 68, 4432, 5024, 5028, 97, 114, 59, 26898, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25029, 111, 119, 110, 65, 114, 114, 111, 119, 59, 24981, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26990, 101, 101, 256, 59, 65, 5067, 5068, 25253, 114, 114, 111, 119, 59, 24997, 111, 119, 110, 225, 1011, 101, 114, 256, 76, 82, 5086, 5096, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24982, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24983, 105, 256, 59, 108, 5113, 5114, 17362, 111, 110, 59, 17317, 105, 110, 103, 59, 16750, 99, 114, 59, 49152, 55349, 56496, 105, 108, 100, 101, 59, 16744, 109, 108, 32827, 220, 16604, 1152, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5159, 5164, 5168, 5171, 5182, 5253, 5258, 5264, 5270, 97, 115, 104, 59, 25259, 97, 114, 59, 27371, 121, 59, 17426, 97, 115, 104, 256, 59, 108, 5179, 5180, 25257, 59, 27366, 256, 101, 114, 5187, 5189, 59, 25281, 384, 98, 116, 121, 5196, 5200, 5242, 97, 114, 59, 24598, 256, 59, 105, 5199, 5205, 99, 97, 108, 512, 66, 76, 83, 84, 5217, 5221, 5226, 5236, 97, 114, 59, 25123, 105, 110, 101, 59, 16508, 101, 112, 97, 114, 97, 116, 111, 114, 59, 26456, 105, 108, 100, 101, 59, 25152, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 24586, 114, 59, 49152, 55349, 56601, 112, 102, 59, 49152, 55349, 56653, 99, 114, 59, 49152, 55349, 56497, 100, 97, 115, 104, 59, 25258, 640, 99, 101, 102, 111, 115, 5287, 5292, 5297, 5302, 5308, 105, 114, 99, 59, 16756, 100, 103, 101, 59, 25280, 114, 59, 49152, 55349, 56602, 112, 102, 59, 49152, 55349, 56654, 99, 114, 59, 49152, 55349, 56498, 512, 102, 105, 111, 115, 5323, 5328, 5330, 5336, 114, 59, 49152, 55349, 56603, 59, 17310, 112, 102, 59, 49152, 55349, 56655, 99, 114, 59, 49152, 55349, 56499, 1152, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5361, 5365, 5369, 5373, 5380, 5391, 5396, 5402, 5408, 99, 121, 59, 17455, 99, 121, 59, 17415, 99, 121, 59, 17454, 99, 117, 116, 101, 32827, 221, 16605, 256, 105, 121, 5385, 5389, 114, 99, 59, 16758, 59, 17451, 114, 59, 49152, 55349, 56604, 112, 102, 59, 49152, 55349, 56656, 99, 114, 59, 49152, 55349, 56500, 109, 108, 59, 16760, 1024, 72, 97, 99, 100, 101, 102, 111, 115, 5429, 5433, 5439, 5451, 5455, 5469, 5472, 5476, 99, 121, 59, 17430, 99, 117, 116, 101, 59, 16761, 256, 97, 121, 5444, 5449, 114, 111, 110, 59, 16765, 59, 17431, 111, 116, 59, 16763, 498, 5460, 0, 5467, 111, 87, 105, 100, 116, 232, 2777, 97, 59, 17302, 114, 59, 24872, 112, 102, 59, 24868, 99, 114, 59, 49152, 55349, 56501, 3041, 5507, 5514, 5520, 0, 5552, 5558, 5567, 0, 0, 0, 0, 5574, 5595, 5611, 5727, 5741, 0, 5781, 5787, 5810, 5817, 0, 5822, 99, 117, 116, 101, 32827, 225, 16609, 114, 101, 118, 101, 59, 16643, 768, 59, 69, 100, 105, 117, 121, 5532, 5533, 5537, 5539, 5544, 5549, 25150, 59, 49152, 8766, 819, 59, 25151, 114, 99, 32827, 226, 16610, 116, 101, 32955, 180, 774, 59, 17456, 108, 105, 103, 32827, 230, 16614, 256, 59, 114, 178, 5562, 59, 49152, 55349, 56606, 114, 97, 118, 101, 32827, 224, 16608, 256, 101, 112, 5578, 5590, 256, 102, 112, 5583, 5588, 115, 121, 109, 59, 24885, 232, 5587, 104, 97, 59, 17329, 256, 97, 112, 5599, 99, 256, 99, 108, 5604, 5607, 114, 59, 16641, 103, 59, 27199, 612, 5616, 0, 0, 5642, 640, 59, 97, 100, 115, 118, 5626, 5627, 5631, 5633, 5639, 25127, 110, 100, 59, 27221, 59, 27228, 108, 111, 112, 101, 59, 27224, 59, 27226, 896, 59, 101, 108, 109, 114, 115, 122, 5656, 5657, 5659, 5662, 5695, 5711, 5721, 25120, 59, 27044, 101, 187, 5657, 115, 100, 256, 59, 97, 5669, 5670, 25121, 1121, 5680, 5682, 5684, 5686, 5688, 5690, 5692, 5694, 59, 27048, 59, 27049, 59, 27050, 59, 27051, 59, 27052, 59, 27053, 59, 27054, 59, 27055, 116, 256, 59, 118, 5701, 5702, 25119, 98, 256, 59, 100, 5708, 5709, 25278, 59, 27037, 256, 112, 116, 5716, 5719, 104, 59, 25122, 187, 185, 97, 114, 114, 59, 25468, 256, 103, 112, 5731, 5735, 111, 110, 59, 16645, 102, 59, 49152, 55349, 56658, 896, 59, 69, 97, 101, 105, 111, 112, 4801, 5755, 5757, 5762, 5764, 5767, 5770, 59, 27248, 99, 105, 114, 59, 27247, 59, 25162, 100, 59, 25163, 115, 59, 16423, 114, 111, 120, 256, 59, 101, 4801, 5778, 241, 5763, 105, 110, 103, 32827, 229, 16613, 384, 99, 116, 121, 5793, 5798, 5800, 114, 59, 49152, 55349, 56502, 59, 16426, 109, 112, 256, 59, 101, 4801, 5807, 241, 648, 105, 108, 100, 101, 32827, 227, 16611, 109, 108, 32827, 228, 16612, 256, 99, 105, 5826, 5832, 111, 110, 105, 110, 244, 626, 110, 116, 59, 27153, 2048, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 5869, 5873, 5936, 5948, 5955, 5960, 6008, 6013, 6112, 6118, 6201, 6224, 5901, 6461, 6472, 6512, 111, 116, 59, 27373, 256, 99, 114, 5878, 5918, 107, 512, 99, 101, 112, 115, 5888, 5893, 5901, 5907, 111, 110, 103, 59, 25164, 112, 115, 105, 108, 111, 110, 59, 17398, 114, 105, 109, 101, 59, 24629, 105, 109, 256, 59, 101, 5914, 5915, 25149, 113, 59, 25293, 374, 5922, 5926, 101, 101, 59, 25277, 101, 100, 256, 59, 103, 5932, 5933, 25349, 101, 187, 5933, 114, 107, 256, 59, 116, 4956, 5943, 98, 114, 107, 59, 25526, 256, 111, 121, 5889, 5953, 59, 17457, 113, 117, 111, 59, 24606, 640, 99, 109, 112, 114, 116, 5971, 5979, 5985, 5988, 5992, 97, 117, 115, 256, 59, 101, 266, 265, 112, 116, 121, 118, 59, 27056, 115, 233, 5900, 110, 111, 245, 275, 384, 97, 104, 119, 5999, 6001, 6003, 59, 17330, 59, 24886, 101, 101, 110, 59, 25196, 114, 59, 49152, 55349, 56607, 103, 896, 99, 111, 115, 116, 117, 118, 119, 6029, 6045, 6067, 6081, 6101, 6107, 6110, 384, 97, 105, 117, 6036, 6038, 6042, 240, 1888, 114, 99, 59, 26095, 112, 187, 4977, 384, 100, 112, 116, 6052, 6056, 6061, 111, 116, 59, 27136, 108, 117, 115, 59, 27137, 105, 109, 101, 115, 59, 27138, 625, 6073, 0, 0, 6078, 99, 117, 112, 59, 27142, 97, 114, 59, 26117, 114, 105, 97, 110, 103, 108, 101, 256, 100, 117, 6093, 6098, 111, 119, 110, 59, 26045, 112, 59, 26035, 112, 108, 117, 115, 59, 27140, 101, 229, 5188, 229, 5293, 97, 114, 111, 119, 59, 26893, 384, 97, 107, 111, 6125, 6182, 6197, 256, 99, 110, 6130, 6179, 107, 384, 108, 115, 116, 6138, 1451, 6146, 111, 122, 101, 110, 103, 101, 59, 27115, 114, 105, 97, 110, 103, 108, 101, 512, 59, 100, 108, 114, 6162, 6163, 6168, 6173, 26036, 111, 119, 110, 59, 26046, 101, 102, 116, 59, 26050, 105, 103, 104, 116, 59, 26040, 107, 59, 25635, 433, 6187, 0, 6195, 434, 6191, 0, 6193, 59, 26002, 59, 26001, 52, 59, 26003, 99, 107, 59, 25992, 256, 101, 111, 6206, 6221, 256, 59, 113, 6211, 6214, 49152, 61, 8421, 117, 105, 118, 59, 49152, 8801, 8421, 116, 59, 25360, 512, 112, 116, 119, 120, 6233, 6238, 6247, 6252, 102, 59, 49152, 55349, 56659, 256, 59, 116, 5067, 6243, 111, 109, 187, 5068, 116, 105, 101, 59, 25288, 1536, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 6277, 6294, 6314, 6331, 6359, 6363, 6380, 6399, 6405, 6410, 6416, 6433, 512, 76, 82, 108, 114, 6286, 6288, 6290, 6292, 59, 25943, 59, 25940, 59, 25942, 59, 25939, 640, 59, 68, 85, 100, 117, 6305, 6306, 6308, 6310, 6312, 25936, 59, 25958, 59, 25961, 59, 25956, 59, 25959, 512, 76, 82, 108, 114, 6323, 6325, 6327, 6329, 59, 25949, 59, 25946, 59, 25948, 59, 25945, 896, 59, 72, 76, 82, 104, 108, 114, 6346, 6347, 6349, 6351, 6353, 6355, 6357, 25937, 59, 25964, 59, 25955, 59, 25952, 59, 25963, 59, 25954, 59, 25951, 111, 120, 59, 27081, 512, 76, 82, 108, 114, 6372, 6374, 6376, 6378, 59, 25941, 59, 25938, 59, 25872, 59, 25868, 640, 59, 68, 85, 100, 117, 1725, 6391, 6393, 6395, 6397, 59, 25957, 59, 25960, 59, 25900, 59, 25908, 105, 110, 117, 115, 59, 25247, 108, 117, 115, 59, 25246, 105, 109, 101, 115, 59, 25248, 512, 76, 82, 108, 114, 6425, 6427, 6429, 6431, 59, 25947, 59, 25944, 59, 25880, 59, 25876, 896, 59, 72, 76, 82, 104, 108, 114, 6448, 6449, 6451, 6453, 6455, 6457, 6459, 25858, 59, 25962, 59, 25953, 59, 25950, 59, 25916, 59, 25892, 59, 25884, 256, 101, 118, 291, 6466, 98, 97, 114, 32827, 166, 16550, 512, 99, 101, 105, 111, 6481, 6486, 6490, 6496, 114, 59, 49152, 55349, 56503, 109, 105, 59, 24655, 109, 256, 59, 101, 5914, 5916, 108, 384, 59, 98, 104, 6504, 6505, 6507, 16476, 59, 27077, 115, 117, 98, 59, 26568, 364, 6516, 6526, 108, 256, 59, 101, 6521, 6522, 24610, 116, 187, 6522, 112, 384, 59, 69, 101, 303, 6533, 6535, 59, 27310, 256, 59, 113, 1756, 1755, 3297, 6567, 0, 6632, 6673, 6677, 6706, 0, 6711, 6736, 0, 0, 6836, 0, 0, 6849, 0, 0, 6945, 6958, 6989, 6994, 0, 7165, 0, 7180, 384, 99, 112, 114, 6573, 6578, 6621, 117, 116, 101, 59, 16647, 768, 59, 97, 98, 99, 100, 115, 6591, 6592, 6596, 6602, 6613, 6617, 25129, 110, 100, 59, 27204, 114, 99, 117, 112, 59, 27209, 256, 97, 117, 6607, 6610, 112, 59, 27211, 112, 59, 27207, 111, 116, 59, 27200, 59, 49152, 8745, 65024, 256, 101, 111, 6626, 6629, 116, 59, 24641, 238, 1683, 512, 97, 101, 105, 117, 6640, 6651, 6657, 6661, 496, 6645, 0, 6648, 115, 59, 27213, 111, 110, 59, 16653, 100, 105, 108, 32827, 231, 16615, 114, 99, 59, 16649, 112, 115, 256, 59, 115, 6668, 6669, 27212, 109, 59, 27216, 111, 116, 59, 16651, 384, 100, 109, 110, 6683, 6688, 6694, 105, 108, 32955, 184, 429, 112, 116, 121, 118, 59, 27058, 116, 33024, 162, 59, 101, 6701, 6702, 16546, 114, 228, 434, 114, 59, 49152, 55349, 56608, 384, 99, 101, 105, 6717, 6720, 6733, 121, 59, 17479, 99, 107, 256, 59, 109, 6727, 6728, 26387, 97, 114, 107, 187, 6728, 59, 17351, 114, 896, 59, 69, 99, 101, 102, 109, 115, 6751, 6752, 6754, 6763, 6820, 6826, 6830, 26059, 59, 27075, 384, 59, 101, 108, 6761, 6762, 6765, 17094, 113, 59, 25175, 101, 609, 6772, 0, 0, 6792, 114, 114, 111, 119, 256, 108, 114, 6780, 6785, 101, 102, 116, 59, 25018, 105, 103, 104, 116, 59, 25019, 640, 82, 83, 97, 99, 100, 6802, 6804, 6806, 6810, 6815, 187, 3911, 59, 25800, 115, 116, 59, 25243, 105, 114, 99, 59, 25242, 97, 115, 104, 59, 25245, 110, 105, 110, 116, 59, 27152, 105, 100, 59, 27375, 99, 105, 114, 59, 27074, 117, 98, 115, 256, 59, 117, 6843, 6844, 26211, 105, 116, 187, 6844, 748, 6855, 6868, 6906, 0, 6922, 111, 110, 256, 59, 101, 6861, 6862, 16442, 256, 59, 113, 199, 198, 621, 6873, 0, 0, 6882, 97, 256, 59, 116, 6878, 6879, 16428, 59, 16448, 384, 59, 102, 108, 6888, 6889, 6891, 25089, 238, 4448, 101, 256, 109, 120, 6897, 6902, 101, 110, 116, 187, 6889, 101, 243, 589, 487, 6910, 0, 6919, 256, 59, 100, 4795, 6914, 111, 116, 59, 27245, 110, 244, 582, 384, 102, 114, 121, 6928, 6932, 6935, 59, 49152, 55349, 56660, 111, 228, 596, 33024, 169, 59, 115, 341, 6941, 114, 59, 24855, 256, 97, 111, 6949, 6953, 114, 114, 59, 25013, 115, 115, 59, 26391, 256, 99, 117, 6962, 6967, 114, 59, 49152, 55349, 56504, 256, 98, 112, 6972, 6980, 256, 59, 101, 6977, 6978, 27343, 59, 27345, 256, 59, 101, 6985, 6986, 27344, 59, 27346, 100, 111, 116, 59, 25327, 896, 100, 101, 108, 112, 114, 118, 119, 7008, 7020, 7031, 7042, 7084, 7124, 7161, 97, 114, 114, 256, 108, 114, 7016, 7018, 59, 26936, 59, 26933, 624, 7026, 0, 0, 7029, 114, 59, 25310, 99, 59, 25311, 97, 114, 114, 256, 59, 112, 7039, 7040, 25014, 59, 26941, 768, 59, 98, 99, 100, 111, 115, 7055, 7056, 7062, 7073, 7077, 7080, 25130, 114, 99, 97, 112, 59, 27208, 256, 97, 117, 7067, 7070, 112, 59, 27206, 112, 59, 27210, 111, 116, 59, 25229, 114, 59, 27205, 59, 49152, 8746, 65024, 512, 97, 108, 114, 118, 7093, 7103, 7134, 7139, 114, 114, 256, 59, 109, 7100, 7101, 25015, 59, 26940, 121, 384, 101, 118, 119, 7111, 7124, 7128, 113, 624, 7118, 0, 0, 7122, 114, 101, 227, 7027, 117, 227, 7029, 101, 101, 59, 25294, 101, 100, 103, 101, 59, 25295, 101, 110, 32827, 164, 16548, 101, 97, 114, 114, 111, 119, 256, 108, 114, 7150, 7155, 101, 102, 116, 187, 7040, 105, 103, 104, 116, 187, 7101, 101, 228, 7133, 256, 99, 105, 7169, 7175, 111, 110, 105, 110, 244, 503, 110, 116, 59, 25137, 108, 99, 116, 121, 59, 25389, 2432, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 7224, 7227, 7231, 7261, 7273, 7285, 7306, 7326, 7340, 7351, 7419, 7423, 7437, 7547, 7569, 7595, 7611, 7622, 7629, 114, 242, 897, 97, 114, 59, 26981, 512, 103, 108, 114, 115, 7240, 7245, 7250, 7252, 103, 101, 114, 59, 24608, 101, 116, 104, 59, 24888, 242, 4403, 104, 256, 59, 118, 7258, 7259, 24592, 187, 2314, 363, 7265, 7271, 97, 114, 111, 119, 59, 26895, 97, 227, 789, 256, 97, 121, 7278, 7283, 114, 111, 110, 59, 16655, 59, 17460, 384, 59, 97, 111, 818, 7292, 7300, 256, 103, 114, 703, 7297, 114, 59, 25034, 116, 115, 101, 113, 59, 27255, 384, 103, 108, 109, 7313, 7316, 7320, 32827, 176, 16560, 116, 97, 59, 17332, 112, 116, 121, 118, 59, 27057, 256, 105, 114, 7331, 7336, 115, 104, 116, 59, 27007, 59, 49152, 55349, 56609, 97, 114, 256, 108, 114, 7347, 7349, 187, 2268, 187, 4126, 640, 97, 101, 103, 115, 118, 7362, 888, 7382, 7388, 7392, 109, 384, 59, 111, 115, 806, 7370, 7380, 110, 100, 256, 59, 115, 806, 7377, 117, 105, 116, 59, 26214, 97, 109, 109, 97, 59, 17373, 105, 110, 59, 25330, 384, 59, 105, 111, 7399, 7400, 7416, 16631, 100, 101, 33024, 247, 59, 111, 7399, 7408, 110, 116, 105, 109, 101, 115, 59, 25287, 110, 248, 7415, 99, 121, 59, 17490, 99, 623, 7430, 0, 0, 7434, 114, 110, 59, 25374, 111, 112, 59, 25357, 640, 108, 112, 116, 117, 119, 7448, 7453, 7458, 7497, 7509, 108, 97, 114, 59, 16420, 102, 59, 49152, 55349, 56661, 640, 59, 101, 109, 112, 115, 779, 7469, 7479, 7485, 7490, 113, 256, 59, 100, 850, 7475, 111, 116, 59, 25169, 105, 110, 117, 115, 59, 25144, 108, 117, 115, 59, 25108, 113, 117, 97, 114, 101, 59, 25249, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 229, 250, 110, 384, 97, 100, 104, 4398, 7517, 7527, 111, 119, 110, 97, 114, 114, 111, 119, 243, 7299, 97, 114, 112, 111, 111, 110, 256, 108, 114, 7538, 7542, 101, 102, 244, 7348, 105, 103, 104, 244, 7350, 354, 7551, 7557, 107, 97, 114, 111, 247, 3906, 623, 7562, 0, 0, 7566, 114, 110, 59, 25375, 111, 112, 59, 25356, 384, 99, 111, 116, 7576, 7587, 7590, 256, 114, 121, 7581, 7585, 59, 49152, 55349, 56505, 59, 17493, 108, 59, 27126, 114, 111, 107, 59, 16657, 256, 100, 114, 7600, 7604, 111, 116, 59, 25329, 105, 256, 59, 102, 7610, 6166, 26047, 256, 97, 104, 7616, 7619, 114, 242, 1065, 97, 242, 4006, 97, 110, 103, 108, 101, 59, 27046, 256, 99, 105, 7634, 7637, 121, 59, 17503, 103, 114, 97, 114, 114, 59, 26623, 2304, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 7681, 7689, 7705, 7736, 1400, 7740, 7753, 7777, 7806, 7845, 7855, 7869, 7905, 7978, 7991, 8004, 8014, 8026, 256, 68, 111, 7686, 7476, 111, 244, 7305, 256, 99, 115, 7694, 7700, 117, 116, 101, 32827, 233, 16617, 116, 101, 114, 59, 27246, 512, 97, 105, 111, 121, 7714, 7719, 7729, 7734, 114, 111, 110, 59, 16667, 114, 256, 59, 99, 7725, 7726, 25174, 32827, 234, 16618, 108, 111, 110, 59, 25173, 59, 17485, 111, 116, 59, 16663, 256, 68, 114, 7745, 7749, 111, 116, 59, 25170, 59, 49152, 55349, 56610, 384, 59, 114, 115, 7760, 7761, 7767, 27290, 97, 118, 101, 32827, 232, 16616, 256, 59, 100, 7772, 7773, 27286, 111, 116, 59, 27288, 512, 59, 105, 108, 115, 7786, 7787, 7794, 7796, 27289, 110, 116, 101, 114, 115, 59, 25575, 59, 24851, 256, 59, 100, 7801, 7802, 27285, 111, 116, 59, 27287, 384, 97, 112, 115, 7813, 7817, 7831, 99, 114, 59, 16659, 116, 121, 384, 59, 115, 118, 7826, 7827, 7829, 25093, 101, 116, 187, 7827, 112, 256, 49, 59, 7837, 7844, 307, 7841, 7843, 59, 24580, 59, 24581, 24579, 256, 103, 115, 7850, 7852, 59, 16715, 112, 59, 24578, 256, 103, 112, 7860, 7864, 111, 110, 59, 16665, 102, 59, 49152, 55349, 56662, 384, 97, 108, 115, 7876, 7886, 7890, 114, 256, 59, 115, 7882, 7883, 25301, 108, 59, 27107, 117, 115, 59, 27249, 105, 384, 59, 108, 118, 7898, 7899, 7903, 17333, 111, 110, 187, 7899, 59, 17397, 512, 99, 115, 117, 118, 7914, 7923, 7947, 7971, 256, 105, 111, 7919, 7729, 114, 99, 187, 7726, 617, 7929, 0, 0, 7931, 237, 1352, 97, 110, 116, 256, 103, 108, 7938, 7942, 116, 114, 187, 7773, 101, 115, 115, 187, 7802, 384, 97, 101, 105, 7954, 7958, 7962, 108, 115, 59, 16445, 115, 116, 59, 25183, 118, 256, 59, 68, 565, 7968, 68, 59, 27256, 112, 97, 114, 115, 108, 59, 27109, 256, 68, 97, 7983, 7987, 111, 116, 59, 25171, 114, 114, 59, 26993, 384, 99, 100, 105, 7998, 8001, 7928, 114, 59, 24879, 111, 244, 850, 256, 97, 104, 8009, 8011, 59, 17335, 32827, 240, 16624, 256, 109, 114, 8019, 8023, 108, 32827, 235, 16619, 111, 59, 24748, 384, 99, 105, 112, 8033, 8036, 8039, 108, 59, 16417, 115, 244, 1390, 256, 101, 111, 8044, 8052, 99, 116, 97, 116, 105, 111, 238, 1369, 110, 101, 110, 116, 105, 97, 108, 229, 1401, 2529, 8082, 0, 8094, 0, 8097, 8103, 0, 0, 8134, 8140, 0, 8147, 0, 8166, 8170, 8192, 0, 8200, 8282, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7748, 121, 59, 17476, 109, 97, 108, 101, 59, 26176, 384, 105, 108, 114, 8109, 8115, 8129, 108, 105, 103, 59, 32768, 64259, 617, 8121, 0, 0, 8125, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 49152, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 49152, 102, 106, 384, 97, 108, 116, 8153, 8156, 8161, 116, 59, 26221, 105, 103, 59, 32768, 64258, 110, 115, 59, 26033, 111, 102, 59, 16786, 496, 8174, 0, 8179, 102, 59, 49152, 55349, 56663, 256, 97, 107, 1471, 8183, 256, 59, 118, 8188, 8189, 25300, 59, 27353, 97, 114, 116, 105, 110, 116, 59, 27149, 256, 97, 111, 8204, 8277, 256, 99, 115, 8209, 8274, 945, 8218, 8240, 8248, 8261, 8264, 0, 8272, 946, 8226, 8229, 8231, 8234, 8236, 0, 8238, 32827, 189, 16573, 59, 24915, 32827, 188, 16572, 59, 24917, 59, 24921, 59, 24923, 435, 8244, 0, 8246, 59, 24916, 59, 24918, 692, 8254, 8257, 0, 0, 8259, 32827, 190, 16574, 59, 24919, 59, 24924, 53, 59, 24920, 438, 8268, 0, 8270, 59, 24922, 59, 24925, 56, 59, 24926, 108, 59, 24644, 119, 110, 59, 25378, 99, 114, 59, 49152, 55349, 56507, 2176, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 8322, 8329, 8351, 8357, 8368, 8372, 8432, 8437, 8442, 8447, 8451, 8466, 8504, 791, 8510, 8530, 8606, 256, 59, 108, 1613, 8327, 59, 27276, 384, 99, 109, 112, 8336, 8341, 8349, 117, 116, 101, 59, 16885, 109, 97, 256, 59, 100, 8348, 7386, 17331, 59, 27270, 114, 101, 118, 101, 59, 16671, 256, 105, 121, 8362, 8366, 114, 99, 59, 16669, 59, 17459, 111, 116, 59, 16673, 512, 59, 108, 113, 115, 1598, 1602, 8381, 8393, 384, 59, 113, 115, 1598, 1612, 8388, 108, 97, 110, 244, 1637, 512, 59, 99, 100, 108, 1637, 8402, 8405, 8421, 99, 59, 27305, 111, 116, 256, 59, 111, 8412, 8413, 27264, 256, 59, 108, 8418, 8419, 27266, 59, 27268, 256, 59, 101, 8426, 8429, 49152, 8923, 65024, 115, 59, 27284, 114, 59, 49152, 55349, 56612, 256, 59, 103, 1651, 1563, 109, 101, 108, 59, 24887, 99, 121, 59, 17491, 512, 59, 69, 97, 106, 1626, 8460, 8462, 8464, 59, 27282, 59, 27301, 59, 27300, 512, 69, 97, 101, 115, 8475, 8477, 8489, 8500, 59, 25193, 112, 256, 59, 112, 8483, 8484, 27274, 114, 111, 120, 187, 8484, 256, 59, 113, 8494, 8495, 27272, 256, 59, 113, 8494, 8475, 105, 109, 59, 25319, 112, 102, 59, 49152, 55349, 56664, 256, 99, 105, 8515, 8518, 114, 59, 24842, 109, 384, 59, 101, 108, 1643, 8526, 8528, 59, 27278, 59, 27280, 33536, 62, 59, 99, 100, 108, 113, 114, 1518, 8544, 8554, 8558, 8563, 8569, 256, 99, 105, 8549, 8551, 59, 27303, 114, 59, 27258, 111, 116, 59, 25303, 80, 97, 114, 59, 27029, 117, 101, 115, 116, 59, 27260, 640, 97, 100, 101, 108, 115, 8580, 8554, 8592, 1622, 8603, 496, 8585, 0, 8590, 112, 114, 111, 248, 8350, 114, 59, 27e3, 113, 256, 108, 113, 1599, 8598, 108, 101, 115, 243, 8328, 105, 237, 1643, 256, 101, 110, 8611, 8621, 114, 116, 110, 101, 113, 113, 59, 49152, 8809, 65024, 197, 8618, 1280, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 8644, 8647, 8689, 8693, 8698, 8728, 8733, 8751, 8808, 8829, 114, 242, 928, 512, 105, 108, 109, 114, 8656, 8660, 8663, 8667, 114, 115, 240, 5252, 102, 187, 8228, 105, 108, 244, 1705, 256, 100, 114, 8672, 8676, 99, 121, 59, 17482, 384, 59, 99, 119, 2292, 8683, 8687, 105, 114, 59, 26952, 59, 25005, 97, 114, 59, 24847, 105, 114, 99, 59, 16677, 384, 97, 108, 114, 8705, 8718, 8723, 114, 116, 115, 256, 59, 117, 8713, 8714, 26213, 105, 116, 187, 8714, 108, 105, 112, 59, 24614, 99, 111, 110, 59, 25273, 114, 59, 49152, 55349, 56613, 115, 256, 101, 119, 8739, 8745, 97, 114, 111, 119, 59, 26917, 97, 114, 111, 119, 59, 26918, 640, 97, 109, 111, 112, 114, 8762, 8766, 8771, 8798, 8803, 114, 114, 59, 25087, 116, 104, 116, 59, 25147, 107, 256, 108, 114, 8777, 8787, 101, 102, 116, 97, 114, 114, 111, 119, 59, 25001, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25002, 102, 59, 49152, 55349, 56665, 98, 97, 114, 59, 24597, 384, 99, 108, 116, 8815, 8820, 8824, 114, 59, 49152, 55349, 56509, 97, 115, 232, 8692, 114, 111, 107, 59, 16679, 256, 98, 112, 8834, 8839, 117, 108, 108, 59, 24643, 104, 101, 110, 187, 7259, 2785, 8867, 0, 8874, 0, 8888, 8901, 8910, 0, 8917, 8947, 0, 0, 8952, 8994, 9063, 9058, 9087, 0, 9094, 9130, 9140, 99, 117, 116, 101, 32827, 237, 16621, 384, 59, 105, 121, 1905, 8880, 8885, 114, 99, 32827, 238, 16622, 59, 17464, 256, 99, 120, 8892, 8895, 121, 59, 17461, 99, 108, 32827, 161, 16545, 256, 102, 114, 927, 8905, 59, 49152, 55349, 56614, 114, 97, 118, 101, 32827, 236, 16620, 512, 59, 105, 110, 111, 1854, 8925, 8937, 8942, 256, 105, 110, 8930, 8934, 110, 116, 59, 27148, 116, 59, 25133, 102, 105, 110, 59, 27100, 116, 97, 59, 24873, 108, 105, 103, 59, 16691, 384, 97, 111, 112, 8958, 8986, 8989, 384, 99, 103, 116, 8965, 8968, 8983, 114, 59, 16683, 384, 101, 108, 112, 1823, 8975, 8979, 105, 110, 229, 1934, 97, 114, 244, 1824, 104, 59, 16689, 102, 59, 25271, 101, 100, 59, 16821, 640, 59, 99, 102, 111, 116, 1268, 9004, 9009, 9021, 9025, 97, 114, 101, 59, 24837, 105, 110, 256, 59, 116, 9016, 9017, 25118, 105, 101, 59, 27101, 100, 111, 244, 8985, 640, 59, 99, 101, 108, 112, 1879, 9036, 9040, 9051, 9057, 97, 108, 59, 25274, 256, 103, 114, 9045, 9049, 101, 114, 243, 5475, 227, 9037, 97, 114, 104, 107, 59, 27159, 114, 111, 100, 59, 27196, 512, 99, 103, 112, 116, 9071, 9074, 9078, 9083, 121, 59, 17489, 111, 110, 59, 16687, 102, 59, 49152, 55349, 56666, 97, 59, 17337, 117, 101, 115, 116, 32827, 191, 16575, 256, 99, 105, 9098, 9103, 114, 59, 49152, 55349, 56510, 110, 640, 59, 69, 100, 115, 118, 1268, 9115, 9117, 9121, 1267, 59, 25337, 111, 116, 59, 25333, 256, 59, 118, 9126, 9127, 25332, 59, 25331, 256, 59, 105, 1911, 9134, 108, 100, 101, 59, 16681, 491, 9144, 0, 9148, 99, 121, 59, 17494, 108, 32827, 239, 16623, 768, 99, 102, 109, 111, 115, 117, 9164, 9175, 9180, 9185, 9191, 9205, 256, 105, 121, 9169, 9173, 114, 99, 59, 16693, 59, 17465, 114, 59, 49152, 55349, 56615, 97, 116, 104, 59, 16951, 112, 102, 59, 49152, 55349, 56667, 483, 9196, 0, 9201, 114, 59, 49152, 55349, 56511, 114, 99, 121, 59, 17496, 107, 99, 121, 59, 17492, 1024, 97, 99, 102, 103, 104, 106, 111, 115, 9227, 9238, 9250, 9255, 9261, 9265, 9269, 9275, 112, 112, 97, 256, 59, 118, 9235, 9236, 17338, 59, 17392, 256, 101, 121, 9243, 9248, 100, 105, 108, 59, 16695, 59, 17466, 114, 59, 49152, 55349, 56616, 114, 101, 101, 110, 59, 16696, 99, 121, 59, 17477, 99, 121, 59, 17500, 112, 102, 59, 49152, 55349, 56668, 99, 114, 59, 49152, 55349, 56512, 2944, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 9328, 9345, 9350, 9357, 9361, 9486, 9533, 9562, 9600, 9806, 9822, 9829, 9849, 9853, 9882, 9906, 9944, 10077, 10088, 10123, 10176, 10241, 10258, 384, 97, 114, 116, 9335, 9338, 9340, 114, 242, 2502, 242, 917, 97, 105, 108, 59, 26907, 97, 114, 114, 59, 26894, 256, 59, 103, 2452, 9355, 59, 27275, 97, 114, 59, 26978, 2403, 9381, 0, 9386, 0, 9393, 0, 0, 0, 0, 0, 9397, 9402, 0, 9414, 9416, 9421, 0, 9465, 117, 116, 101, 59, 16698, 109, 112, 116, 121, 118, 59, 27060, 114, 97, 238, 2124, 98, 100, 97, 59, 17339, 103, 384, 59, 100, 108, 2190, 9409, 9411, 59, 27025, 229, 2190, 59, 27269, 117, 111, 32827, 171, 16555, 114, 1024, 59, 98, 102, 104, 108, 112, 115, 116, 2201, 9438, 9446, 9449, 9451, 9454, 9457, 9461, 256, 59, 102, 2205, 9443, 115, 59, 26911, 115, 59, 26909, 235, 8786, 112, 59, 25003, 108, 59, 26937, 105, 109, 59, 26995, 108, 59, 24994, 384, 59, 97, 101, 9471, 9472, 9476, 27307, 105, 108, 59, 26905, 256, 59, 115, 9481, 9482, 27309, 59, 49152, 10925, 65024, 384, 97, 98, 114, 9493, 9497, 9501, 114, 114, 59, 26892, 114, 107, 59, 26482, 256, 97, 107, 9506, 9516, 99, 256, 101, 107, 9512, 9514, 59, 16507, 59, 16475, 256, 101, 115, 9521, 9523, 59, 27019, 108, 256, 100, 117, 9529, 9531, 59, 27023, 59, 27021, 512, 97, 101, 117, 121, 9542, 9547, 9558, 9560, 114, 111, 110, 59, 16702, 256, 100, 105, 9552, 9556, 105, 108, 59, 16700, 236, 2224, 226, 9513, 59, 17467, 512, 99, 113, 114, 115, 9571, 9574, 9581, 9597, 97, 59, 26934, 117, 111, 256, 59, 114, 3609, 5958, 256, 100, 117, 9586, 9591, 104, 97, 114, 59, 26983, 115, 104, 97, 114, 59, 26955, 104, 59, 25010, 640, 59, 102, 103, 113, 115, 9611, 9612, 2441, 9715, 9727, 25188, 116, 640, 97, 104, 108, 114, 116, 9624, 9636, 9655, 9666, 9704, 114, 114, 111, 119, 256, 59, 116, 2201, 9633, 97, 233, 9462, 97, 114, 112, 111, 111, 110, 256, 100, 117, 9647, 9652, 111, 119, 110, 187, 1114, 112, 187, 2406, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 25031, 105, 103, 104, 116, 384, 97, 104, 115, 9677, 9686, 9694, 114, 114, 111, 119, 256, 59, 115, 2292, 2215, 97, 114, 112, 111, 111, 110, 243, 3992, 113, 117, 105, 103, 97, 114, 114, 111, 247, 8688, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25291, 384, 59, 113, 115, 9611, 2451, 9722, 108, 97, 110, 244, 2476, 640, 59, 99, 100, 103, 115, 2476, 9738, 9741, 9757, 9768, 99, 59, 27304, 111, 116, 256, 59, 111, 9748, 9749, 27263, 256, 59, 114, 9754, 9755, 27265, 59, 27267, 256, 59, 101, 9762, 9765, 49152, 8922, 65024, 115, 59, 27283, 640, 97, 100, 101, 103, 115, 9779, 9785, 9789, 9801, 9803, 112, 112, 114, 111, 248, 9414, 111, 116, 59, 25302, 113, 256, 103, 113, 9795, 9797, 244, 2441, 103, 116, 242, 9356, 244, 2459, 105, 237, 2482, 384, 105, 108, 114, 9813, 2273, 9818, 115, 104, 116, 59, 27004, 59, 49152, 55349, 56617, 256, 59, 69, 2460, 9827, 59, 27281, 353, 9833, 9846, 114, 256, 100, 117, 9650, 9838, 256, 59, 108, 2405, 9843, 59, 26986, 108, 107, 59, 25988, 99, 121, 59, 17497, 640, 59, 97, 99, 104, 116, 2632, 9864, 9867, 9873, 9878, 114, 242, 9665, 111, 114, 110, 101, 242, 7432, 97, 114, 100, 59, 26987, 114, 105, 59, 26106, 256, 105, 111, 9887, 9892, 100, 111, 116, 59, 16704, 117, 115, 116, 256, 59, 97, 9900, 9901, 25520, 99, 104, 101, 187, 9901, 512, 69, 97, 101, 115, 9915, 9917, 9929, 9940, 59, 25192, 112, 256, 59, 112, 9923, 9924, 27273, 114, 111, 120, 187, 9924, 256, 59, 113, 9934, 9935, 27271, 256, 59, 113, 9934, 9915, 105, 109, 59, 25318, 1024, 97, 98, 110, 111, 112, 116, 119, 122, 9961, 9972, 9975, 10010, 10031, 10049, 10055, 10064, 256, 110, 114, 9966, 9969, 103, 59, 26604, 114, 59, 25085, 114, 235, 2241, 103, 384, 108, 109, 114, 9983, 9997, 10004, 101, 102, 116, 256, 97, 114, 2534, 9991, 105, 103, 104, 116, 225, 2546, 97, 112, 115, 116, 111, 59, 26620, 105, 103, 104, 116, 225, 2557, 112, 97, 114, 114, 111, 119, 256, 108, 114, 10021, 10025, 101, 102, 244, 9453, 105, 103, 104, 116, 59, 25004, 384, 97, 102, 108, 10038, 10041, 10045, 114, 59, 27013, 59, 49152, 55349, 56669, 117, 115, 59, 27181, 105, 109, 101, 115, 59, 27188, 353, 10059, 10063, 115, 116, 59, 25111, 225, 4942, 384, 59, 101, 102, 10071, 10072, 6144, 26058, 110, 103, 101, 187, 10072, 97, 114, 256, 59, 108, 10084, 10085, 16424, 116, 59, 27027, 640, 97, 99, 104, 109, 116, 10099, 10102, 10108, 10117, 10119, 114, 242, 2216, 111, 114, 110, 101, 242, 7564, 97, 114, 256, 59, 100, 3992, 10115, 59, 26989, 59, 24590, 114, 105, 59, 25279, 768, 97, 99, 104, 105, 113, 116, 10136, 10141, 2624, 10146, 10158, 10171, 113, 117, 111, 59, 24633, 114, 59, 49152, 55349, 56513, 109, 384, 59, 101, 103, 2482, 10154, 10156, 59, 27277, 59, 27279, 256, 98, 117, 9514, 10163, 111, 256, 59, 114, 3615, 10169, 59, 24602, 114, 111, 107, 59, 16706, 33792, 60, 59, 99, 100, 104, 105, 108, 113, 114, 2091, 10194, 9785, 10204, 10208, 10213, 10218, 10224, 256, 99, 105, 10199, 10201, 59, 27302, 114, 59, 27257, 114, 101, 229, 9714, 109, 101, 115, 59, 25289, 97, 114, 114, 59, 26998, 117, 101, 115, 116, 59, 27259, 256, 80, 105, 10229, 10233, 97, 114, 59, 27030, 384, 59, 101, 102, 10240, 2349, 6171, 26051, 114, 256, 100, 117, 10247, 10253, 115, 104, 97, 114, 59, 26954, 104, 97, 114, 59, 26982, 256, 101, 110, 10263, 10273, 114, 116, 110, 101, 113, 113, 59, 49152, 8808, 65024, 197, 10270, 1792, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 10304, 10309, 10370, 10382, 10387, 10400, 10405, 10408, 10458, 10466, 10468, 2691, 10483, 10498, 68, 111, 116, 59, 25146, 512, 99, 108, 112, 114, 10318, 10322, 10339, 10365, 114, 32827, 175, 16559, 256, 101, 116, 10327, 10329, 59, 26178, 256, 59, 101, 10334, 10335, 26400, 115, 101, 187, 10335, 256, 59, 115, 4155, 10344, 116, 111, 512, 59, 100, 108, 117, 4155, 10355, 10359, 10363, 111, 119, 238, 1164, 101, 102, 244, 2319, 240, 5073, 107, 101, 114, 59, 26030, 256, 111, 121, 10375, 10380, 109, 109, 97, 59, 27177, 59, 17468, 97, 115, 104, 59, 24596, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 187, 5670, 114, 59, 49152, 55349, 56618, 111, 59, 24871, 384, 99, 100, 110, 10415, 10420, 10441, 114, 111, 32827, 181, 16565, 512, 59, 97, 99, 100, 5220, 10429, 10432, 10436, 115, 244, 5799, 105, 114, 59, 27376, 111, 116, 32955, 183, 437, 117, 115, 384, 59, 98, 100, 10450, 6403, 10451, 25106, 256, 59, 117, 7484, 10456, 59, 27178, 355, 10462, 10465, 112, 59, 27355, 242, 8722, 240, 2689, 256, 100, 112, 10473, 10478, 101, 108, 115, 59, 25255, 102, 59, 49152, 55349, 56670, 256, 99, 116, 10488, 10493, 114, 59, 49152, 55349, 56514, 112, 111, 115, 187, 5533, 384, 59, 108, 109, 10505, 10506, 10509, 17340, 116, 105, 109, 97, 112, 59, 25272, 3072, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 10562, 10579, 10622, 10633, 10648, 10714, 10729, 10773, 10778, 10840, 10845, 10883, 10901, 10916, 10920, 11012, 11015, 11076, 11135, 11182, 11316, 11367, 11388, 11497, 256, 103, 116, 10567, 10571, 59, 49152, 8921, 824, 256, 59, 118, 10576, 3023, 49152, 8811, 8402, 384, 101, 108, 116, 10586, 10610, 10614, 102, 116, 256, 97, 114, 10593, 10599, 114, 114, 111, 119, 59, 25037, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25038, 59, 49152, 8920, 824, 256, 59, 118, 10619, 3143, 49152, 8810, 8402, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25039, 256, 68, 100, 10638, 10643, 97, 115, 104, 59, 25263, 97, 115, 104, 59, 25262, 640, 98, 99, 110, 112, 116, 10659, 10663, 10668, 10673, 10700, 108, 97, 187, 734, 117, 116, 101, 59, 16708, 103, 59, 49152, 8736, 8402, 640, 59, 69, 105, 111, 112, 3460, 10684, 10688, 10693, 10696, 59, 49152, 10864, 824, 100, 59, 49152, 8779, 824, 115, 59, 16713, 114, 111, 248, 3460, 117, 114, 256, 59, 97, 10707, 10708, 26222, 108, 256, 59, 115, 10707, 2872, 499, 10719, 0, 10723, 112, 32955, 160, 2871, 109, 112, 256, 59, 101, 3065, 3072, 640, 97, 101, 111, 117, 121, 10740, 10750, 10755, 10768, 10771, 496, 10745, 0, 10747, 59, 27203, 111, 110, 59, 16712, 100, 105, 108, 59, 16710, 110, 103, 256, 59, 100, 3454, 10762, 111, 116, 59, 49152, 10861, 824, 112, 59, 27202, 59, 17469, 97, 115, 104, 59, 24595, 896, 59, 65, 97, 100, 113, 115, 120, 2962, 10793, 10797, 10811, 10817, 10821, 10832, 114, 114, 59, 25047, 114, 256, 104, 114, 10803, 10806, 107, 59, 26916, 256, 59, 111, 5106, 5104, 111, 116, 59, 49152, 8784, 824, 117, 105, 246, 2915, 256, 101, 105, 10826, 10830, 97, 114, 59, 26920, 237, 2968, 105, 115, 116, 256, 59, 115, 2976, 2975, 114, 59, 49152, 55349, 56619, 512, 69, 101, 115, 116, 3013, 10854, 10873, 10876, 384, 59, 113, 115, 3004, 10861, 3041, 384, 59, 113, 115, 3004, 3013, 10868, 108, 97, 110, 244, 3042, 105, 237, 3050, 256, 59, 114, 2998, 10881, 187, 2999, 384, 65, 97, 112, 10890, 10893, 10897, 114, 242, 10609, 114, 114, 59, 25006, 97, 114, 59, 27378, 384, 59, 115, 118, 3981, 10908, 3980, 256, 59, 100, 10913, 10914, 25340, 59, 25338, 99, 121, 59, 17498, 896, 65, 69, 97, 100, 101, 115, 116, 10935, 10938, 10942, 10946, 10949, 10998, 11001, 114, 242, 10598, 59, 49152, 8806, 824, 114, 114, 59, 24986, 114, 59, 24613, 512, 59, 102, 113, 115, 3131, 10958, 10979, 10991, 116, 256, 97, 114, 10964, 10969, 114, 114, 111, 247, 10945, 105, 103, 104, 116, 97, 114, 114, 111, 247, 10896, 384, 59, 113, 115, 3131, 10938, 10986, 108, 97, 110, 244, 3157, 256, 59, 115, 3157, 10996, 187, 3126, 105, 237, 3165, 256, 59, 114, 3125, 11006, 105, 256, 59, 101, 3098, 3109, 105, 228, 3472, 256, 112, 116, 11020, 11025, 102, 59, 49152, 55349, 56671, 33152, 172, 59, 105, 110, 11033, 11034, 11062, 16556, 110, 512, 59, 69, 100, 118, 2953, 11044, 11048, 11054, 59, 49152, 8953, 824, 111, 116, 59, 49152, 8949, 824, 481, 2953, 11059, 11061, 59, 25335, 59, 25334, 105, 256, 59, 118, 3256, 11068, 481, 3256, 11073, 11075, 59, 25342, 59, 25341, 384, 97, 111, 114, 11083, 11107, 11113, 114, 512, 59, 97, 115, 116, 2939, 11093, 11098, 11103, 108, 108, 101, 236, 2939, 108, 59, 49152, 11005, 8421, 59, 49152, 8706, 824, 108, 105, 110, 116, 59, 27156, 384, 59, 99, 101, 3218, 11120, 11123, 117, 229, 3237, 256, 59, 99, 3224, 11128, 256, 59, 101, 3218, 11133, 241, 3224, 512, 65, 97, 105, 116, 11144, 11147, 11165, 11175, 114, 242, 10632, 114, 114, 384, 59, 99, 119, 11156, 11157, 11161, 24987, 59, 49152, 10547, 824, 59, 49152, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 187, 11157, 114, 105, 256, 59, 101, 3275, 3286, 896, 99, 104, 105, 109, 112, 113, 117, 11197, 11213, 11225, 11012, 2936, 11236, 11247, 512, 59, 99, 101, 114, 3378, 11206, 3383, 11209, 117, 229, 3397, 59, 49152, 55349, 56515, 111, 114, 116, 621, 11013, 0, 0, 11222, 97, 114, 225, 11094, 109, 256, 59, 101, 3438, 11231, 256, 59, 113, 3444, 3443, 115, 117, 256, 98, 112, 11243, 11245, 229, 3320, 229, 3339, 384, 98, 99, 112, 11254, 11281, 11289, 512, 59, 69, 101, 115, 11263, 11264, 3362, 11268, 25220, 59, 49152, 10949, 824, 101, 116, 256, 59, 101, 3355, 11275, 113, 256, 59, 113, 3363, 11264, 99, 256, 59, 101, 3378, 11287, 241, 3384, 512, 59, 69, 101, 115, 11298, 11299, 3423, 11303, 25221, 59, 49152, 10950, 824, 101, 116, 256, 59, 101, 3416, 11310, 113, 256, 59, 113, 3424, 11299, 512, 103, 105, 108, 114, 11325, 11327, 11333, 11335, 236, 3031, 108, 100, 101, 32827, 241, 16625, 231, 3139, 105, 97, 110, 103, 108, 101, 256, 108, 114, 11346, 11356, 101, 102, 116, 256, 59, 101, 3098, 11354, 241, 3110, 105, 103, 104, 116, 256, 59, 101, 3275, 11365, 241, 3287, 256, 59, 109, 11372, 11373, 17341, 384, 59, 101, 115, 11380, 11381, 11385, 16419, 114, 111, 59, 24854, 112, 59, 24583, 1152, 68, 72, 97, 100, 103, 105, 108, 114, 115, 11407, 11412, 11417, 11422, 11427, 11440, 11446, 11475, 11491, 97, 115, 104, 59, 25261, 97, 114, 114, 59, 26884, 112, 59, 49152, 8781, 8402, 97, 115, 104, 59, 25260, 256, 101, 116, 11432, 11436, 59, 49152, 8805, 8402, 59, 49152, 62, 8402, 110, 102, 105, 110, 59, 27102, 384, 65, 101, 116, 11453, 11457, 11461, 114, 114, 59, 26882, 59, 49152, 8804, 8402, 256, 59, 114, 11466, 11469, 49152, 60, 8402, 105, 101, 59, 49152, 8884, 8402, 256, 65, 116, 11480, 11484, 114, 114, 59, 26883, 114, 105, 101, 59, 49152, 8885, 8402, 105, 109, 59, 49152, 8764, 8402, 384, 65, 97, 110, 11504, 11508, 11522, 114, 114, 59, 25046, 114, 256, 104, 114, 11514, 11517, 107, 59, 26915, 256, 59, 111, 5095, 5093, 101, 97, 114, 59, 26919, 4691, 6805, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11565, 0, 11576, 11592, 11616, 11621, 11634, 11652, 6919, 0, 0, 11661, 11691, 0, 11720, 11726, 0, 11740, 11801, 11819, 11838, 11843, 256, 99, 115, 11569, 6807, 117, 116, 101, 32827, 243, 16627, 256, 105, 121, 11580, 11589, 114, 256, 59, 99, 6814, 11586, 32827, 244, 16628, 59, 17470, 640, 97, 98, 105, 111, 115, 6816, 11602, 11607, 456, 11610, 108, 97, 99, 59, 16721, 118, 59, 27192, 111, 108, 100, 59, 27068, 108, 105, 103, 59, 16723, 256, 99, 114, 11625, 11629, 105, 114, 59, 27071, 59, 49152, 55349, 56620, 879, 11641, 0, 0, 11644, 0, 11650, 110, 59, 17115, 97, 118, 101, 32827, 242, 16626, 59, 27073, 256, 98, 109, 11656, 3572, 97, 114, 59, 27061, 512, 97, 99, 105, 116, 11669, 11672, 11685, 11688, 114, 242, 6784, 256, 105, 114, 11677, 11680, 114, 59, 27070, 111, 115, 115, 59, 27067, 110, 229, 3666, 59, 27072, 384, 97, 101, 105, 11697, 11701, 11705, 99, 114, 59, 16717, 103, 97, 59, 17353, 384, 99, 100, 110, 11712, 11717, 461, 114, 111, 110, 59, 17343, 59, 27062, 112, 102, 59, 49152, 55349, 56672, 384, 97, 101, 108, 11732, 11735, 466, 114, 59, 27063, 114, 112, 59, 27065, 896, 59, 97, 100, 105, 111, 115, 118, 11754, 11755, 11758, 11784, 11789, 11792, 11798, 25128, 114, 242, 6790, 512, 59, 101, 102, 109, 11767, 11768, 11778, 11781, 27229, 114, 256, 59, 111, 11774, 11775, 24884, 102, 187, 11775, 32827, 170, 16554, 32827, 186, 16570, 103, 111, 102, 59, 25270, 114, 59, 27222, 108, 111, 112, 101, 59, 27223, 59, 27227, 384, 99, 108, 111, 11807, 11809, 11815, 242, 11777, 97, 115, 104, 32827, 248, 16632, 108, 59, 25240, 105, 364, 11823, 11828, 100, 101, 32827, 245, 16629, 101, 115, 256, 59, 97, 475, 11834, 115, 59, 27190, 109, 108, 32827, 246, 16630, 98, 97, 114, 59, 25405, 2785, 11870, 0, 11901, 0, 11904, 11933, 0, 11938, 11961, 0, 0, 11979, 3740, 0, 12051, 0, 0, 12075, 12220, 0, 12232, 114, 512, 59, 97, 115, 116, 1027, 11879, 11890, 3717, 33024, 182, 59, 108, 11885, 11886, 16566, 108, 101, 236, 1027, 617, 11896, 0, 0, 11899, 109, 59, 27379, 59, 27389, 121, 59, 17471, 114, 640, 99, 105, 109, 112, 116, 11915, 11919, 11923, 6245, 11927, 110, 116, 59, 16421, 111, 100, 59, 16430, 105, 108, 59, 24624, 101, 110, 107, 59, 24625, 114, 59, 49152, 55349, 56621, 384, 105, 109, 111, 11944, 11952, 11956, 256, 59, 118, 11949, 11950, 17350, 59, 17365, 109, 97, 244, 2678, 110, 101, 59, 26126, 384, 59, 116, 118, 11967, 11968, 11976, 17344, 99, 104, 102, 111, 114, 107, 187, 8189, 59, 17366, 256, 97, 117, 11983, 11999, 110, 256, 99, 107, 11989, 11997, 107, 256, 59, 104, 8692, 11995, 59, 24846, 246, 8692, 115, 1152, 59, 97, 98, 99, 100, 101, 109, 115, 116, 12019, 12020, 6408, 12025, 12029, 12036, 12038, 12042, 12046, 16427, 99, 105, 114, 59, 27171, 105, 114, 59, 27170, 256, 111, 117, 7488, 12034, 59, 27173, 59, 27250, 110, 32955, 177, 3741, 105, 109, 59, 27174, 119, 111, 59, 27175, 384, 105, 112, 117, 12057, 12064, 12069, 110, 116, 105, 110, 116, 59, 27157, 102, 59, 49152, 55349, 56673, 110, 100, 32827, 163, 16547, 1280, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 3784, 12095, 12097, 12100, 12103, 12161, 12169, 12178, 12158, 12214, 59, 27315, 112, 59, 27319, 117, 229, 3801, 256, 59, 99, 3790, 12108, 768, 59, 97, 99, 101, 110, 115, 3784, 12121, 12127, 12134, 12136, 12158, 112, 112, 114, 111, 248, 12099, 117, 114, 108, 121, 101, 241, 3801, 241, 3790, 384, 97, 101, 115, 12143, 12150, 12154, 112, 112, 114, 111, 120, 59, 27321, 113, 113, 59, 27317, 105, 109, 59, 25320, 105, 237, 3807, 109, 101, 256, 59, 115, 12168, 3758, 24626, 384, 69, 97, 115, 12152, 12176, 12154, 240, 12149, 384, 100, 102, 112, 3820, 12185, 12207, 384, 97, 108, 115, 12192, 12197, 12202, 108, 97, 114, 59, 25390, 105, 110, 101, 59, 25362, 117, 114, 102, 59, 25363, 256, 59, 116, 3835, 12212, 239, 3835, 114, 101, 108, 59, 25264, 256, 99, 105, 12224, 12229, 114, 59, 49152, 55349, 56517, 59, 17352, 110, 99, 115, 112, 59, 24584, 768, 102, 105, 111, 112, 115, 117, 12250, 8930, 12255, 12261, 12267, 12273, 114, 59, 49152, 55349, 56622, 112, 102, 59, 49152, 55349, 56674, 114, 105, 109, 101, 59, 24663, 99, 114, 59, 49152, 55349, 56518, 384, 97, 101, 111, 12280, 12297, 12307, 116, 256, 101, 105, 12286, 12293, 114, 110, 105, 111, 110, 243, 1712, 110, 116, 59, 27158, 115, 116, 256, 59, 101, 12304, 12305, 16447, 241, 7961, 244, 3860, 2688, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 12352, 12369, 12373, 12377, 12512, 12558, 12587, 12615, 12642, 12658, 12686, 12806, 12821, 12836, 12841, 12888, 12910, 12914, 12944, 12976, 12983, 384, 97, 114, 116, 12359, 12362, 12364, 114, 242, 4275, 242, 989, 97, 105, 108, 59, 26908, 97, 114, 242, 7269, 97, 114, 59, 26980, 896, 99, 100, 101, 110, 113, 114, 116, 12392, 12405, 12408, 12415, 12431, 12436, 12492, 256, 101, 117, 12397, 12401, 59, 49152, 8765, 817, 116, 101, 59, 16725, 105, 227, 4462, 109, 112, 116, 121, 118, 59, 27059, 103, 512, 59, 100, 101, 108, 4049, 12425, 12427, 12429, 59, 27026, 59, 27045, 229, 4049, 117, 111, 32827, 187, 16571, 114, 1408, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 4060, 12460, 12463, 12471, 12473, 12476, 12478, 12480, 12483, 12487, 12490, 112, 59, 26997, 256, 59, 102, 4064, 12468, 115, 59, 26912, 59, 26931, 115, 59, 26910, 235, 8797, 240, 10030, 108, 59, 26949, 105, 109, 59, 26996, 108, 59, 24995, 59, 24989, 256, 97, 105, 12497, 12501, 105, 108, 59, 26906, 111, 256, 59, 110, 12507, 12508, 25142, 97, 108, 243, 3870, 384, 97, 98, 114, 12519, 12522, 12526, 114, 242, 6117, 114, 107, 59, 26483, 256, 97, 107, 12531, 12541, 99, 256, 101, 107, 12537, 12539, 59, 16509, 59, 16477, 256, 101, 115, 12546, 12548, 59, 27020, 108, 256, 100, 117, 12554, 12556, 59, 27022, 59, 27024, 512, 97, 101, 117, 121, 12567, 12572, 12583, 12585, 114, 111, 110, 59, 16729, 256, 100, 105, 12577, 12581, 105, 108, 59, 16727, 236, 4082, 226, 12538, 59, 17472, 512, 99, 108, 113, 115, 12596, 12599, 12605, 12612, 97, 59, 26935, 100, 104, 97, 114, 59, 26985, 117, 111, 256, 59, 114, 526, 525, 104, 59, 25011, 384, 97, 99, 103, 12622, 12639, 3908, 108, 512, 59, 105, 112, 115, 3960, 12632, 12635, 4252, 110, 229, 4283, 97, 114, 244, 4009, 116, 59, 26029, 384, 105, 108, 114, 12649, 4131, 12654, 115, 104, 116, 59, 27005, 59, 49152, 55349, 56623, 256, 97, 111, 12663, 12678, 114, 256, 100, 117, 12669, 12671, 187, 1147, 256, 59, 108, 4241, 12676, 59, 26988, 256, 59, 118, 12683, 12684, 17345, 59, 17393, 384, 103, 110, 115, 12693, 12793, 12796, 104, 116, 768, 97, 104, 108, 114, 115, 116, 12708, 12720, 12738, 12760, 12772, 12782, 114, 114, 111, 119, 256, 59, 116, 4060, 12717, 97, 233, 12488, 97, 114, 112, 111, 111, 110, 256, 100, 117, 12731, 12735, 111, 119, 238, 12670, 112, 187, 4242, 101, 102, 116, 256, 97, 104, 12746, 12752, 114, 114, 111, 119, 243, 4074, 97, 114, 112, 111, 111, 110, 243, 1361, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 25033, 113, 117, 105, 103, 97, 114, 114, 111, 247, 12491, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25292, 103, 59, 17114, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7986, 384, 97, 104, 109, 12813, 12816, 12819, 114, 242, 4074, 97, 242, 1361, 59, 24591, 111, 117, 115, 116, 256, 59, 97, 12830, 12831, 25521, 99, 104, 101, 187, 12831, 109, 105, 100, 59, 27374, 512, 97, 98, 112, 116, 12850, 12861, 12864, 12882, 256, 110, 114, 12855, 12858, 103, 59, 26605, 114, 59, 25086, 114, 235, 4099, 384, 97, 102, 108, 12871, 12874, 12878, 114, 59, 27014, 59, 49152, 55349, 56675, 117, 115, 59, 27182, 105, 109, 101, 115, 59, 27189, 256, 97, 112, 12893, 12903, 114, 256, 59, 103, 12899, 12900, 16425, 116, 59, 27028, 111, 108, 105, 110, 116, 59, 27154, 97, 114, 242, 12771, 512, 97, 99, 104, 113, 12923, 12928, 4284, 12933, 113, 117, 111, 59, 24634, 114, 59, 49152, 55349, 56519, 256, 98, 117, 12539, 12938, 111, 256, 59, 114, 532, 531, 384, 104, 105, 114, 12951, 12955, 12960, 114, 101, 229, 12792, 109, 101, 115, 59, 25290, 105, 512, 59, 101, 102, 108, 12970, 4185, 6177, 12971, 26041, 116, 114, 105, 59, 27086, 108, 117, 104, 97, 114, 59, 26984, 59, 24862, 3425, 13013, 13019, 13023, 13100, 13112, 13169, 0, 13178, 13220, 0, 0, 13292, 13296, 0, 13352, 13384, 13402, 13485, 13489, 13514, 13553, 0, 13846, 0, 0, 13875, 99, 117, 116, 101, 59, 16731, 113, 117, 239, 10170, 1280, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 4589, 13043, 13045, 13055, 13058, 13067, 13071, 13087, 13094, 13097, 59, 27316, 496, 13050, 0, 13052, 59, 27320, 111, 110, 59, 16737, 117, 229, 4606, 256, 59, 100, 4595, 13063, 105, 108, 59, 16735, 114, 99, 59, 16733, 384, 69, 97, 115, 13078, 13080, 13083, 59, 27318, 112, 59, 27322, 105, 109, 59, 25321, 111, 108, 105, 110, 116, 59, 27155, 105, 237, 4612, 59, 17473, 111, 116, 384, 59, 98, 101, 13108, 7495, 13109, 25285, 59, 27238, 896, 65, 97, 99, 109, 115, 116, 120, 13126, 13130, 13143, 13147, 13150, 13155, 13165, 114, 114, 59, 25048, 114, 256, 104, 114, 13136, 13138, 235, 8744, 256, 59, 111, 2614, 2612, 116, 32827, 167, 16551, 105, 59, 16443, 119, 97, 114, 59, 26921, 109, 256, 105, 110, 13161, 240, 110, 117, 243, 241, 116, 59, 26422, 114, 256, 59, 111, 13174, 8277, 49152, 55349, 56624, 512, 97, 99, 111, 121, 13186, 13190, 13201, 13216, 114, 112, 59, 26223, 256, 104, 121, 13195, 13199, 99, 121, 59, 17481, 59, 17480, 114, 116, 621, 13209, 0, 0, 13212, 105, 228, 5220, 97, 114, 97, 236, 11887, 32827, 173, 16557, 256, 103, 109, 13224, 13236, 109, 97, 384, 59, 102, 118, 13233, 13234, 13234, 17347, 59, 17346, 1024, 59, 100, 101, 103, 108, 110, 112, 114, 4779, 13253, 13257, 13262, 13270, 13278, 13281, 13286, 111, 116, 59, 27242, 256, 59, 113, 4785, 4784, 256, 59, 69, 13267, 13268, 27294, 59, 27296, 256, 59, 69, 13275, 13276, 27293, 59, 27295, 101, 59, 25158, 108, 117, 115, 59, 27172, 97, 114, 114, 59, 26994, 97, 114, 242, 4413, 512, 97, 101, 105, 116, 13304, 13320, 13327, 13335, 256, 108, 115, 13309, 13316, 108, 115, 101, 116, 109, 233, 13162, 104, 112, 59, 27187, 112, 97, 114, 115, 108, 59, 27108, 256, 100, 108, 5219, 13332, 101, 59, 25379, 256, 59, 101, 13340, 13341, 27306, 256, 59, 115, 13346, 13347, 27308, 59, 49152, 10924, 65024, 384, 102, 108, 112, 13358, 13363, 13378, 116, 99, 121, 59, 17484, 256, 59, 98, 13368, 13369, 16431, 256, 59, 97, 13374, 13375, 27076, 114, 59, 25407, 102, 59, 49152, 55349, 56676, 97, 256, 100, 114, 13389, 1026, 101, 115, 256, 59, 117, 13396, 13397, 26208, 105, 116, 187, 13397, 384, 99, 115, 117, 13408, 13433, 13471, 256, 97, 117, 13413, 13423, 112, 256, 59, 115, 4488, 13419, 59, 49152, 8851, 65024, 112, 256, 59, 115, 4532, 13429, 59, 49152, 8852, 65024, 117, 256, 98, 112, 13439, 13455, 384, 59, 101, 115, 4503, 4508, 13446, 101, 116, 256, 59, 101, 4503, 13453, 241, 4509, 384, 59, 101, 115, 4520, 4525, 13462, 101, 116, 256, 59, 101, 4520, 13469, 241, 4526, 384, 59, 97, 102, 4475, 13478, 1456, 114, 357, 13483, 1457, 187, 4476, 97, 114, 242, 4424, 512, 99, 101, 109, 116, 13497, 13502, 13506, 13509, 114, 59, 49152, 55349, 56520, 116, 109, 238, 241, 105, 236, 13333, 97, 114, 230, 4542, 256, 97, 114, 13518, 13525, 114, 256, 59, 102, 13524, 6079, 26118, 256, 97, 110, 13530, 13549, 105, 103, 104, 116, 256, 101, 112, 13539, 13546, 112, 115, 105, 108, 111, 238, 7904, 104, 233, 11951, 115, 187, 10322, 640, 98, 99, 109, 110, 112, 13563, 13662, 4617, 13707, 13710, 1152, 59, 69, 100, 101, 109, 110, 112, 114, 115, 13582, 13583, 13585, 13589, 13598, 13603, 13612, 13617, 13622, 25218, 59, 27333, 111, 116, 59, 27325, 256, 59, 100, 4570, 13594, 111, 116, 59, 27331, 117, 108, 116, 59, 27329, 256, 69, 101, 13608, 13610, 59, 27339, 59, 25226, 108, 117, 115, 59, 27327, 97, 114, 114, 59, 27001, 384, 101, 105, 117, 13629, 13650, 13653, 116, 384, 59, 101, 110, 13582, 13637, 13643, 113, 256, 59, 113, 4570, 13583, 101, 113, 256, 59, 113, 13611, 13608, 109, 59, 27335, 256, 98, 112, 13658, 13660, 59, 27349, 59, 27347, 99, 768, 59, 97, 99, 101, 110, 115, 4589, 13676, 13682, 13689, 13691, 13094, 112, 112, 114, 111, 248, 13050, 117, 114, 108, 121, 101, 241, 4606, 241, 4595, 384, 97, 101, 115, 13698, 13704, 13083, 112, 112, 114, 111, 248, 13082, 113, 241, 13079, 103, 59, 26218, 1664, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 13737, 13740, 13743, 4636, 13746, 13748, 13760, 13769, 13781, 13786, 13791, 13800, 13805, 32827, 185, 16569, 32827, 178, 16562, 32827, 179, 16563, 59, 27334, 256, 111, 115, 13753, 13756, 116, 59, 27326, 117, 98, 59, 27352, 256, 59, 100, 4642, 13765, 111, 116, 59, 27332, 115, 256, 111, 117, 13775, 13778, 108, 59, 26569, 98, 59, 27351, 97, 114, 114, 59, 27003, 117, 108, 116, 59, 27330, 256, 69, 101, 13796, 13798, 59, 27340, 59, 25227, 108, 117, 115, 59, 27328, 384, 101, 105, 117, 13812, 13833, 13836, 116, 384, 59, 101, 110, 4636, 13820, 13826, 113, 256, 59, 113, 4642, 13746, 101, 113, 256, 59, 113, 13799, 13796, 109, 59, 27336, 256, 98, 112, 13841, 13843, 59, 27348, 59, 27350, 384, 65, 97, 110, 13852, 13856, 13869, 114, 114, 59, 25049, 114, 256, 104, 114, 13862, 13864, 235, 8750, 256, 59, 111, 2603, 2601, 119, 97, 114, 59, 26922, 108, 105, 103, 32827, 223, 16607, 3041, 13905, 13917, 13920, 4814, 13939, 13945, 0, 13950, 14018, 0, 0, 0, 0, 0, 14043, 14083, 0, 14089, 14188, 0, 0, 0, 14215, 626, 13910, 0, 0, 13915, 103, 101, 116, 59, 25366, 59, 17348, 114, 235, 3679, 384, 97, 101, 121, 13926, 13931, 13936, 114, 111, 110, 59, 16741, 100, 105, 108, 59, 16739, 59, 17474, 108, 114, 101, 99, 59, 25365, 114, 59, 49152, 55349, 56625, 512, 101, 105, 107, 111, 13958, 13981, 14005, 14012, 498, 13963, 0, 13969, 101, 256, 52, 102, 4740, 4737, 97, 384, 59, 115, 118, 13976, 13977, 13979, 17336, 121, 109, 59, 17361, 256, 99, 110, 13986, 14002, 107, 256, 97, 115, 13992, 13998, 112, 112, 114, 111, 248, 4801, 105, 109, 187, 4780, 115, 240, 4766, 256, 97, 115, 14010, 13998, 240, 4801, 114, 110, 32827, 254, 16638, 492, 799, 14022, 8935, 101, 115, 33152, 215, 59, 98, 100, 14031, 14032, 14040, 16599, 256, 59, 97, 6415, 14037, 114, 59, 27185, 59, 27184, 384, 101, 112, 115, 14049, 14051, 14080, 225, 10829, 512, 59, 98, 99, 102, 1158, 14060, 14064, 14068, 111, 116, 59, 25398, 105, 114, 59, 27377, 256, 59, 111, 14073, 14076, 49152, 55349, 56677, 114, 107, 59, 27354, 225, 13154, 114, 105, 109, 101, 59, 24628, 384, 97, 105, 112, 14095, 14098, 14180, 100, 229, 4680, 896, 97, 100, 101, 109, 112, 115, 116, 14113, 14157, 14144, 14161, 14167, 14172, 14175, 110, 103, 108, 101, 640, 59, 100, 108, 113, 114, 14128, 14129, 14134, 14144, 14146, 26037, 111, 119, 110, 187, 7611, 101, 102, 116, 256, 59, 101, 10240, 14142, 241, 2350, 59, 25180, 105, 103, 104, 116, 256, 59, 101, 12970, 14155, 241, 4186, 111, 116, 59, 26092, 105, 110, 117, 115, 59, 27194, 108, 117, 115, 59, 27193, 98, 59, 27085, 105, 109, 101, 59, 27195, 101, 122, 105, 117, 109, 59, 25570, 384, 99, 104, 116, 14194, 14205, 14209, 256, 114, 121, 14199, 14203, 59, 49152, 55349, 56521, 59, 17478, 99, 121, 59, 17499, 114, 111, 107, 59, 16743, 256, 105, 111, 14219, 14222, 120, 244, 6007, 104, 101, 97, 100, 256, 108, 114, 14231, 14240, 101, 102, 116, 97, 114, 114, 111, 247, 2127, 105, 103, 104, 116, 97, 114, 114, 111, 119, 187, 3933, 2304, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 14288, 14291, 14295, 14308, 14320, 14332, 14350, 14364, 14371, 14388, 14417, 14429, 14443, 14505, 14540, 14546, 14570, 14582, 114, 242, 1005, 97, 114, 59, 26979, 256, 99, 114, 14300, 14306, 117, 116, 101, 32827, 250, 16634, 242, 4432, 114, 483, 14314, 0, 14317, 121, 59, 17502, 118, 101, 59, 16749, 256, 105, 121, 14325, 14330, 114, 99, 32827, 251, 16635, 59, 17475, 384, 97, 98, 104, 14339, 14342, 14347, 114, 242, 5037, 108, 97, 99, 59, 16753, 97, 242, 5059, 256, 105, 114, 14355, 14360, 115, 104, 116, 59, 27006, 59, 49152, 55349, 56626, 114, 97, 118, 101, 32827, 249, 16633, 353, 14375, 14385, 114, 256, 108, 114, 14380, 14382, 187, 2391, 187, 4227, 108, 107, 59, 25984, 256, 99, 116, 14393, 14413, 623, 14399, 0, 0, 14410, 114, 110, 256, 59, 101, 14405, 14406, 25372, 114, 187, 14406, 111, 112, 59, 25359, 114, 105, 59, 26104, 256, 97, 108, 14422, 14426, 99, 114, 59, 16747, 32955, 168, 841, 256, 103, 112, 14434, 14438, 111, 110, 59, 16755, 102, 59, 49152, 55349, 56678, 768, 97, 100, 104, 108, 115, 117, 4427, 14456, 14461, 4978, 14481, 14496, 111, 119, 110, 225, 5043, 97, 114, 112, 111, 111, 110, 256, 108, 114, 14472, 14476, 101, 102, 244, 14381, 105, 103, 104, 244, 14383, 105, 384, 59, 104, 108, 14489, 14490, 14492, 17349, 187, 5114, 111, 110, 187, 14490, 112, 97, 114, 114, 111, 119, 115, 59, 25032, 384, 99, 105, 116, 14512, 14532, 14536, 623, 14518, 0, 0, 14529, 114, 110, 256, 59, 101, 14524, 14525, 25373, 114, 187, 14525, 111, 112, 59, 25358, 110, 103, 59, 16751, 114, 105, 59, 26105, 99, 114, 59, 49152, 55349, 56522, 384, 100, 105, 114, 14553, 14557, 14562, 111, 116, 59, 25328, 108, 100, 101, 59, 16745, 105, 256, 59, 102, 14128, 14568, 187, 6163, 256, 97, 109, 14575, 14578, 114, 242, 14504, 108, 32827, 252, 16636, 97, 110, 103, 108, 101, 59, 27047, 1920, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 14620, 14623, 14633, 14637, 14773, 14776, 14781, 14815, 14820, 14824, 14835, 14841, 14845, 14849, 14880, 114, 242, 1015, 97, 114, 256, 59, 118, 14630, 14631, 27368, 59, 27369, 97, 115, 232, 993, 256, 110, 114, 14642, 14647, 103, 114, 116, 59, 27036, 896, 101, 107, 110, 112, 114, 115, 116, 13539, 14662, 14667, 14674, 14685, 14692, 14742, 97, 112, 112, 225, 9237, 111, 116, 104, 105, 110, 231, 7830, 384, 104, 105, 114, 13547, 11976, 14681, 111, 112, 244, 12213, 256, 59, 104, 5047, 14690, 239, 12685, 256, 105, 117, 14697, 14701, 103, 109, 225, 13235, 256, 98, 112, 14706, 14724, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14717, 14720, 49152, 8842, 65024, 59, 49152, 10955, 65024, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14735, 14738, 49152, 8843, 65024, 59, 49152, 10956, 65024, 256, 104, 114, 14747, 14751, 101, 116, 225, 13980, 105, 97, 110, 103, 108, 101, 256, 108, 114, 14762, 14767, 101, 102, 116, 187, 2341, 105, 103, 104, 116, 187, 4177, 121, 59, 17458, 97, 115, 104, 187, 4150, 384, 101, 108, 114, 14788, 14802, 14807, 384, 59, 98, 101, 11754, 14795, 14799, 97, 114, 59, 25275, 113, 59, 25178, 108, 105, 112, 59, 25326, 256, 98, 116, 14812, 5224, 97, 242, 5225, 114, 59, 49152, 55349, 56627, 116, 114, 233, 14766, 115, 117, 256, 98, 112, 14831, 14833, 187, 3356, 187, 3417, 112, 102, 59, 49152, 55349, 56679, 114, 111, 240, 3835, 116, 114, 233, 14772, 256, 99, 117, 14854, 14859, 114, 59, 49152, 55349, 56523, 256, 98, 112, 14864, 14872, 110, 256, 69, 101, 14720, 14870, 187, 14718, 110, 256, 69, 101, 14738, 14878, 187, 14736, 105, 103, 122, 97, 103, 59, 27034, 896, 99, 101, 102, 111, 112, 114, 115, 14902, 14907, 14934, 14939, 14932, 14945, 14954, 105, 114, 99, 59, 16757, 256, 100, 105, 14912, 14929, 256, 98, 103, 14917, 14921, 97, 114, 59, 27231, 101, 256, 59, 113, 5626, 14927, 59, 25177, 101, 114, 112, 59, 24856, 114, 59, 49152, 55349, 56628, 112, 102, 59, 49152, 55349, 56680, 256, 59, 101, 5241, 14950, 97, 116, 232, 5241, 99, 114, 59, 49152, 55349, 56524, 2787, 6030, 14983, 0, 14987, 0, 14992, 15003, 0, 0, 15005, 15016, 15019, 15023, 0, 0, 15043, 15054, 0, 15064, 6108, 6111, 116, 114, 233, 6097, 114, 59, 49152, 55349, 56629, 256, 65, 97, 14996, 14999, 114, 242, 963, 114, 242, 2550, 59, 17342, 256, 65, 97, 15009, 15012, 114, 242, 952, 114, 242, 2539, 97, 240, 10003, 105, 115, 59, 25339, 384, 100, 112, 116, 6052, 15029, 15038, 256, 102, 108, 15034, 6057, 59, 49152, 55349, 56681, 105, 109, 229, 6066, 256, 65, 97, 15047, 15050, 114, 242, 974, 114, 242, 2561, 256, 99, 113, 15058, 6072, 114, 59, 49152, 55349, 56525, 256, 112, 116, 6102, 15068, 114, 233, 6100, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 15088, 15101, 15112, 15116, 15121, 15125, 15131, 15137, 99, 256, 117, 121, 15094, 15099, 116, 101, 32827, 253, 16637, 59, 17487, 256, 105, 121, 15106, 15110, 114, 99, 59, 16759, 59, 17483, 110, 32827, 165, 16549, 114, 59, 49152, 55349, 56630, 99, 121, 59, 17495, 112, 102, 59, 49152, 55349, 56682, 99, 114, 59, 49152, 55349, 56526, 256, 99, 109, 15142, 15145, 121, 59, 17486, 108, 32827, 255, 16639, 1280, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 15170, 15176, 15188, 15192, 15204, 15209, 15213, 15220, 15226, 15232, 99, 117, 116, 101, 59, 16762, 256, 97, 121, 15181, 15186, 114, 111, 110, 59, 16766, 59, 17463, 111, 116, 59, 16764, 256, 101, 116, 15197, 15201, 116, 114, 230, 5471, 97, 59, 17334, 114, 59, 49152, 55349, 56631, 99, 121, 59, 17462, 103, 114, 97, 114, 114, 59, 25053, 112, 102, 59, 49152, 55349, 56683, 99, 114, 59, 49152, 55349, 56527, 256, 106, 110, 15237, 15239, 59, 24589, 106, 59, 24588]);

  // ../node_modules/entities/lib/esm/generated/decode-data-xml.js
  init_inject();
  var decode_data_xml_default = new Uint16Array([512, 97, 103, 108, 113, 9, 21, 24, 27, 621, 15, 0, 0, 18, 112, 59, 16422, 111, 115, 59, 16423, 116, 59, 16446, 116, 59, 16444, 117, 111, 116, 59, 16418]);

  // ../node_modules/entities/lib/esm/decode_codepoint.js
  init_inject();
  var _a;
  var decodeMap = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
  var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  function decodeCodePoint(codePoint) {
    return fromCodePoint(replaceCodePoint(codePoint));
  }

  // ../node_modules/entities/lib/esm/decode.js
  var CharCodes;
  (function(CharCodes3) {
    CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
    CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
    CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
    CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
    CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
    CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
    CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
    CharCodes3[CharCodes3["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
  })(CharCodes || (CharCodes = {}));
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function getDecoder(decodeTree) {
    return function decodeHTMLBinary(str, strict) {
      let ret = "";
      let lastIdx = 0;
      let strIdx = 0;
      while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
        ret += str.slice(lastIdx, strIdx);
        lastIdx = strIdx;
        strIdx += 1;
        if (str.charCodeAt(strIdx) === CharCodes.NUM) {
          let start = strIdx + 1;
          let base = 10;
          let cp = str.charCodeAt(start);
          if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
            base = 16;
            strIdx += 1;
            start += 1;
          }
          do
            cp = str.charCodeAt(++strIdx);
          while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);
          if (start !== strIdx) {
            const entity = str.substring(start, strIdx);
            const parsed = parseInt(entity, base);
            if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
              strIdx += 1;
            } else if (strict) {
              continue;
            }
            ret += decodeCodePoint(parsed);
            lastIdx = strIdx;
          }
          continue;
        }
        let resultIdx = 0;
        let excess = 1;
        let treeIdx = 0;
        let current = decodeTree[treeIdx];
        for (; strIdx < str.length; strIdx++, excess++) {
          treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
          if (treeIdx < 0)
            break;
          current = decodeTree[treeIdx];
          const masked = current & BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
              resultIdx = treeIdx;
              excess = 0;
            }
            const valueLength = (masked >> 14) - 1;
            if (valueLength === 0)
              break;
            treeIdx += valueLength;
          }
        }
        if (resultIdx !== 0) {
          const valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
          ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
          lastIdx = strIdx - excess + 1;
        }
      }
      return ret + str.slice(lastIdx);
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  var htmlDecoder = getDecoder(decode_data_html_default);
  var xmlDecoder = getDecoder(decode_data_xml_default);

  // ../node_modules/htmlparser2/lib/esm/Tokenizer.js
  var CharCodes2;
  (function(CharCodes3) {
    CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
    CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
    CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
    CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes3[CharCodes3["Space"] = 32] = "Space";
    CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes3[CharCodes3["Num"] = 35] = "Num";
    CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
    CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
    CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
    CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
    CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
    CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
    CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
    CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
    CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
    CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
    CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
    CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
    CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
    CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
    CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
    CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
    CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
    CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
    CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes2 || (CharCodes2 = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  function isWhitespace(c) {
    return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
  }
  function isEndOfTagSection(c) {
    return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
  }
  function isNumber(c) {
    return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
  }
  function isASCIIAlpha(c) {
    return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
  }
  function isHexDigit(c) {
    return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
  var Tokenizer = class {
    constructor({
      xmlMode = false,
      decodeEntities = true
    }, cbs) {
      this.cbs = cbs;
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.isSpecial = false;
      this.running = true;
      this.offset = 0;
      this.sequenceIndex = 0;
      this.trieIndex = 0;
      this.trieCurrent = 0;
      this.entityResult = 0;
      this.entityExcess = 0;
      this.xmlMode = xmlMode;
      this.decodeEntities = decodeEntities;
      this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
    }
    reset() {
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.currentSequence = void 0;
      this.running = true;
      this.offset = 0;
    }
    write(chunk) {
      this.offset += this.buffer.length;
      this.buffer = chunk;
      this.parse();
    }
    end() {
      if (this.running)
        this.finish();
    }
    pause() {
      this.running = false;
    }
    resume() {
      this.running = true;
      if (this.index < this.buffer.length + this.offset) {
        this.parse();
      }
    }
    getIndex() {
      return this.index;
    }
    getSectionStart() {
      return this.sectionStart;
    }
    stateText(c) {
      if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = State.BeforeTagName;
        this.sectionStart = this.index;
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.state = State.BeforeEntity;
      }
    }
    stateSpecialStartSequence(c) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
      if (!isMatch) {
        this.isSpecial = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
    stateInSpecialTag(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === CharCodes2.Gt || isWhitespace(c)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.isSpecial = false;
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd) {
          if (this.decodeEntities && c === CharCodes2.Amp) {
            this.state = State.BeforeEntity;
          }
        } else if (this.fastForwardTo(CharCodes2.Lt)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === CharCodes2.Lt);
      }
    }
    stateCDATASequence(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = State.InDeclaration;
        this.stateInDeclaration(c);
      }
    }
    fastForwardTo(c) {
      while (++this.index < this.buffer.length + this.offset) {
        if (this.buffer.charCodeAt(this.index - this.offset) === c) {
          return true;
        }
      }
      this.index = this.buffer.length + this.offset - 1;
      return false;
    }
    stateInCommentLike(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index, 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index, 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = State.Text;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    isTagStartChar(c) {
      return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    }
    startSpecial(sequence, offset) {
      this.isSpecial = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
      this.state = State.SpecialStartSequence;
    }
    stateBeforeTagName(c) {
      if (c === CharCodes2.ExclamationMark) {
        this.state = State.BeforeDeclaration;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.Questionmark) {
        this.state = State.InProcessingInstruction;
        this.sectionStart = this.index + 1;
      } else if (this.isTagStartChar(c)) {
        const lower = c | 32;
        this.sectionStart = this.index;
        if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
          this.startSpecial(Sequences.TitleEnd, 3);
        } else {
          this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
        }
      } else if (c === CharCodes2.Slash) {
        this.state = State.BeforeClosingTagName;
      } else {
        this.state = State.Text;
        this.stateText(c);
      }
    }
    stateInTagName(c) {
      if (isEndOfTagSection(c)) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateBeforeClosingTagName(c) {
      if (isWhitespace(c)) {
      } else if (c === CharCodes2.Gt) {
        this.state = State.Text;
      } else {
        this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterClosingTagName;
        this.stateAfterClosingTagName(c);
      }
    }
    stateAfterClosingTagName(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttributeName(c) {
      if (c === CharCodes2.Gt) {
        this.cbs.onopentagend(this.index);
        if (this.isSpecial) {
          this.state = State.InSpecialTag;
          this.sequenceIndex = 0;
        } else {
          this.state = State.Text;
        }
        this.baseState = this.state;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.Slash) {
        this.state = State.InSelfClosingTag;
      } else if (!isWhitespace(c)) {
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c) {
      if (c === CharCodes2.Gt) {
        this.cbs.onselfclosingtag(this.index);
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
        this.isSpecial = false;
      } else if (!isWhitespace(c)) {
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateInAttributeName(c) {
      if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterAttributeName;
        this.stateAfterAttributeName(c);
      }
    }
    stateAfterAttributeName(c) {
      if (c === CharCodes2.Eq) {
        this.state = State.BeforeAttributeValue;
      } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (!isWhitespace(c)) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateBeforeAttributeValue(c) {
      if (c === CharCodes2.DoubleQuote) {
        this.state = State.InAttributeValueDq;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.SingleQuote) {
        this.state = State.InAttributeValueSq;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c)) {
        this.sectionStart = this.index;
        this.state = State.InAttributeValueNq;
        this.stateInAttributeValueNoQuotes(c);
      }
    }
    handleInAttributeValue(c, quote) {
      if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
        this.state = State.BeforeAttributeName;
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    }
    stateInAttributeValueDoubleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
    }
    stateInAttributeValueSingleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes2.SingleQuote);
    }
    stateInAttributeValueNoQuotes(c) {
      if (isWhitespace(c) || c === CharCodes2.Gt) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(QuoteType.Unquoted, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    }
    stateBeforeDeclaration(c) {
      if (c === CharCodes2.OpeningSquareBracket) {
        this.state = State.CDATASequence;
        this.sequenceIndex = 0;
      } else {
        this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
      }
    }
    stateInDeclaration(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.ondeclaration(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c) {
      if (c === CharCodes2.Dash) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = State.InDeclaration;
      }
    }
    stateInSpecialComment(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.oncomment(this.sectionStart, this.index, 0);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c) {
      const lower = c | 32;
      if (lower === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (lower === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c);
      }
    }
    stateBeforeEntity(c) {
      this.entityExcess = 1;
      this.entityResult = 0;
      if (c === CharCodes2.Num) {
        this.state = State.BeforeNumericEntity;
      } else if (c === CharCodes2.Amp) {
      } else {
        this.trieIndex = 0;
        this.trieCurrent = this.entityTrie[0];
        this.state = State.InNamedEntity;
        this.stateInNamedEntity(c);
      }
    }
    stateInNamedEntity(c) {
      this.entityExcess += 1;
      this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
      if (this.trieIndex < 0) {
        this.emitNamedEntity();
        this.index--;
        return;
      }
      this.trieCurrent = this.entityTrie[this.trieIndex];
      const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
          this.trieIndex += valueLength;
        } else {
          const entityStart = this.index - this.entityExcess + 1;
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.entityResult = this.trieIndex;
          this.trieIndex += valueLength;
          this.entityExcess = 0;
          this.sectionStart = this.index + 1;
          if (valueLength === 0) {
            this.emitNamedEntity();
          }
        }
      }
    }
    emitNamedEntity() {
      this.state = this.baseState;
      if (this.entityResult === 0) {
        return;
      }
      const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
      switch (valueLength) {
        case 1:
          this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
          break;
        case 2:
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          break;
        case 3: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
        }
      }
    }
    stateBeforeNumericEntity(c) {
      if ((c | 32) === CharCodes2.LowerX) {
        this.entityExcess++;
        this.state = State.InHexEntity;
      } else {
        this.state = State.InNumericEntity;
        this.stateInNumericEntity(c);
      }
    }
    emitNumericEntity(strict) {
      const entityStart = this.index - this.entityExcess - 1;
      const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
      if (numberStart !== this.index) {
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.sectionStart = this.index + Number(strict);
        this.emitCodePoint(replaceCodePoint(this.entityResult));
      }
      this.state = this.baseState;
    }
    stateInNumericEntity(c) {
      if (c === CharCodes2.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    }
    stateInHexEntity(c) {
      if (c === CharCodes2.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
        this.entityExcess++;
      } else if (isHexDigit(c)) {
        this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    }
    allowLegacyEntity() {
      return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    }
    cleanup() {
      if (this.running && this.sectionStart !== this.index) {
        if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    shouldContinue() {
      return this.index < this.buffer.length + this.offset && this.running;
    }
    parse() {
      while (this.shouldContinue()) {
        const c = this.buffer.charCodeAt(this.index - this.offset);
        if (this.state === State.Text) {
          this.stateText(c);
        } else if (this.state === State.SpecialStartSequence) {
          this.stateSpecialStartSequence(c);
        } else if (this.state === State.InSpecialTag) {
          this.stateInSpecialTag(c);
        } else if (this.state === State.CDATASequence) {
          this.stateCDATASequence(c);
        } else if (this.state === State.InAttributeValueDq) {
          this.stateInAttributeValueDoubleQuotes(c);
        } else if (this.state === State.InAttributeName) {
          this.stateInAttributeName(c);
        } else if (this.state === State.InCommentLike) {
          this.stateInCommentLike(c);
        } else if (this.state === State.InSpecialComment) {
          this.stateInSpecialComment(c);
        } else if (this.state === State.BeforeAttributeName) {
          this.stateBeforeAttributeName(c);
        } else if (this.state === State.InTagName) {
          this.stateInTagName(c);
        } else if (this.state === State.InClosingTagName) {
          this.stateInClosingTagName(c);
        } else if (this.state === State.BeforeTagName) {
          this.stateBeforeTagName(c);
        } else if (this.state === State.AfterAttributeName) {
          this.stateAfterAttributeName(c);
        } else if (this.state === State.InAttributeValueSq) {
          this.stateInAttributeValueSingleQuotes(c);
        } else if (this.state === State.BeforeAttributeValue) {
          this.stateBeforeAttributeValue(c);
        } else if (this.state === State.BeforeClosingTagName) {
          this.stateBeforeClosingTagName(c);
        } else if (this.state === State.AfterClosingTagName) {
          this.stateAfterClosingTagName(c);
        } else if (this.state === State.BeforeSpecialS) {
          this.stateBeforeSpecialS(c);
        } else if (this.state === State.InAttributeValueNq) {
          this.stateInAttributeValueNoQuotes(c);
        } else if (this.state === State.InSelfClosingTag) {
          this.stateInSelfClosingTag(c);
        } else if (this.state === State.InDeclaration) {
          this.stateInDeclaration(c);
        } else if (this.state === State.BeforeDeclaration) {
          this.stateBeforeDeclaration(c);
        } else if (this.state === State.BeforeComment) {
          this.stateBeforeComment(c);
        } else if (this.state === State.InProcessingInstruction) {
          this.stateInProcessingInstruction(c);
        } else if (this.state === State.InNamedEntity) {
          this.stateInNamedEntity(c);
        } else if (this.state === State.BeforeEntity) {
          this.stateBeforeEntity(c);
        } else if (this.state === State.InHexEntity) {
          this.stateInHexEntity(c);
        } else if (this.state === State.InNumericEntity) {
          this.stateInNumericEntity(c);
        } else {
          this.stateBeforeNumericEntity(c);
        }
        this.index++;
      }
      this.cleanup();
    }
    finish() {
      if (this.state === State.InNamedEntity) {
        this.emitNamedEntity();
      }
      if (this.sectionStart < this.index) {
        this.handleTrailingData();
      }
      this.cbs.onend();
    }
    handleTrailingData() {
      const endIndex = this.buffer.length + this.offset;
      if (this.state === State.InCommentLike) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex, 0);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex, 0);
        }
      } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
      } else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitPartial(start, endIndex) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribdata(start, endIndex);
      } else {
        this.cbs.ontext(start, endIndex);
      }
    }
    emitCodePoint(cp) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribentity(cp);
      } else {
        this.cbs.ontextentity(cp);
      }
    }
  };

  // ../node_modules/htmlparser2/lib/esm/Parser.js
  var formTags = /* @__PURE__ */ new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
  var pTag = /* @__PURE__ */ new Set(["p"]);
  var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
  var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
  var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
  var openImpliesClose = /* @__PURE__ */ new Map([["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])], ["th", /* @__PURE__ */ new Set(["th"])], ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])], ["body", /* @__PURE__ */ new Set(["head", "link", "script"])], ["li", /* @__PURE__ */ new Set(["li"])], ["p", pTag], ["h1", pTag], ["h2", pTag], ["h3", pTag], ["h4", pTag], ["h5", pTag], ["h6", pTag], ["select", formTags], ["input", formTags], ["output", formTags], ["button", formTags], ["datalist", formTags], ["textarea", formTags], ["option", /* @__PURE__ */ new Set(["option"])], ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])], ["dd", ddtTags], ["dt", ddtTags], ["address", pTag], ["article", pTag], ["aside", pTag], ["blockquote", pTag], ["details", pTag], ["div", pTag], ["dl", pTag], ["fieldset", pTag], ["figcaption", pTag], ["figure", pTag], ["footer", pTag], ["form", pTag], ["header", pTag], ["hr", pTag], ["main", pTag], ["nav", pTag], ["ol", pTag], ["pre", pTag], ["section", pTag], ["table", pTag], ["ul", pTag], ["rt", rtpTags], ["rp", rtpTags], ["tbody", tableSectionTags], ["tfoot", tableSectionTags]]);
  var voidElements = /* @__PURE__ */ new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
  var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
  var htmlIntegrationElements = /* @__PURE__ */ new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignobject", "desc", "title"]);
  var reNameEnd = /\s|\//;
  var Parser = class {
    constructor(cbs, options = {}) {
      var _a2, _b, _c, _d, _e;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
      this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    ontext(start, endIndex) {
      var _a2, _b;
      const data = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
      this.startIndex = endIndex;
    }
    ontextentity(cp) {
      var _a2, _b;
      const idx = this.tokenizer.getSectionStart();
      this.endIndex = idx - 1;
      (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
      this.startIndex = idx;
    }
    isVoidElement(name) {
      return !this.options.xmlMode && voidElements.has(name);
    }
    onopentagname(start, endIndex) {
      this.endIndex = endIndex;
      let name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      this.emitOpenTag(name);
    }
    emitOpenTag(name) {
      var _a2, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name;
      const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          const el = this.stack.pop();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, el, true);
        }
      }
      if (!this.isVoidElement(name)) {
        this.stack.push(name);
        if (foreignContextElements.has(name)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
      if (this.cbs.onopentag)
        this.attribs = {};
    }
    endOpenTag(isImplied) {
      var _a2, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    }
    onopentagend(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    }
    onclosetag(start, endIndex) {
      var _a2, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      let name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name)) {
        const pos = this.stack.lastIndexOf(name);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            let count = this.stack.length - pos;
            while (count--) {
              this.cbs.onclosetag(this.stack.pop(), count !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name === "br") {
        (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    }
    onselfclosingtag(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    }
    closeCurrentTag(isOpenImplied) {
      var _a2, _b;
      const name = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name) {
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
        this.stack.pop();
      }
    }
    onattribname(start, endIndex) {
      this.startIndex = start;
      const name = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    }
    onattribdata(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    }
    onattribentity(cp) {
      this.attribvalue += fromCodePoint(cp);
    }
    onattribend(quote, endIndex) {
      var _a2, _b;
      this.endIndex = endIndex;
      (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    }
    getInstructionName(value) {
      const idx = value.search(reNameEnd);
      let name = idx < 0 ? value : value.substr(0, idx);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      return name;
    }
    ondeclaration(start, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    onprocessinginstruction(start, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    oncomment(start, endIndex, offset) {
      var _a2, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    }
    oncdata(start, endIndex, offset) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    }
    onend() {
      var _a2, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (let i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
          ;
      }
      (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
    }
    reset() {
      var _a2, _b, _c, _d;
      (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    }
    parseComplete(data) {
      this.reset();
      this.end(data);
    }
    getSlice(start, end) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      let str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
      while (end - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        str += this.buffers[0].slice(0, end - this.bufferOffset);
      }
      return str;
    }
    shiftBuffer() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    }
    write(chunk) {
      var _a2, _b;
      if (this.ended) {
        (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    }
    end(chunk) {
      var _a2, _b;
      if (this.ended) {
        (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    }
    pause() {
      this.tokenizer.pause();
    }
    resume() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    }
    parseChunk(chunk) {
      this.write(chunk);
    }
    done(chunk) {
      this.end(chunk);
    }
  };

  // ../node_modules/domhandler/lib/esm/index.js
  init_inject();

  // ../node_modules/domelementtype/lib/esm/index.js
  init_inject();
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  var Root = ElementType.Root;
  var Text = ElementType.Text;
  var Directive = ElementType.Directive;
  var Comment = ElementType.Comment;
  var Script = ElementType.Script;
  var Style = ElementType.Style;
  var Tag = ElementType.Tag;
  var CDATA = ElementType.CDATA;
  var Doctype = ElementType.Doctype;

  // ../node_modules/domhandler/lib/esm/node.js
  init_inject();

  // ../node_modules/domutils/lib/esm/index.js
  init_inject();

  // ../node_modules/domutils/lib/esm/stringify.js
  init_inject();

  // ../node_modules/dom-serializer/lib/esm/index.js
  init_inject();

  // ../node_modules/entities/lib/esm/index.js
  init_inject();

  // ../node_modules/entities/lib/esm/encode.js
  init_inject();

  // ../node_modules/entities/lib/esm/generated/encode-html.js
  init_inject();

  // ../node_modules/entities/lib/esm/escape.js
  init_inject();
  var xmlCodeMap = /* @__PURE__ */ new Map([[34, "&quot;"], [38, "&amp;"], [39, "&apos;"], [60, "&lt;"], [62, "&gt;"]]);
  var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
  function getEscaper(regex, map) {
    return function escape2(data) {
      let match;
      let lastIdx = 0;
      let result = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  }
  var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]]));
  var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]]));

  // ../node_modules/entities/lib/esm/index.js
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  })(DecodingMode || (DecodingMode = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode || (EncodingMode = {}));

  // ../node_modules/dom-serializer/lib/esm/foreignNames.js
  init_inject();
  var elementNames = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map((val) => [val.toLowerCase(), val]));
  var attributeNames = new Map(["definitionURL", "attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map((val) => [val.toLowerCase(), val]));

  // ../node_modules/domutils/lib/esm/traversal.js
  init_inject();

  // ../node_modules/domutils/lib/esm/manipulation.js
  init_inject();

  // ../node_modules/domutils/lib/esm/querying.js
  init_inject();

  // ../node_modules/domutils/lib/esm/legacy.js
  init_inject();

  // ../node_modules/domutils/lib/esm/helpers.js
  init_inject();
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));

  // ../node_modules/domutils/lib/esm/feeds.js
  init_inject();

  // ../src/core/parseHtml.ts
  var parseHtml = (content, options, collectTo = /* @__PURE__ */ new Map()) => {
    new Parser({
      onattribute: (name, value) => name === "class" && parseClass(value, options, collectTo)
    }).end(content);
    return collectTo;
  };

  // ../src/core/parseScript.ts
  init_inject();
  var import_parser = __toESM(require_lib(), 1);

  // ../src/core/types.ts
  init_inject();

  // ../src/replacements/index.ts
  init_inject();

  // ../src/replacements/default.ts
  init_inject();

  // ../src/replacements/merge.ts
  init_inject();
  var mergeReplacements = (...replacements) => {
    const rs = [].concat(...replacements);
    return {
      media: rs.flatMap((r) => r.media ?? []),
      selector: rs.flatMap((r) => r.selector ?? []),
      property: rs.flatMap((r) => r.property ?? []),
      value: rs.flatMap((r) => r.value ?? [])
    };
  };

  // ../src/replacements/default.ts
  var mediaOperatorReplacements = {
    media: [[/!/g, "not "], [/&/g, " and "], [/\|/g, " or "]]
  };
  var abbreviationReplacements = {
    media: [[/\bh\b/g, "height"], [/\bw\b/g, "width"]],
    property: [[/^b$/, "border"], [/^bg$/, "background"], [/^d$/, "display"], [/^f$/, "font"], [/^m$/, "margin"], [/^p$/, "padding"], [/^z$/, "z-index"], [/^a-content$/, "align-content"], [/^a-items$/, "align-items"], [/^a-self$/, "align-self"], [/^j-content$/, "justify-content"], [/^j-items$/, "justify-items"], [/^j-self$/, "justify-self"], [/^p-content$/, "place-content"], [/^p-items$/, "place-items"], [/^p-self$/, "place-self"], [/^v-align$/, "vertical-align"], [/\bsz\b/, "size"], [/\bpos\b/, "position"], [/\bc$/, "color"], [/\bh$/, "height"], [/\bw$/, "width"], [/^b-/, "border-"], [/^bg-/, "background-"], [/^f-/, "font-"], [/^m-/, "margin-"], [/^p-/, "padding-"], [/^t-/, "text-"], [/-b\b/, "-bottom"], [/-l\b/, "-left"], [/-r\b/, "-right"], [/-t\b/, "-top"]]
  };
  var nthChildReplacements = {
    selector: [[/>(-?\d+(?:n(?:\+\d+)?)?)\b/g, ">:nth-child($1)"]]
  };
  var defaultReplacements = mergeReplacements(mediaOperatorReplacements, abbreviationReplacements, nthChildReplacements);

  // src/sample.html
  var sample_default = '<form onsubmit="arguments[0].preventDefault()">\n  <label class="cursor:pointer user-select:none d:inline-flex a-items:center gap:4px :has(>:checked)/c:rebeccapurple :has(>:checked)/accent-c:rebeccapurple">\n    <input type="checkbox" class="cursor:inherit" />\n    Checkbox\n  </label>\n\n  <button class="--hue:210 cursor:pointer p:4px_8px @w>=768px/p:8px_16px b-radius:8px c:white b:3px_solid_hsl($hue,100%,80%) bg:hsl($hue,100%,50%) :hover/bg:hsl($hue,100%,60%) :active/bg:hsl($hue,100%,40%)* @hover:hover/:hover/scale:1.1">\n    Submit\n  </button>\n</form>\n';

  // src/App.tsx
  var _tmpl$ = /* @__PURE__ */ template(`<header class="p-b:1em f-family:logo d:inline-flex flex-direction:column a-items:center"><h1 class="f-sz:2.5rem f-style:oblique">isaaccss</h1><h2 class="f-sz:1rem c:gray letter-spacing:0.375em">playground</h2></header>`, 6);
  var _tmpl$2 = /* @__PURE__ */ template(`<details class="p:0.5rem box-shadow:0_0_4px_#bbb,_0_2px_8px_#bbb"><summary class="cursor:pointer user-select:none f-weight:bold"></summary><div class="b-w:1px b-c:#ccc"></div></details>`, 6);
  var _tmpl$3 = /* @__PURE__ */ template(`<textarea rows="10"></textarea>`, 2);
  var _tmpl$4 = /* @__PURE__ */ template(`<textarea rows="10" readonly></textarea>`, 2);
  var _tmpl$5 = /* @__PURE__ */ template(`<iframe></iframe>`, 2);
  var _tmpl$6 = /* @__PURE__ */ template(`<main class="d:flex flex-direction:column gap:1rem _textarea/f-family:'Source_Code_Pro',monospace _textarea/f-sz:0.9375rem"></main>`, 2);
  var Header = () => _tmpl$.cloneNode(true);
  var Details = ({
    open,
    summary,
    children: children2
  }) => (() => {
    const _el$2 = _tmpl$2.cloneNode(true), _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;
    _el$2.open = open;
    insert(_el$3, summary);
    insert(_el$4, children2);
    return _el$2;
  })();
  var Main = () => (() => {
    const _el$5 = _tmpl$6.cloneNode(true);
    insert(_el$5, createComponent(Details, {
      summary: "HTML",
      open: true,
      get children() {
        const _el$6 = _tmpl$3.cloneNode(true);
        _el$6.$$input = (e) => setHtmlContent(e.currentTarget.value);
        createRenderEffect(() => _el$6.value = htmlContent());
        return _el$6;
      }
    }), null);
    insert(_el$5, createComponent(Details, {
      summary: "Parsed Classes",
      get children() {
        const _el$7 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$7.value = classesJson());
        return _el$7;
      }
    }), null);
    insert(_el$5, createComponent(Details, {
      summary: "CSS",
      get children() {
        const _el$8 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$8.value = css());
        return _el$8;
      }
    }), null);
    insert(_el$5, createComponent(Details, {
      summary: "Pretty CSS",
      open: true,
      get children() {
        const _el$9 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$9.value = beautifiedCss());
        return _el$9;
      }
    }), null);
    insert(_el$5, createComponent(Details, {
      summary: "Preview",
      open: true,
      get children() {
        const _el$10 = _tmpl$5.cloneNode(true);
        createRenderEffect(() => setAttribute(_el$10, "srcdoc", `<html><head><style>${css()}</style></head><body>${htmlContent()}</body></html>`));
        return _el$10;
      }
    }), null);
    return _el$5;
  })();
  var [htmlContent, setHtmlContent] = createSignal(sample_default);
  var classes = createMemo(() => parseHtml(htmlContent(), {
    replacements: defaultReplacements
  }));
  var classesJson = createMemo(() => JSON.stringify([...classes().values()], void 0, 2));
  var css = createMemo(() => cssify(classes()));
  var beautifiedCss = createMemo(() => cssify(classes(), {
    pretty: true
  }));
  var App = () => [createComponent(Header, {}), createComponent(Main, {})];
  delegateEvents(["input"]);

  // src/playground.tsx
  document.body.className = "p:1rem";
  render(() => createComponent(App, {}), document.body);
})();
