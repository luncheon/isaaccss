"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // virtual:isaaccss:css:virtual:isaaccss.css
  var init_ = __esm({
    "virtual:isaaccss:css:virtual:isaaccss.css"() {
    }
  });

  // ../lib/esbuild/inject.js
  var init_inject = __esm({
    "../lib/esbuild/inject.js"() {
      "use strict";
      init_();
    }
  });

  // ../node_modules/known-css-properties/data/all.json
  var require_all = __commonJS({
    "../node_modules/known-css-properties/data/all.json"(exports, module) {
      module.exports = {
        properties: [
          "-epub-caption-side",
          "-epub-hyphens",
          "-epub-text-combine",
          "-epub-text-emphasis",
          "-epub-text-emphasis-color",
          "-epub-text-emphasis-style",
          "-epub-text-orientation",
          "-epub-text-transform",
          "-epub-word-break",
          "-epub-writing-mode",
          "-internal-text-autosizing-status",
          "accelerator",
          "accent-color",
          "-wap-accesskey",
          "additive-symbols",
          "align-content",
          "-webkit-align-content",
          "align-items",
          "-webkit-align-items",
          "align-self",
          "-webkit-align-self",
          "alignment-baseline",
          "all",
          "alt",
          "-webkit-alt",
          "animation",
          "animation-delay",
          "-moz-animation-delay",
          "-ms-animation-delay",
          "-webkit-animation-delay",
          "animation-direction",
          "-moz-animation-direction",
          "-ms-animation-direction",
          "-webkit-animation-direction",
          "animation-duration",
          "-moz-animation-duration",
          "-ms-animation-duration",
          "-webkit-animation-duration",
          "animation-fill-mode",
          "-moz-animation-fill-mode",
          "-ms-animation-fill-mode",
          "-webkit-animation-fill-mode",
          "animation-iteration-count",
          "-moz-animation-iteration-count",
          "-ms-animation-iteration-count",
          "-webkit-animation-iteration-count",
          "-moz-animation",
          "-ms-animation",
          "animation-name",
          "-moz-animation-name",
          "-ms-animation-name",
          "-webkit-animation-name",
          "animation-play-state",
          "-moz-animation-play-state",
          "-ms-animation-play-state",
          "-webkit-animation-play-state",
          "animation-timing-function",
          "-moz-animation-timing-function",
          "-ms-animation-timing-function",
          "-webkit-animation-timing-function",
          "-webkit-animation-trigger",
          "-webkit-animation",
          "app-region",
          "-webkit-app-region",
          "appearance",
          "-moz-appearance",
          "-webkit-appearance",
          "ascent-override",
          "aspect-ratio",
          "-webkit-aspect-ratio",
          "audio-level",
          "azimuth",
          "backdrop-filter",
          "-webkit-backdrop-filter",
          "backface-visibility",
          "-moz-backface-visibility",
          "-ms-backface-visibility",
          "-webkit-backface-visibility",
          "background",
          "background-attachment",
          "-webkit-background-attachment",
          "background-blend-mode",
          "background-clip",
          "-moz-background-clip",
          "-webkit-background-clip",
          "background-color",
          "-webkit-background-color",
          "-webkit-background-composite",
          "background-image",
          "-webkit-background-image",
          "-moz-background-inline-policy",
          "background-origin",
          "-moz-background-origin",
          "-webkit-background-origin",
          "background-position",
          "-webkit-background-position",
          "background-position-x",
          "-webkit-background-position-x",
          "background-position-y",
          "-webkit-background-position-y",
          "background-repeat",
          "-webkit-background-repeat",
          "background-repeat-x",
          "background-repeat-y",
          "background-size",
          "-moz-background-size",
          "-webkit-background-size",
          "-webkit-background",
          "base-palette",
          "baseline-shift",
          "baseline-source",
          "behavior",
          "-moz-binding",
          "block-ellipsis",
          "-ms-block-progression",
          "block-size",
          "block-step",
          "block-step-align",
          "block-step-insert",
          "block-step-round",
          "block-step-size",
          "bookmark-label",
          "bookmark-level",
          "bookmark-state",
          "border",
          "-webkit-border-after-color",
          "-webkit-border-after-style",
          "-webkit-border-after",
          "-webkit-border-after-width",
          "-webkit-border-before-color",
          "-webkit-border-before-style",
          "-webkit-border-before",
          "-webkit-border-before-width",
          "border-block",
          "border-block-color",
          "border-block-end",
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width",
          "border-block-start",
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width",
          "border-block-style",
          "border-block-width",
          "border-bottom",
          "border-bottom-color",
          "-moz-border-bottom-colors",
          "border-bottom-left-radius",
          "-webkit-border-bottom-left-radius",
          "border-bottom-right-radius",
          "-webkit-border-bottom-right-radius",
          "border-bottom-style",
          "border-bottom-width",
          "border-boundary",
          "border-collapse",
          "border-color",
          "-moz-border-end-color",
          "-webkit-border-end-color",
          "border-end-end-radius",
          "-moz-border-end",
          "border-end-start-radius",
          "-moz-border-end-style",
          "-webkit-border-end-style",
          "-webkit-border-end",
          "-moz-border-end-width",
          "-webkit-border-end-width",
          "-webkit-border-fit",
          "-webkit-border-horizontal-spacing",
          "border-image",
          "-moz-border-image",
          "-o-border-image",
          "border-image-outset",
          "-webkit-border-image-outset",
          "border-image-repeat",
          "-webkit-border-image-repeat",
          "border-image-slice",
          "-webkit-border-image-slice",
          "border-image-source",
          "-webkit-border-image-source",
          "-webkit-border-image",
          "border-image-width",
          "-webkit-border-image-width",
          "border-inline",
          "border-inline-color",
          "border-inline-end",
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width",
          "border-inline-start",
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width",
          "border-inline-style",
          "border-inline-width",
          "border-left",
          "border-left-color",
          "-moz-border-left-colors",
          "border-left-style",
          "border-left-width",
          "border-radius",
          "-moz-border-radius-bottomleft",
          "-moz-border-radius-bottomright",
          "-moz-border-radius",
          "-moz-border-radius-topleft",
          "-moz-border-radius-topright",
          "-webkit-border-radius",
          "border-right",
          "border-right-color",
          "-moz-border-right-colors",
          "border-right-style",
          "border-right-width",
          "border-spacing",
          "-moz-border-start-color",
          "-webkit-border-start-color",
          "border-start-end-radius",
          "-moz-border-start",
          "border-start-start-radius",
          "-moz-border-start-style",
          "-webkit-border-start-style",
          "-webkit-border-start",
          "-moz-border-start-width",
          "-webkit-border-start-width",
          "border-style",
          "border-top",
          "border-top-color",
          "-moz-border-top-colors",
          "border-top-left-radius",
          "-webkit-border-top-left-radius",
          "border-top-right-radius",
          "-webkit-border-top-right-radius",
          "border-top-style",
          "border-top-width",
          "-webkit-border-vertical-spacing",
          "border-width",
          "bottom",
          "-moz-box-align",
          "-webkit-box-align",
          "box-decoration-break",
          "-webkit-box-decoration-break",
          "-moz-box-direction",
          "-webkit-box-direction",
          "-webkit-box-flex-group",
          "-moz-box-flex",
          "-webkit-box-flex",
          "-webkit-box-lines",
          "-moz-box-ordinal-group",
          "-webkit-box-ordinal-group",
          "-moz-box-orient",
          "-webkit-box-orient",
          "-moz-box-pack",
          "-webkit-box-pack",
          "-webkit-box-reflect",
          "box-shadow",
          "-moz-box-shadow",
          "-webkit-box-shadow",
          "box-sizing",
          "-moz-box-sizing",
          "-webkit-box-sizing",
          "box-snap",
          "break-after",
          "break-before",
          "break-inside",
          "buffered-rendering",
          "caption-side",
          "caret",
          "caret-color",
          "caret-shape",
          "chains",
          "clear",
          "clip",
          "clip-path",
          "-webkit-clip-path",
          "clip-rule",
          "color",
          "color-adjust",
          "-webkit-color-correction",
          "-apple-color-filter",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "color-scheme",
          "-webkit-column-axis",
          "-webkit-column-break-after",
          "-webkit-column-break-before",
          "-webkit-column-break-inside",
          "column-count",
          "-moz-column-count",
          "-webkit-column-count",
          "column-fill",
          "-moz-column-fill",
          "-webkit-column-fill",
          "column-gap",
          "-moz-column-gap",
          "-webkit-column-gap",
          "column-progression",
          "-webkit-column-progression",
          "column-rule",
          "column-rule-color",
          "-moz-column-rule-color",
          "-webkit-column-rule-color",
          "-moz-column-rule",
          "column-rule-style",
          "-moz-column-rule-style",
          "-webkit-column-rule-style",
          "-webkit-column-rule",
          "column-rule-width",
          "-moz-column-rule-width",
          "-webkit-column-rule-width",
          "column-span",
          "-moz-column-span",
          "-webkit-column-span",
          "column-width",
          "-moz-column-width",
          "-webkit-column-width",
          "columns",
          "-moz-columns",
          "-webkit-columns",
          "-webkit-composition-fill-color",
          "-webkit-composition-frame-color",
          "contain",
          "contain-intrinsic-block-size",
          "contain-intrinsic-height",
          "contain-intrinsic-inline-size",
          "contain-intrinsic-size",
          "contain-intrinsic-width",
          "container",
          "container-name",
          "container-type",
          "content",
          "content-visibility",
          "-ms-content-zoom-chaining",
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min",
          "-ms-content-zoom-limit",
          "-ms-content-zoom-snap",
          "-ms-content-zoom-snap-points",
          "-ms-content-zoom-snap-type",
          "-ms-content-zooming",
          "continue",
          "counter-increment",
          "counter-reset",
          "counter-set",
          "cue",
          "cue-after",
          "cue-before",
          "cursor",
          "-webkit-cursor-visibility",
          "cx",
          "cy",
          "d",
          "-apple-dashboard-region",
          "-webkit-dashboard-region",
          "descent-override",
          "direction",
          "display",
          "display-align",
          "dominant-baseline",
          "elevation",
          "empty-cells",
          "enable-background",
          "epub-caption-side",
          "epub-hyphens",
          "epub-text-combine",
          "epub-text-emphasis",
          "epub-text-emphasis-color",
          "epub-text-emphasis-style",
          "epub-text-orientation",
          "epub-text-transform",
          "epub-word-break",
          "epub-writing-mode",
          "fallback",
          "fill",
          "fill-break",
          "fill-color",
          "fill-image",
          "fill-opacity",
          "fill-origin",
          "fill-position",
          "fill-repeat",
          "fill-rule",
          "fill-size",
          "filter",
          "-ms-filter",
          "-webkit-filter",
          "flex",
          "-ms-flex-align",
          "-webkit-flex-align",
          "flex-basis",
          "-webkit-flex-basis",
          "flex-direction",
          "-ms-flex-direction",
          "-webkit-flex-direction",
          "flex-flow",
          "-ms-flex-flow",
          "-webkit-flex-flow",
          "flex-grow",
          "-webkit-flex-grow",
          "-ms-flex-item-align",
          "-webkit-flex-item-align",
          "-ms-flex-line-pack",
          "-webkit-flex-line-pack",
          "-ms-flex",
          "-ms-flex-negative",
          "-ms-flex-order",
          "-webkit-flex-order",
          "-ms-flex-pack",
          "-webkit-flex-pack",
          "-ms-flex-positive",
          "-ms-flex-preferred-size",
          "flex-shrink",
          "-webkit-flex-shrink",
          "-webkit-flex",
          "flex-wrap",
          "-ms-flex-wrap",
          "-webkit-flex-wrap",
          "float",
          "float-defer",
          "-moz-float-edge",
          "float-offset",
          "float-reference",
          "flood-color",
          "flood-opacity",
          "flow",
          "flow-from",
          "-ms-flow-from",
          "-webkit-flow-from",
          "flow-into",
          "-ms-flow-into",
          "-webkit-flow-into",
          "font",
          "font-display",
          "font-family",
          "font-feature-settings",
          "-moz-font-feature-settings",
          "-ms-font-feature-settings",
          "-webkit-font-feature-settings",
          "font-kerning",
          "-webkit-font-kerning",
          "font-language-override",
          "-moz-font-language-override",
          "font-optical-sizing",
          "font-palette",
          "font-size",
          "font-size-adjust",
          "-webkit-font-size-delta",
          "-webkit-font-smoothing",
          "font-stretch",
          "font-style",
          "font-synthesis",
          "font-synthesis-small-caps",
          "font-synthesis-style",
          "font-synthesis-weight",
          "font-variant",
          "font-variant-alternates",
          "font-variant-caps",
          "font-variant-east-asian",
          "font-variant-emoji",
          "font-variant-ligatures",
          "-webkit-font-variant-ligatures",
          "font-variant-numeric",
          "font-variant-position",
          "font-variation-settings",
          "font-weight",
          "footnote-display",
          "footnote-policy",
          "-moz-force-broken-image-icon",
          "forced-color-adjust",
          "gap",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "grid",
          "-webkit-grid-after",
          "grid-area",
          "grid-auto-columns",
          "-webkit-grid-auto-columns",
          "grid-auto-flow",
          "-webkit-grid-auto-flow",
          "grid-auto-rows",
          "-webkit-grid-auto-rows",
          "-webkit-grid-before",
          "grid-column",
          "-ms-grid-column-align",
          "grid-column-end",
          "grid-column-gap",
          "-ms-grid-column",
          "-ms-grid-column-span",
          "grid-column-start",
          "-webkit-grid-column",
          "-ms-grid-columns",
          "-webkit-grid-columns",
          "-webkit-grid-end",
          "grid-gap",
          "grid-row",
          "-ms-grid-row-align",
          "grid-row-end",
          "grid-row-gap",
          "-ms-grid-row",
          "-ms-grid-row-span",
          "grid-row-start",
          "-webkit-grid-row",
          "-ms-grid-rows",
          "-webkit-grid-rows",
          "-webkit-grid-start",
          "grid-template",
          "grid-template-areas",
          "grid-template-columns",
          "grid-template-rows",
          "hanging-punctuation",
          "height",
          "-ms-high-contrast-adjust",
          "-webkit-highlight",
          "hyphenate-character",
          "-webkit-hyphenate-character",
          "-webkit-hyphenate-limit-after",
          "-webkit-hyphenate-limit-before",
          "hyphenate-limit-chars",
          "-ms-hyphenate-limit-chars",
          "hyphenate-limit-last",
          "hyphenate-limit-lines",
          "-ms-hyphenate-limit-lines",
          "-webkit-hyphenate-limit-lines",
          "hyphenate-limit-zone",
          "-ms-hyphenate-limit-zone",
          "hyphens",
          "-moz-hyphens",
          "-ms-hyphens",
          "-webkit-hyphens",
          "image-orientation",
          "-moz-image-region",
          "image-rendering",
          "image-resolution",
          "-ms-ime-align",
          "ime-mode",
          "inherits",
          "initial-letter",
          "initial-letter-align",
          "-webkit-initial-letter",
          "initial-letter-wrap",
          "initial-value",
          "inline-size",
          "inline-sizing",
          "input-format",
          "-wap-input-format",
          "-wap-input-required",
          "input-security",
          "inset",
          "inset-block",
          "inset-block-end",
          "inset-block-start",
          "inset-inline",
          "inset-inline-end",
          "inset-inline-start",
          "-ms-interpolation-mode",
          "isolation",
          "justify-content",
          "-webkit-justify-content",
          "justify-items",
          "-webkit-justify-items",
          "justify-self",
          "-webkit-justify-self",
          "kerning",
          "layout-flow",
          "layout-grid",
          "layout-grid-char",
          "layout-grid-line",
          "layout-grid-mode",
          "layout-grid-type",
          "leading-trim",
          "left",
          "letter-spacing",
          "lighting-color",
          "-webkit-line-align",
          "-webkit-line-box-contain",
          "line-break",
          "-webkit-line-break",
          "line-clamp",
          "-webkit-line-clamp",
          "line-gap-override",
          "line-grid",
          "-webkit-line-grid-snap",
          "-webkit-line-grid",
          "line-height",
          "line-height-step",
          "line-increment",
          "line-padding",
          "line-snap",
          "-webkit-line-snap",
          "-o-link",
          "-o-link-source",
          "list-style",
          "list-style-image",
          "list-style-position",
          "list-style-type",
          "-webkit-locale",
          "-webkit-logical-height",
          "-webkit-logical-width",
          "margin",
          "-webkit-margin-after-collapse",
          "-webkit-margin-after",
          "-webkit-margin-before-collapse",
          "-webkit-margin-before",
          "margin-block",
          "margin-block-end",
          "margin-block-start",
          "margin-bottom",
          "-webkit-margin-bottom-collapse",
          "margin-break",
          "-webkit-margin-collapse",
          "-moz-margin-end",
          "-webkit-margin-end",
          "margin-inline",
          "margin-inline-end",
          "margin-inline-start",
          "margin-left",
          "margin-right",
          "-moz-margin-start",
          "-webkit-margin-start",
          "margin-top",
          "-webkit-margin-top-collapse",
          "margin-trim",
          "marker",
          "marker-end",
          "marker-knockout-left",
          "marker-knockout-right",
          "marker-mid",
          "marker-offset",
          "marker-pattern",
          "marker-segment",
          "marker-side",
          "marker-start",
          "marks",
          "-wap-marquee-dir",
          "-webkit-marquee-direction",
          "-webkit-marquee-increment",
          "-wap-marquee-loop",
          "-webkit-marquee-repetition",
          "-wap-marquee-speed",
          "-webkit-marquee-speed",
          "-wap-marquee-style",
          "-webkit-marquee-style",
          "-webkit-marquee",
          "mask",
          "-webkit-mask-attachment",
          "mask-border",
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width",
          "-webkit-mask-box-image-outset",
          "-webkit-mask-box-image-repeat",
          "-webkit-mask-box-image-slice",
          "-webkit-mask-box-image-source",
          "-webkit-mask-box-image",
          "-webkit-mask-box-image-width",
          "mask-clip",
          "-webkit-mask-clip",
          "mask-composite",
          "-webkit-mask-composite",
          "mask-image",
          "-webkit-mask-image",
          "mask-mode",
          "mask-origin",
          "-webkit-mask-origin",
          "mask-position",
          "-webkit-mask-position",
          "mask-position-x",
          "-webkit-mask-position-x",
          "mask-position-y",
          "-webkit-mask-position-y",
          "mask-repeat",
          "-webkit-mask-repeat",
          "-webkit-mask-repeat-x",
          "-webkit-mask-repeat-y",
          "mask-size",
          "-webkit-mask-size",
          "mask-source-type",
          "-webkit-mask-source-type",
          "mask-type",
          "-webkit-mask",
          "-webkit-match-nearest-mail-blockquote-color",
          "math-style",
          "max-block-size",
          "max-height",
          "max-inline-size",
          "max-lines",
          "-webkit-max-logical-height",
          "-webkit-max-logical-width",
          "max-width",
          "max-zoom",
          "min-block-size",
          "min-height",
          "min-inline-size",
          "min-intrinsic-sizing",
          "-webkit-min-logical-height",
          "-webkit-min-logical-width",
          "min-width",
          "min-zoom",
          "mix-blend-mode",
          "motion",
          "motion-offset",
          "motion-path",
          "motion-rotation",
          "nav-down",
          "nav-index",
          "nav-left",
          "nav-right",
          "nav-up",
          "-webkit-nbsp-mode",
          "negative",
          "object-fit",
          "-o-object-fit",
          "object-overflow",
          "object-position",
          "-o-object-position",
          "object-view-box",
          "offset",
          "offset-anchor",
          "offset-block-end",
          "offset-block-start",
          "offset-distance",
          "offset-inline-end",
          "offset-inline-start",
          "offset-path",
          "offset-position",
          "offset-rotate",
          "offset-rotation",
          "opacity",
          "-moz-opacity",
          "-webkit-opacity",
          "order",
          "-webkit-order",
          "-moz-orient",
          "orientation",
          "orphans",
          "-moz-osx-font-smoothing",
          "outline",
          "outline-color",
          "-moz-outline-color",
          "-moz-outline",
          "outline-offset",
          "-moz-outline-offset",
          "-moz-outline-radius-bottomleft",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius",
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "outline-style",
          "-moz-outline-style",
          "outline-width",
          "-moz-outline-width",
          "overflow",
          "overflow-anchor",
          "overflow-block",
          "overflow-clip-margin",
          "overflow-inline",
          "-webkit-overflow-scrolling",
          "-ms-overflow-style",
          "overflow-wrap",
          "overflow-x",
          "overflow-y",
          "override-colors",
          "overscroll-behavior",
          "overscroll-behavior-block",
          "overscroll-behavior-inline",
          "overscroll-behavior-x",
          "overscroll-behavior-y",
          "pad",
          "padding",
          "-webkit-padding-after",
          "-webkit-padding-before",
          "padding-block",
          "padding-block-end",
          "padding-block-start",
          "padding-bottom",
          "-moz-padding-end",
          "-webkit-padding-end",
          "padding-inline",
          "padding-inline-end",
          "padding-inline-start",
          "padding-left",
          "padding-right",
          "-moz-padding-start",
          "-webkit-padding-start",
          "padding-top",
          "page",
          "page-break-after",
          "page-break-before",
          "page-break-inside",
          "page-orientation",
          "paint-order",
          "pause",
          "pause-after",
          "pause-before",
          "-apple-pay-button-style",
          "-apple-pay-button-type",
          "pen-action",
          "perspective",
          "-moz-perspective",
          "-ms-perspective",
          "perspective-origin",
          "-moz-perspective-origin",
          "-ms-perspective-origin",
          "-webkit-perspective-origin",
          "perspective-origin-x",
          "-webkit-perspective-origin-x",
          "perspective-origin-y",
          "-webkit-perspective-origin-y",
          "-webkit-perspective",
          "pitch",
          "pitch-range",
          "place-content",
          "place-items",
          "place-self",
          "play-during",
          "pointer-events",
          "position",
          "prefix",
          "print-color-adjust",
          "-webkit-print-color-adjust",
          "property-name",
          "quotes",
          "r",
          "range",
          "-webkit-region-break-after",
          "-webkit-region-break-before",
          "-webkit-region-break-inside",
          "region-fragment",
          "-webkit-region-fragment",
          "-webkit-region-overflow",
          "resize",
          "rest",
          "rest-after",
          "rest-before",
          "richness",
          "right",
          "rotate",
          "row-gap",
          "-webkit-rtl-ordering",
          "ruby-align",
          "ruby-merge",
          "ruby-overhang",
          "ruby-position",
          "-webkit-ruby-position",
          "running",
          "rx",
          "ry",
          "scale",
          "scroll-behavior",
          "-ms-scroll-chaining",
          "-ms-scroll-limit",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-max",
          "-ms-scroll-limit-y-min",
          "scroll-margin",
          "scroll-margin-block",
          "scroll-margin-block-end",
          "scroll-margin-block-start",
          "scroll-margin-bottom",
          "scroll-margin-inline",
          "scroll-margin-inline-end",
          "scroll-margin-inline-start",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top",
          "scroll-padding",
          "scroll-padding-block",
          "scroll-padding-block-end",
          "scroll-padding-block-start",
          "scroll-padding-bottom",
          "scroll-padding-inline",
          "scroll-padding-inline-end",
          "scroll-padding-inline-start",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top",
          "-ms-scroll-rails",
          "scroll-snap-align",
          "scroll-snap-coordinate",
          "-webkit-scroll-snap-coordinate",
          "scroll-snap-destination",
          "-webkit-scroll-snap-destination",
          "scroll-snap-margin",
          "scroll-snap-margin-bottom",
          "scroll-snap-margin-left",
          "scroll-snap-margin-right",
          "scroll-snap-margin-top",
          "scroll-snap-points-x",
          "-ms-scroll-snap-points-x",
          "-webkit-scroll-snap-points-x",
          "scroll-snap-points-y",
          "-ms-scroll-snap-points-y",
          "-webkit-scroll-snap-points-y",
          "scroll-snap-stop",
          "scroll-snap-type",
          "-ms-scroll-snap-type",
          "-webkit-scroll-snap-type",
          "scroll-snap-type-x",
          "scroll-snap-type-y",
          "-ms-scroll-snap-x",
          "-ms-scroll-snap-y",
          "-ms-scroll-translation",
          "scrollbar-arrow-color",
          "scrollbar-base-color",
          "scrollbar-color",
          "scrollbar-dark-shadow-color",
          "scrollbar-darkshadow-color",
          "scrollbar-face-color",
          "scrollbar-gutter",
          "scrollbar-highlight-color",
          "scrollbar-shadow-color",
          "scrollbar-track-color",
          "scrollbar-width",
          "scrollbar3d-light-color",
          "scrollbar3dlight-color",
          "shape-image-threshold",
          "-webkit-shape-image-threshold",
          "shape-inside",
          "-webkit-shape-inside",
          "shape-margin",
          "-webkit-shape-margin",
          "shape-outside",
          "-webkit-shape-outside",
          "-webkit-shape-padding",
          "shape-rendering",
          "size",
          "size-adjust",
          "snap-height",
          "solid-color",
          "solid-opacity",
          "spatial-navigation-action",
          "spatial-navigation-contain",
          "spatial-navigation-function",
          "speak",
          "speak-as",
          "speak-header",
          "speak-numeral",
          "speak-punctuation",
          "speech-rate",
          "src",
          "-moz-stack-sizing",
          "stop-color",
          "stop-opacity",
          "stress",
          "string-set",
          "stroke",
          "stroke-align",
          "stroke-alignment",
          "stroke-break",
          "stroke-color",
          "stroke-dash-corner",
          "stroke-dash-justify",
          "stroke-dashadjust",
          "stroke-dasharray",
          "stroke-dashcorner",
          "stroke-dashoffset",
          "stroke-image",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-origin",
          "stroke-position",
          "stroke-repeat",
          "stroke-size",
          "stroke-width",
          "suffix",
          "supported-color-schemes",
          "-webkit-svg-shadow",
          "symbols",
          "syntax",
          "system",
          "tab-size",
          "-moz-tab-size",
          "-o-tab-size",
          "-o-table-baseline",
          "table-layout",
          "-webkit-tap-highlight-color",
          "text-align",
          "text-align-all",
          "text-align-last",
          "-moz-text-align-last",
          "text-anchor",
          "text-autospace",
          "-moz-text-blink",
          "-ms-text-combine-horizontal",
          "text-combine-upright",
          "-webkit-text-combine",
          "text-decoration",
          "text-decoration-blink",
          "text-decoration-color",
          "-moz-text-decoration-color",
          "-webkit-text-decoration-color",
          "text-decoration-line",
          "-moz-text-decoration-line",
          "text-decoration-line-through",
          "-webkit-text-decoration-line",
          "text-decoration-none",
          "text-decoration-overline",
          "text-decoration-skip",
          "text-decoration-skip-box",
          "text-decoration-skip-ink",
          "text-decoration-skip-inset",
          "text-decoration-skip-self",
          "text-decoration-skip-spaces",
          "-webkit-text-decoration-skip",
          "text-decoration-style",
          "-moz-text-decoration-style",
          "-webkit-text-decoration-style",
          "text-decoration-thickness",
          "text-decoration-underline",
          "-webkit-text-decoration",
          "-webkit-text-decorations-in-effect",
          "text-edge",
          "text-emphasis",
          "text-emphasis-color",
          "-webkit-text-emphasis-color",
          "text-emphasis-position",
          "-webkit-text-emphasis-position",
          "text-emphasis-skip",
          "text-emphasis-style",
          "-webkit-text-emphasis-style",
          "-webkit-text-emphasis",
          "-webkit-text-fill-color",
          "text-group-align",
          "text-indent",
          "text-justify",
          "text-justify-trim",
          "text-kashida",
          "text-kashida-space",
          "text-line-through",
          "text-line-through-color",
          "text-line-through-mode",
          "text-line-through-style",
          "text-line-through-width",
          "text-orientation",
          "-webkit-text-orientation",
          "text-overflow",
          "text-overline",
          "text-overline-color",
          "text-overline-mode",
          "text-overline-style",
          "text-overline-width",
          "text-rendering",
          "-webkit-text-security",
          "text-shadow",
          "text-size-adjust",
          "-moz-text-size-adjust",
          "-ms-text-size-adjust",
          "-webkit-text-size-adjust",
          "text-space-collapse",
          "text-space-trim",
          "text-spacing",
          "-webkit-text-stroke-color",
          "-webkit-text-stroke",
          "-webkit-text-stroke-width",
          "text-transform",
          "text-underline",
          "text-underline-color",
          "text-underline-mode",
          "text-underline-offset",
          "text-underline-position",
          "-webkit-text-underline-position",
          "text-underline-style",
          "text-underline-width",
          "text-wrap",
          "-webkit-text-zoom",
          "top",
          "touch-action",
          "touch-action-delay",
          "-ms-touch-action",
          "-webkit-touch-callout",
          "-ms-touch-select",
          "-apple-trailing-word",
          "transform",
          "transform-box",
          "-moz-transform",
          "-ms-transform",
          "-o-transform",
          "transform-origin",
          "-moz-transform-origin",
          "-ms-transform-origin",
          "-o-transform-origin",
          "-webkit-transform-origin",
          "transform-origin-x",
          "-webkit-transform-origin-x",
          "transform-origin-y",
          "-webkit-transform-origin-y",
          "transform-origin-z",
          "-webkit-transform-origin-z",
          "transform-style",
          "-moz-transform-style",
          "-ms-transform-style",
          "-webkit-transform-style",
          "-webkit-transform",
          "transition",
          "transition-delay",
          "-moz-transition-delay",
          "-ms-transition-delay",
          "-o-transition-delay",
          "-webkit-transition-delay",
          "transition-duration",
          "-moz-transition-duration",
          "-ms-transition-duration",
          "-o-transition-duration",
          "-webkit-transition-duration",
          "-moz-transition",
          "-ms-transition",
          "-o-transition",
          "transition-property",
          "-moz-transition-property",
          "-ms-transition-property",
          "-o-transition-property",
          "-webkit-transition-property",
          "transition-timing-function",
          "-moz-transition-timing-function",
          "-ms-transition-timing-function",
          "-o-transition-timing-function",
          "-webkit-transition-timing-function",
          "-webkit-transition",
          "translate",
          "uc-alt-skin",
          "uc-skin",
          "unicode-bidi",
          "unicode-range",
          "-webkit-user-drag",
          "-moz-user-focus",
          "-moz-user-input",
          "-moz-user-modify",
          "-webkit-user-modify",
          "user-select",
          "-moz-user-select",
          "-ms-user-select",
          "-webkit-user-select",
          "user-zoom",
          "vector-effect",
          "vertical-align",
          "viewport-fill",
          "viewport-fill-opacity",
          "viewport-fit",
          "visibility",
          "voice-balance",
          "voice-duration",
          "voice-family",
          "voice-pitch",
          "voice-range",
          "voice-rate",
          "voice-stress",
          "voice-volume",
          "volume",
          "white-space",
          "-webkit-widget-region",
          "widows",
          "width",
          "will-change",
          "-moz-window-dragging",
          "-moz-window-shadow",
          "word-boundary-detection",
          "word-boundary-expansion",
          "word-break",
          "word-spacing",
          "word-wrap",
          "wrap-after",
          "wrap-before",
          "wrap-flow",
          "-ms-wrap-flow",
          "-webkit-wrap-flow",
          "wrap-inside",
          "-ms-wrap-margin",
          "-webkit-wrap-margin",
          "-webkit-wrap-padding",
          "-webkit-wrap-shape-inside",
          "-webkit-wrap-shape-outside",
          "wrap-through",
          "-ms-wrap-through",
          "-webkit-wrap-through",
          "-webkit-wrap",
          "writing-mode",
          "-webkit-writing-mode",
          "x",
          "y",
          "z-index",
          "zoom"
        ]
      };
    }
  });

  // ../node_modules/known-css-properties/index.js
  var require_known_css_properties = __commonJS({
    "../node_modules/known-css-properties/index.js"(exports, module) {
      init_inject();
      module.exports.all = require_all().properties;
    }
  });

  // ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
  var require_set_array_umd = __commonJS({
    "../node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
      init_inject();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
      })(exports, function(exports2) {
        "use strict";
        exports2.get = void 0;
        exports2.put = void 0;
        exports2.pop = void 0;
        class SetArray {
          constructor() {
            this._indexes = { __proto__: null };
            this.array = [];
          }
        }
        (() => {
          exports2.get = (strarr, key) => strarr._indexes[key];
          exports2.put = (strarr, key) => {
            const index = exports2.get(strarr, key);
            if (index !== void 0)
              return index;
            const { array, _indexes: indexes } = strarr;
            return indexes[key] = array.push(key) - 1;
          };
          exports2.pop = (strarr) => {
            const { array, _indexes: indexes } = strarr;
            if (array.length === 0)
              return;
            const last = array.pop();
            indexes[last] = void 0;
          };
        })();
        exports2.SetArray = SetArray;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
  var require_sourcemap_codec_umd = __commonJS({
    "../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
      init_inject();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
      })(exports, function(exports2) {
        "use strict";
        const comma = ",".charCodeAt(0);
        const semicolon = ";".charCodeAt(0);
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        const intToChar = new Uint8Array(64);
        const charToInt = new Uint8Array(128);
        for (let i = 0; i < chars.length; i++) {
          const c = chars.charCodeAt(i);
          intToChar[i] = c;
          charToInt[c] = i;
        }
        const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
          decode(buf) {
            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
            return out.toString();
          }
        } : {
          decode(buf) {
            let out = "";
            for (let i = 0; i < buf.length; i++) {
              out += String.fromCharCode(buf[i]);
            }
            return out;
          }
        };
        function decode(mappings) {
          const state = new Int32Array(5);
          const decoded = [];
          let index = 0;
          do {
            const semi = indexOf(mappings, index);
            const line = [];
            let sorted = true;
            let lastCol = 0;
            state[0] = 0;
            for (let i = index; i < semi; i++) {
              let seg;
              i = decodeInteger(mappings, i, state, 0);
              const col = state[0];
              if (col < lastCol)
                sorted = false;
              lastCol = col;
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 1);
                i = decodeInteger(mappings, i, state, 2);
                i = decodeInteger(mappings, i, state, 3);
                if (hasMoreVlq(mappings, i, semi)) {
                  i = decodeInteger(mappings, i, state, 4);
                  seg = [col, state[1], state[2], state[3], state[4]];
                } else {
                  seg = [col, state[1], state[2], state[3]];
                }
              } else {
                seg = [col];
              }
              line.push(seg);
            }
            if (!sorted)
              sort(line);
            decoded.push(line);
            index = semi + 1;
          } while (index <= mappings.length);
          return decoded;
        }
        function indexOf(mappings, index) {
          const idx = mappings.indexOf(";", index);
          return idx === -1 ? mappings.length : idx;
        }
        function decodeInteger(mappings, pos, state, j) {
          let value = 0;
          let shift = 0;
          let integer = 0;
          do {
            const c = mappings.charCodeAt(pos++);
            integer = charToInt[c];
            value |= (integer & 31) << shift;
            shift += 5;
          } while (integer & 32);
          const shouldNegate = value & 1;
          value >>>= 1;
          if (shouldNegate) {
            value = -2147483648 | -value;
          }
          state[j] += value;
          return pos;
        }
        function hasMoreVlq(mappings, i, length) {
          if (i >= length)
            return false;
          return mappings.charCodeAt(i) !== comma;
        }
        function sort(line) {
          line.sort(sortComparator);
        }
        function sortComparator(a, b) {
          return a[0] - b[0];
        }
        function encode(decoded) {
          const state = new Int32Array(5);
          const bufLength = 1024 * 16;
          const subLength = bufLength - 36;
          const buf = new Uint8Array(bufLength);
          const sub = buf.subarray(0, subLength);
          let pos = 0;
          let out = "";
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            if (i > 0) {
              if (pos === bufLength) {
                out += td.decode(buf);
                pos = 0;
              }
              buf[pos++] = semicolon;
            }
            if (line.length === 0)
              continue;
            state[0] = 0;
            for (let j = 0; j < line.length; j++) {
              const segment = line[j];
              if (pos > subLength) {
                out += td.decode(sub);
                buf.copyWithin(0, subLength, pos);
                pos -= subLength;
              }
              if (j > 0)
                buf[pos++] = comma;
              pos = encodeInteger(buf, pos, state, segment, 0);
              if (segment.length === 1)
                continue;
              pos = encodeInteger(buf, pos, state, segment, 1);
              pos = encodeInteger(buf, pos, state, segment, 2);
              pos = encodeInteger(buf, pos, state, segment, 3);
              if (segment.length === 4)
                continue;
              pos = encodeInteger(buf, pos, state, segment, 4);
            }
          }
          return out + td.decode(buf.subarray(0, pos));
        }
        function encodeInteger(buf, pos, state, segment, j) {
          const next = segment[j];
          let num = next - state[j];
          state[j] = next;
          num = num < 0 ? -num << 1 | 1 : num << 1;
          do {
            let clamped = num & 31;
            num >>>= 5;
            if (num > 0)
              clamped |= 32;
            buf[pos++] = intToChar[clamped];
          } while (num > 0);
          return pos;
        }
        exports2.decode = decode;
        exports2.encode = encode;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
  var require_resolve_uri_umd = __commonJS({
    "../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
      init_inject();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
      })(exports, function() {
        "use strict";
        const schemeRegex = /^[\w+.-]+:\/\//;
        const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
        const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
        var UrlType;
        (function(UrlType2) {
          UrlType2[UrlType2["Empty"] = 1] = "Empty";
          UrlType2[UrlType2["Hash"] = 2] = "Hash";
          UrlType2[UrlType2["Query"] = 3] = "Query";
          UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
          UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
          UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
          UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
        })(UrlType || (UrlType = {}));
        function isAbsoluteUrl(input) {
          return schemeRegex.test(input);
        }
        function isSchemeRelativeUrl(input) {
          return input.startsWith("//");
        }
        function isAbsolutePath(input) {
          return input.startsWith("/");
        }
        function isFileUrl(input) {
          return input.startsWith("file:");
        }
        function isRelative(input) {
          return /^[.?#]/.test(input);
        }
        function parseAbsoluteUrl(input) {
          const match = urlRegex.exec(input);
          return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
        }
        function parseFileUrl(input) {
          const match = fileRegex.exec(input);
          const path = match[2];
          return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
        }
        function makeUrl(scheme, user, host, port, path, query, hash) {
          return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: UrlType.Absolute
          };
        }
        function parseUrl(input) {
          if (isSchemeRelativeUrl(input)) {
            const url2 = parseAbsoluteUrl("http:" + input);
            url2.scheme = "";
            url2.type = UrlType.SchemeRelative;
            return url2;
          }
          if (isAbsolutePath(input)) {
            const url2 = parseAbsoluteUrl("http://foo.com" + input);
            url2.scheme = "";
            url2.host = "";
            url2.type = UrlType.AbsolutePath;
            return url2;
          }
          if (isFileUrl(input))
            return parseFileUrl(input);
          if (isAbsoluteUrl(input))
            return parseAbsoluteUrl(input);
          const url = parseAbsoluteUrl("http://foo.com/" + input);
          url.scheme = "";
          url.host = "";
          url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
          return url;
        }
        function stripPathFilename(path) {
          if (path.endsWith("/.."))
            return path;
          const index = path.lastIndexOf("/");
          return path.slice(0, index + 1);
        }
        function mergePaths(url, base) {
          normalizePath(base, base.type);
          if (url.path === "/") {
            url.path = base.path;
          } else {
            url.path = stripPathFilename(base.path) + url.path;
          }
        }
        function normalizePath(url, type) {
          const rel = type <= UrlType.RelativePath;
          const pieces = url.path.split("/");
          let pointer = 1;
          let positive = 0;
          let addTrailingSlash = false;
          for (let i = 1; i < pieces.length; i++) {
            const piece = pieces[i];
            if (!piece) {
              addTrailingSlash = true;
              continue;
            }
            addTrailingSlash = false;
            if (piece === ".")
              continue;
            if (piece === "..") {
              if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
              } else if (rel) {
                pieces[pointer++] = piece;
              }
              continue;
            }
            pieces[pointer++] = piece;
            positive++;
          }
          let path = "";
          for (let i = 1; i < pointer; i++) {
            path += "/" + pieces[i];
          }
          if (!path || addTrailingSlash && !path.endsWith("/..")) {
            path += "/";
          }
          url.path = path;
        }
        function resolve(input, base) {
          if (!input && !base)
            return "";
          const url = parseUrl(input);
          let inputType = url.type;
          if (base && inputType !== UrlType.Absolute) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch (inputType) {
              case UrlType.Empty:
                url.hash = baseUrl.hash;
              case UrlType.Hash:
                url.query = baseUrl.query;
              case UrlType.Query:
              case UrlType.RelativePath:
                mergePaths(url, baseUrl);
              case UrlType.AbsolutePath:
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
              case UrlType.SchemeRelative:
                url.scheme = baseUrl.scheme;
            }
            if (baseType > inputType)
              inputType = baseType;
          }
          normalizePath(url, inputType);
          const queryHash = url.query + url.hash;
          switch (inputType) {
            case UrlType.Hash:
            case UrlType.Query:
              return queryHash;
            case UrlType.RelativePath: {
              const path = url.path.slice(1);
              if (!path)
                return queryHash || ".";
              if (isRelative(base || input) && !isRelative(path)) {
                return "./" + path + queryHash;
              }
              return path + queryHash;
            }
            case UrlType.AbsolutePath:
              return url.path + queryHash;
            default:
              return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
          }
        }
        return resolve;
      });
    }
  });

  // ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
  var require_trace_mapping_umd = __commonJS({
    "../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
      init_inject();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
      })(exports, function(exports2, sourcemapCodec, resolveUri) {
        "use strict";
        function _interopDefaultLegacy(e) {
          return e && typeof e === "object" && "default" in e ? e : { "default": e };
        }
        var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
        function resolve(input, base) {
          if (base && !base.endsWith("/"))
            base += "/";
          return resolveUri__default["default"](input, base);
        }
        function stripFilename(path) {
          if (!path)
            return "";
          const index = path.lastIndexOf("/");
          return path.slice(0, index + 1);
        }
        const COLUMN = 0;
        const SOURCES_INDEX = 1;
        const SOURCE_LINE = 2;
        const SOURCE_COLUMN = 3;
        const NAMES_INDEX = 4;
        const REV_GENERATED_LINE = 1;
        const REV_GENERATED_COLUMN = 2;
        function maybeSort(mappings, owned) {
          const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
          if (unsortedIndex === mappings.length)
            return mappings;
          if (!owned)
            mappings = mappings.slice();
          for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
            mappings[i] = sortSegments(mappings[i], owned);
          }
          return mappings;
        }
        function nextUnsortedSegmentLine(mappings, start) {
          for (let i = start; i < mappings.length; i++) {
            if (!isSorted(mappings[i]))
              return i;
          }
          return mappings.length;
        }
        function isSorted(line) {
          for (let j = 1; j < line.length; j++) {
            if (line[j][COLUMN] < line[j - 1][COLUMN]) {
              return false;
            }
          }
          return true;
        }
        function sortSegments(line, owned) {
          if (!owned)
            line = line.slice();
          return line.sort(sortComparator);
        }
        function sortComparator(a, b) {
          return a[COLUMN] - b[COLUMN];
        }
        let found = false;
        function binarySearch(haystack, needle, low, high) {
          while (low <= high) {
            const mid = low + (high - low >> 1);
            const cmp = haystack[mid][COLUMN] - needle;
            if (cmp === 0) {
              found = true;
              return mid;
            }
            if (cmp < 0) {
              low = mid + 1;
            } else {
              high = mid - 1;
            }
          }
          found = false;
          return low - 1;
        }
        function upperBound(haystack, needle, index) {
          for (let i = index + 1; i < haystack.length; index = i++) {
            if (haystack[i][COLUMN] !== needle)
              break;
          }
          return index;
        }
        function lowerBound(haystack, needle, index) {
          for (let i = index - 1; i >= 0; index = i--) {
            if (haystack[i][COLUMN] !== needle)
              break;
          }
          return index;
        }
        function memoizedState() {
          return {
            lastKey: -1,
            lastNeedle: -1,
            lastIndex: -1
          };
        }
        function memoizedBinarySearch(haystack, needle, state, key) {
          const { lastKey, lastNeedle, lastIndex } = state;
          let low = 0;
          let high = haystack.length - 1;
          if (key === lastKey) {
            if (needle === lastNeedle) {
              found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
              return lastIndex;
            }
            if (needle >= lastNeedle) {
              low = lastIndex === -1 ? 0 : lastIndex;
            } else {
              high = lastIndex;
            }
          }
          state.lastKey = key;
          state.lastNeedle = needle;
          return state.lastIndex = binarySearch(haystack, needle, low, high);
        }
        function buildBySources(decoded, memos) {
          const sources = memos.map(buildNullArray);
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              if (seg.length === 1)
                continue;
              const sourceIndex = seg[SOURCES_INDEX];
              const sourceLine = seg[SOURCE_LINE];
              const sourceColumn = seg[SOURCE_COLUMN];
              const originalSource = sources[sourceIndex];
              const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
              const memo = memos[sourceIndex];
              const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
              insert2(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
            }
          }
          return sources;
        }
        function insert2(array, index, value) {
          for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
          }
          array[index] = value;
        }
        function buildNullArray() {
          return { __proto__: null };
        }
        const AnyMap = function(map, mapUrl) {
          const parsed = typeof map === "string" ? JSON.parse(map) : map;
          if (!("sections" in parsed))
            return new TraceMap(parsed, mapUrl);
          const mappings = [];
          const sources = [];
          const sourcesContent = [];
          const names = [];
          recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
          const joined = {
            version: 3,
            file: parsed.file,
            names,
            sources,
            sourcesContent,
            mappings
          };
          return exports2.presortedDecodedMap(joined);
        };
        function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
          const { sections } = input;
          for (let i = 0; i < sections.length; i++) {
            const { map, offset } = sections[i];
            let sl = stopLine;
            let sc = stopColumn;
            if (i + 1 < sections.length) {
              const nextOffset = sections[i + 1].offset;
              sl = Math.min(stopLine, lineOffset + nextOffset.line);
              if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
              } else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
              }
            }
            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
          }
        }
        function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
          if ("sections" in input)
            return recurse(...arguments);
          const map = new TraceMap(input, mapUrl);
          const sourcesOffset = sources.length;
          const namesOffset = names.length;
          const decoded = exports2.decodedMappings(map);
          const { resolvedSources, sourcesContent: contents } = map;
          append(sources, resolvedSources);
          append(names, map.names);
          if (contents)
            append(sourcesContent, contents);
          else
            for (let i = 0; i < resolvedSources.length; i++)
              sourcesContent.push(null);
          for (let i = 0; i < decoded.length; i++) {
            const lineI = lineOffset + i;
            if (lineI > stopLine)
              return;
            const out = getLine(mappings, lineI);
            const cOffset = i === 0 ? columnOffset : 0;
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const column = cOffset + seg[COLUMN];
              if (lineI === stopLine && column >= stopColumn)
                return;
              if (seg.length === 1) {
                out.push([column]);
                continue;
              }
              const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
              const sourceLine = seg[SOURCE_LINE];
              const sourceColumn = seg[SOURCE_COLUMN];
              out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
            }
          }
        }
        function append(arr, other) {
          for (let i = 0; i < other.length; i++)
            arr.push(other[i]);
        }
        function getLine(arr, index) {
          for (let i = arr.length; i <= index; i++)
            arr[i] = [];
          return arr[index];
        }
        const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
        const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
        const LEAST_UPPER_BOUND = -1;
        const GREATEST_LOWER_BOUND = 1;
        exports2.encodedMappings = void 0;
        exports2.decodedMappings = void 0;
        exports2.traceSegment = void 0;
        exports2.originalPositionFor = void 0;
        exports2.generatedPositionFor = void 0;
        exports2.eachMapping = void 0;
        exports2.sourceContentFor = void 0;
        exports2.presortedDecodedMap = void 0;
        exports2.decodedMap = void 0;
        exports2.encodedMap = void 0;
        class TraceMap {
          constructor(map, mapUrl) {
            const isString = typeof map === "string";
            if (!isString && map._decodedMemo)
              return map;
            const parsed = isString ? JSON.parse(map) : map;
            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
            this.version = version;
            this.file = file;
            this.names = names;
            this.sourceRoot = sourceRoot;
            this.sources = sources;
            this.sourcesContent = sourcesContent;
            const from = resolve(sourceRoot || "", stripFilename(mapUrl));
            this.resolvedSources = sources.map((s) => resolve(s || "", from));
            const { mappings } = parsed;
            if (typeof mappings === "string") {
              this._encoded = mappings;
              this._decoded = void 0;
            } else {
              this._encoded = void 0;
              this._decoded = maybeSort(mappings, isString);
            }
            this._decodedMemo = memoizedState();
            this._bySources = void 0;
            this._bySourceMemos = void 0;
          }
        }
        (() => {
          exports2.encodedMappings = (map) => {
            var _a2;
            return (_a2 = map._encoded) !== null && _a2 !== void 0 ? _a2 : map._encoded = sourcemapCodec.encode(map._decoded);
          };
          exports2.decodedMappings = (map) => {
            return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
          };
          exports2.traceSegment = (map, line, column) => {
            const decoded = exports2.decodedMappings(map);
            if (line >= decoded.length)
              return null;
            return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
          };
          exports2.originalPositionFor = (map, { line, column, bias }) => {
            line--;
            if (line < 0)
              throw new Error(LINE_GTR_ZERO);
            if (column < 0)
              throw new Error(COL_GTR_EQ_ZERO);
            const decoded = exports2.decodedMappings(map);
            if (line >= decoded.length)
              return OMapping(null, null, null, null);
            const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
            if (segment == null)
              return OMapping(null, null, null, null);
            if (segment.length == 1)
              return OMapping(null, null, null, null);
            const { names, resolvedSources } = map;
            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
          };
          exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
            line--;
            if (line < 0)
              throw new Error(LINE_GTR_ZERO);
            if (column < 0)
              throw new Error(COL_GTR_EQ_ZERO);
            const { sources, resolvedSources } = map;
            let sourceIndex = sources.indexOf(source);
            if (sourceIndex === -1)
              sourceIndex = resolvedSources.indexOf(source);
            if (sourceIndex === -1)
              return GMapping(null, null);
            const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
            const memos = map._bySourceMemos;
            const segments = generated[sourceIndex][line];
            if (segments == null)
              return GMapping(null, null);
            const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);
            if (segment == null)
              return GMapping(null, null);
            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
          };
          exports2.eachMapping = (map, cb) => {
            const decoded = exports2.decodedMappings(map);
            const { names, resolvedSources } = map;
            for (let i = 0; i < decoded.length; i++) {
              const line = decoded[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generatedLine = i + 1;
                const generatedColumn = seg[0];
                let source = null;
                let originalLine = null;
                let originalColumn = null;
                let name = null;
                if (seg.length !== 1) {
                  source = resolvedSources[seg[1]];
                  originalLine = seg[2] + 1;
                  originalColumn = seg[3];
                }
                if (seg.length === 5)
                  name = names[seg[4]];
                cb({
                  generatedLine,
                  generatedColumn,
                  source,
                  originalLine,
                  originalColumn,
                  name
                });
              }
            }
          };
          exports2.sourceContentFor = (map, source) => {
            const { sources, resolvedSources, sourcesContent } = map;
            if (sourcesContent == null)
              return null;
            let index = sources.indexOf(source);
            if (index === -1)
              index = resolvedSources.indexOf(source);
            return index === -1 ? null : sourcesContent[index];
          };
          exports2.presortedDecodedMap = (map, mapUrl) => {
            const tracer = new TraceMap(clone(map, []), mapUrl);
            tracer._decoded = map.mappings;
            return tracer;
          };
          exports2.decodedMap = (map) => {
            return clone(map, exports2.decodedMappings(map));
          };
          exports2.encodedMap = (map) => {
            return clone(map, exports2.encodedMappings(map));
          };
        })();
        function clone(map, mappings) {
          return {
            version: map.version,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings
          };
        }
        function OMapping(source, line, column, name) {
          return { source, line, column, name };
        }
        function GMapping(line, column) {
          return { line, column };
        }
        function traceSegmentInternal(segments, memo, line, column, bias) {
          let index = memoizedBinarySearch(segments, column, memo, line);
          if (found) {
            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
          } else if (bias === LEAST_UPPER_BOUND)
            index++;
          if (index === -1 || index === segments.length)
            return null;
          return segments[index];
        }
        exports2.AnyMap = AnyMap;
        exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
        exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
        exports2.TraceMap = TraceMap;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
  var require_gen_mapping_umd = __commonJS({
    "../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
      init_inject();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
      })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
        "use strict";
        const COLUMN = 0;
        const SOURCES_INDEX = 1;
        const SOURCE_LINE = 2;
        const SOURCE_COLUMN = 3;
        const NAMES_INDEX = 4;
        const NO_NAME = -1;
        exports2.addSegment = void 0;
        exports2.addMapping = void 0;
        exports2.maybeAddSegment = void 0;
        exports2.maybeAddMapping = void 0;
        exports2.setSourceContent = void 0;
        exports2.toDecodedMap = void 0;
        exports2.toEncodedMap = void 0;
        exports2.fromMap = void 0;
        exports2.allMappings = void 0;
        let addSegmentInternal;
        class GenMapping {
          constructor({ file, sourceRoot } = {}) {
            this._names = new setArray.SetArray();
            this._sources = new setArray.SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
          }
        }
        (() => {
          exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
            return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
          };
          exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
            return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
          };
          exports2.addMapping = (map, mapping) => {
            return addMappingInternal(false, map, mapping);
          };
          exports2.maybeAddMapping = (map, mapping) => {
            return addMappingInternal(true, map, mapping);
          };
          exports2.setSourceContent = (map, source, content) => {
            const { _sources: sources, _sourcesContent: sourcesContent } = map;
            sourcesContent[setArray.put(sources, source)] = content;
          };
          exports2.toDecodedMap = (map) => {
            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            removeEmptyFinalLines(mappings);
            return {
              version: 3,
              file: file || void 0,
              names: names.array,
              sourceRoot: sourceRoot || void 0,
              sources: sources.array,
              sourcesContent,
              mappings
            };
          };
          exports2.toEncodedMap = (map) => {
            const decoded = exports2.toDecodedMap(map);
            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
          };
          exports2.allMappings = (map) => {
            const out = [];
            const { _mappings: mappings, _sources: sources, _names: names } = map;
            for (let i = 0; i < mappings.length; i++) {
              const line = mappings[i];
              for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generated = { line: i + 1, column: seg[COLUMN] };
                let source = void 0;
                let original = void 0;
                let name = void 0;
                if (seg.length !== 1) {
                  source = sources.array[seg[SOURCES_INDEX]];
                  original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                  if (seg.length === 5)
                    name = names.array[seg[NAMES_INDEX]];
                }
                out.push({ generated, source, original, name });
              }
            }
            return out;
          };
          exports2.fromMap = (input) => {
            const map = new traceMapping.TraceMap(input);
            const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
            putAll(gen._names, map.names);
            putAll(gen._sources, map.sources);
            gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
            gen._mappings = traceMapping.decodedMappings(map);
            return gen;
          };
          addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            const line = getLine(mappings, genLine);
            const index = getColumnIndex(line, genColumn);
            if (!source) {
              if (skipable && skipSourceless(line, index))
                return;
              return insert2(line, index, [genColumn]);
            }
            const sourcesIndex = setArray.put(sources, source);
            const namesIndex = name ? setArray.put(names, name) : NO_NAME;
            if (sourcesIndex === sourcesContent.length)
              sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
              return;
            }
            return insert2(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
          };
        })();
        function getLine(mappings, index) {
          for (let i = mappings.length; i <= index; i++) {
            mappings[i] = [];
          }
          return mappings[index];
        }
        function getColumnIndex(line, genColumn) {
          let index = line.length;
          for (let i = index - 1; i >= 0; index = i--) {
            const current = line[i];
            if (genColumn >= current[COLUMN])
              break;
          }
          return index;
        }
        function insert2(array, index, value) {
          for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
          }
          array[index] = value;
        }
        function removeEmptyFinalLines(mappings) {
          const { length } = mappings;
          let len = length;
          for (let i = len - 1; i >= 0; len = i, i--) {
            if (mappings[i].length > 0)
              break;
          }
          if (len < length)
            mappings.length = len;
        }
        function putAll(strarr, array) {
          for (let i = 0; i < array.length; i++)
            setArray.put(strarr, array[i]);
        }
        function skipSourceless(line, index) {
          if (index === 0)
            return true;
          const prev = line[index - 1];
          return prev.length === 1;
        }
        function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
          if (index === 0)
            return false;
          const prev = line[index - 1];
          if (prev.length === 1)
            return false;
          return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
        }
        function addMappingInternal(skipable, map, mapping) {
          const { generated, source, original, name, content } = mapping;
          if (!source) {
            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
          }
          const s = source;
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
        }
        exports2.GenMapping = GenMapping;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/@babel/generator/lib/source-map.js
  var require_source_map = __commonJS({
    "../node_modules/@babel/generator/lib/source-map.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _genMapping = require_gen_mapping_umd();
      var SourceMap = class {
        constructor(opts, code) {
          var _opts$sourceFileName;
          this._map = void 0;
          this._rawMappings = void 0;
          this._sourceFileName = void 0;
          this._lastGenLine = 0;
          this._lastSourceLine = 0;
          this._lastSourceColumn = 0;
          const map = this._map = new _genMapping.GenMapping({
            sourceRoot: opts.sourceRoot
          });
          this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
          this._rawMappings = void 0;
          if (typeof code === "string") {
            (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
          } else if (typeof code === "object") {
            Object.keys(code).forEach((sourceFileName) => {
              (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
            });
          }
        }
        get() {
          return (0, _genMapping.toEncodedMap)(this._map);
        }
        getDecoded() {
          return (0, _genMapping.toDecodedMap)(this._map);
        }
        getRawMappings() {
          return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
        }
        mark(generated, line, column, identifierName, filename) {
          this._rawMappings = void 0;
          (0, _genMapping.maybeAddMapping)(this._map, {
            name: identifierName,
            generated,
            source: line == null ? void 0 : (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            original: line == null ? void 0 : {
              line,
              column
            }
          });
        }
      };
      exports.default = SourceMap;
    }
  });

  // ../node_modules/@babel/generator/lib/buffer.js
  var require_buffer = __commonJS({
    "../node_modules/@babel/generator/lib/buffer.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function SourcePos() {
        return {
          identifierName: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
      }
      var Buffer2 = class {
        constructor(map) {
          this._map = null;
          this._buf = "";
          this._str = "";
          this._appendCount = 0;
          this._last = 0;
          this._queue = [];
          this._queueCursor = 0;
          this._position = {
            line: 1,
            column: 0
          };
          this._sourcePosition = SourcePos();
          this._disallowedPop = {
            identifierName: void 0,
            line: void 0,
            column: void 0,
            filename: void 0,
            objectReusable: true
          };
          this._map = map;
          this._allocQueue();
        }
        _allocQueue() {
          const queue = this._queue;
          for (let i = 0; i < 16; i++) {
            queue.push({
              char: 0,
              repeat: 1,
              line: void 0,
              column: void 0,
              identifierName: void 0,
              filename: ""
            });
          }
        }
        _pushQueue(char, repeat, line, column, identifierName, filename) {
          const cursor = this._queueCursor;
          if (cursor === this._queue.length) {
            this._allocQueue();
          }
          const item = this._queue[cursor];
          item.char = char;
          item.repeat = repeat;
          item.line = line;
          item.column = column;
          item.identifierName = identifierName;
          item.filename = filename;
          this._queueCursor++;
        }
        _popQueue() {
          if (this._queueCursor === 0) {
            throw new Error("Cannot pop from empty queue");
          }
          return this._queue[--this._queueCursor];
        }
        get() {
          this._flush();
          const map = this._map;
          const result = {
            code: (this._buf + this._str).trimRight(),
            decodedMap: map == null ? void 0 : map.getDecoded(),
            get map() {
              const resultMap = map ? map.get() : null;
              result.map = resultMap;
              return resultMap;
            },
            set map(value) {
              Object.defineProperty(result, "map", {
                value,
                writable: true
              });
            },
            get rawMappings() {
              const mappings = map == null ? void 0 : map.getRawMappings();
              result.rawMappings = mappings;
              return mappings;
            },
            set rawMappings(value) {
              Object.defineProperty(result, "rawMappings", {
                value,
                writable: true
              });
            }
          };
          return result;
        }
        append(str, maybeNewline) {
          this._flush();
          this._append(str, this._sourcePosition, maybeNewline);
        }
        appendChar(char) {
          this._flush();
          this._appendChar(char, 1, this._sourcePosition);
        }
        queue(char) {
          if (char === 10) {
            while (this._queueCursor !== 0) {
              const char2 = this._queue[this._queueCursor - 1].char;
              if (char2 !== 32 && char2 !== 9) {
                break;
              }
              this._queueCursor--;
            }
          }
          const sourcePosition = this._sourcePosition;
          this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);
        }
        queueIndentation(char, repeat) {
          this._pushQueue(char, repeat, void 0, void 0, void 0, void 0);
        }
        _flush() {
          const queueCursor = this._queueCursor;
          const queue = this._queue;
          for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            this._appendChar(item.char, item.repeat, item);
          }
          this._queueCursor = 0;
        }
        _appendChar(char, repeat, sourcePos) {
          this._last = char;
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
          if (char !== 10) {
            this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);
            this._position.column += repeat;
          } else {
            this._position.line++;
            this._position.column = 0;
          }
        }
        _append(str, sourcePos, maybeNewline) {
          const len = str.length;
          this._last = str.charCodeAt(len - 1);
          if (++this._appendCount > 4096) {
            +this._str;
            this._buf += this._str;
            this._str = str;
            this._appendCount = 0;
          } else {
            this._str += str;
          }
          if (!maybeNewline && !this._map) {
            this._position.column += len;
            return;
          }
          const {
            column,
            identifierName,
            filename
          } = sourcePos;
          let line = sourcePos.line;
          let i = str.indexOf("\n");
          let last = 0;
          if (i !== 0) {
            this._mark(line, column, identifierName, filename);
          }
          while (i !== -1) {
            this._position.line++;
            this._position.column = 0;
            last = i + 1;
            if (last < str.length) {
              this._mark(++line, 0, identifierName, filename);
            }
            i = str.indexOf("\n", last);
          }
          this._position.column += str.length - last;
        }
        _mark(line, column, identifierName, filename) {
          var _this$_map;
          (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);
        }
        removeTrailingNewline() {
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
            this._queueCursor--;
          }
        }
        removeLastSemicolon() {
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
            this._queueCursor--;
          }
        }
        getLastChar() {
          const queueCursor = this._queueCursor;
          return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
        }
        endsWithCharAndNewline() {
          const queue = this._queue;
          const queueCursor = this._queueCursor;
          if (queueCursor !== 0) {
            const lastCp = queue[queueCursor - 1].char;
            if (lastCp !== 10)
              return;
            if (queueCursor > 1) {
              return queue[queueCursor - 2].char;
            } else {
              return this._last;
            }
          }
        }
        hasContent() {
          return this._queueCursor !== 0 || !!this._last;
        }
        exactSource(loc, cb) {
          if (!this._map)
            return cb();
          this.source("start", loc);
          cb();
          this.source("end", loc);
          this._disallowPop("start", loc);
        }
        source(prop, loc) {
          if (!loc)
            return;
          this._normalizePosition(prop, loc, this._sourcePosition);
        }
        withSource(prop, loc, cb) {
          if (!this._map)
            return cb();
          const originalLine = this._sourcePosition.line;
          const originalColumn = this._sourcePosition.column;
          const originalFilename = this._sourcePosition.filename;
          const originalIdentifierName = this._sourcePosition.identifierName;
          this.source(prop, loc);
          cb();
          if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {
            this._sourcePosition.line = originalLine;
            this._sourcePosition.column = originalColumn;
            this._sourcePosition.filename = originalFilename;
            this._sourcePosition.identifierName = originalIdentifierName;
            this._disallowedPop.objectReusable = true;
          }
        }
        _disallowPop(prop, loc) {
          if (!loc)
            return;
          const disallowedPop = this._disallowedPop;
          this._normalizePosition(prop, loc, disallowedPop);
          disallowedPop.objectReusable = false;
        }
        _normalizePosition(prop, loc, targetObj) {
          const pos = loc[prop];
          targetObj.identifierName = prop === "start" && loc.identifierName || void 0;
          if (pos) {
            targetObj.line = pos.line;
            targetObj.column = pos.column;
            targetObj.filename = loc.filename;
          } else {
            targetObj.line = null;
            targetObj.column = null;
            targetObj.filename = null;
          }
        }
        getCurrentColumn() {
          const queue = this._queue;
          let lastIndex = -1;
          let len = 0;
          for (let i = 0; i < this._queueCursor; i++) {
            const item = queue[i];
            if (item.char === 10) {
              lastIndex = i;
              len += item.repeat;
            }
          }
          return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
        }
        getCurrentLine() {
          let count = 0;
          const queue = this._queue;
          for (let i = 0; i < this._queueCursor; i++) {
            if (queue[i].char === 10) {
              count++;
            }
          }
          return this._position.line + count;
        }
      };
      exports.default = Buffer2;
    }
  });

  // ../node_modules/@babel/types/lib/utils/shallowEqual.js
  var require_shallowEqual = __commonJS({
    "../node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = shallowEqual;
      function shallowEqual(actual, expected) {
        const keys = Object.keys(expected);
        for (const key of keys) {
          if (actual[key] !== expected[key]) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/generated/index.js
  var require_generated = __commonJS({
    "../node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAccessor = isAccessor;
      exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
      exports.isArgumentPlaceholder = isArgumentPlaceholder;
      exports.isArrayExpression = isArrayExpression;
      exports.isArrayPattern = isArrayPattern;
      exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
      exports.isArrowFunctionExpression = isArrowFunctionExpression;
      exports.isAssignmentExpression = isAssignmentExpression;
      exports.isAssignmentPattern = isAssignmentPattern;
      exports.isAwaitExpression = isAwaitExpression;
      exports.isBigIntLiteral = isBigIntLiteral;
      exports.isBinary = isBinary;
      exports.isBinaryExpression = isBinaryExpression;
      exports.isBindExpression = isBindExpression;
      exports.isBlock = isBlock;
      exports.isBlockParent = isBlockParent;
      exports.isBlockStatement = isBlockStatement;
      exports.isBooleanLiteral = isBooleanLiteral;
      exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
      exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
      exports.isBreakStatement = isBreakStatement;
      exports.isCallExpression = isCallExpression;
      exports.isCatchClause = isCatchClause;
      exports.isClass = isClass;
      exports.isClassAccessorProperty = isClassAccessorProperty;
      exports.isClassBody = isClassBody;
      exports.isClassDeclaration = isClassDeclaration;
      exports.isClassExpression = isClassExpression;
      exports.isClassImplements = isClassImplements;
      exports.isClassMethod = isClassMethod;
      exports.isClassPrivateMethod = isClassPrivateMethod;
      exports.isClassPrivateProperty = isClassPrivateProperty;
      exports.isClassProperty = isClassProperty;
      exports.isCompletionStatement = isCompletionStatement;
      exports.isConditional = isConditional;
      exports.isConditionalExpression = isConditionalExpression;
      exports.isContinueStatement = isContinueStatement;
      exports.isDebuggerStatement = isDebuggerStatement;
      exports.isDecimalLiteral = isDecimalLiteral;
      exports.isDeclaration = isDeclaration;
      exports.isDeclareClass = isDeclareClass;
      exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
      exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
      exports.isDeclareFunction = isDeclareFunction;
      exports.isDeclareInterface = isDeclareInterface;
      exports.isDeclareModule = isDeclareModule;
      exports.isDeclareModuleExports = isDeclareModuleExports;
      exports.isDeclareOpaqueType = isDeclareOpaqueType;
      exports.isDeclareTypeAlias = isDeclareTypeAlias;
      exports.isDeclareVariable = isDeclareVariable;
      exports.isDeclaredPredicate = isDeclaredPredicate;
      exports.isDecorator = isDecorator;
      exports.isDirective = isDirective;
      exports.isDirectiveLiteral = isDirectiveLiteral;
      exports.isDoExpression = isDoExpression;
      exports.isDoWhileStatement = isDoWhileStatement;
      exports.isEmptyStatement = isEmptyStatement;
      exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
      exports.isEnumBody = isEnumBody;
      exports.isEnumBooleanBody = isEnumBooleanBody;
      exports.isEnumBooleanMember = isEnumBooleanMember;
      exports.isEnumDeclaration = isEnumDeclaration;
      exports.isEnumDefaultedMember = isEnumDefaultedMember;
      exports.isEnumMember = isEnumMember;
      exports.isEnumNumberBody = isEnumNumberBody;
      exports.isEnumNumberMember = isEnumNumberMember;
      exports.isEnumStringBody = isEnumStringBody;
      exports.isEnumStringMember = isEnumStringMember;
      exports.isEnumSymbolBody = isEnumSymbolBody;
      exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
      exports.isExportAllDeclaration = isExportAllDeclaration;
      exports.isExportDeclaration = isExportDeclaration;
      exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
      exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
      exports.isExportNamedDeclaration = isExportNamedDeclaration;
      exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
      exports.isExportSpecifier = isExportSpecifier;
      exports.isExpression = isExpression;
      exports.isExpressionStatement = isExpressionStatement;
      exports.isExpressionWrapper = isExpressionWrapper;
      exports.isFile = isFile;
      exports.isFlow = isFlow;
      exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
      exports.isFlowDeclaration = isFlowDeclaration;
      exports.isFlowPredicate = isFlowPredicate;
      exports.isFlowType = isFlowType;
      exports.isFor = isFor;
      exports.isForInStatement = isForInStatement;
      exports.isForOfStatement = isForOfStatement;
      exports.isForStatement = isForStatement;
      exports.isForXStatement = isForXStatement;
      exports.isFunction = isFunction;
      exports.isFunctionDeclaration = isFunctionDeclaration;
      exports.isFunctionExpression = isFunctionExpression;
      exports.isFunctionParent = isFunctionParent;
      exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
      exports.isFunctionTypeParam = isFunctionTypeParam;
      exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
      exports.isIdentifier = isIdentifier;
      exports.isIfStatement = isIfStatement;
      exports.isImmutable = isImmutable;
      exports.isImport = isImport;
      exports.isImportAttribute = isImportAttribute;
      exports.isImportDeclaration = isImportDeclaration;
      exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
      exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
      exports.isImportSpecifier = isImportSpecifier;
      exports.isIndexedAccessType = isIndexedAccessType;
      exports.isInferredPredicate = isInferredPredicate;
      exports.isInterfaceDeclaration = isInterfaceDeclaration;
      exports.isInterfaceExtends = isInterfaceExtends;
      exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
      exports.isInterpreterDirective = isInterpreterDirective;
      exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
      exports.isJSX = isJSX;
      exports.isJSXAttribute = isJSXAttribute;
      exports.isJSXClosingElement = isJSXClosingElement;
      exports.isJSXClosingFragment = isJSXClosingFragment;
      exports.isJSXElement = isJSXElement;
      exports.isJSXEmptyExpression = isJSXEmptyExpression;
      exports.isJSXExpressionContainer = isJSXExpressionContainer;
      exports.isJSXFragment = isJSXFragment;
      exports.isJSXIdentifier = isJSXIdentifier;
      exports.isJSXMemberExpression = isJSXMemberExpression;
      exports.isJSXNamespacedName = isJSXNamespacedName;
      exports.isJSXOpeningElement = isJSXOpeningElement;
      exports.isJSXOpeningFragment = isJSXOpeningFragment;
      exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
      exports.isJSXSpreadChild = isJSXSpreadChild;
      exports.isJSXText = isJSXText;
      exports.isLVal = isLVal;
      exports.isLabeledStatement = isLabeledStatement;
      exports.isLiteral = isLiteral;
      exports.isLogicalExpression = isLogicalExpression;
      exports.isLoop = isLoop;
      exports.isMemberExpression = isMemberExpression;
      exports.isMetaProperty = isMetaProperty;
      exports.isMethod = isMethod;
      exports.isMiscellaneous = isMiscellaneous;
      exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
      exports.isModuleDeclaration = isModuleDeclaration;
      exports.isModuleExpression = isModuleExpression;
      exports.isModuleSpecifier = isModuleSpecifier;
      exports.isNewExpression = isNewExpression;
      exports.isNoop = isNoop;
      exports.isNullLiteral = isNullLiteral;
      exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
      exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
      exports.isNumberLiteral = isNumberLiteral;
      exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
      exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
      exports.isNumericLiteral = isNumericLiteral;
      exports.isObjectExpression = isObjectExpression;
      exports.isObjectMember = isObjectMember;
      exports.isObjectMethod = isObjectMethod;
      exports.isObjectPattern = isObjectPattern;
      exports.isObjectProperty = isObjectProperty;
      exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
      exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
      exports.isObjectTypeIndexer = isObjectTypeIndexer;
      exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
      exports.isObjectTypeProperty = isObjectTypeProperty;
      exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
      exports.isOpaqueType = isOpaqueType;
      exports.isOptionalCallExpression = isOptionalCallExpression;
      exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
      exports.isOptionalMemberExpression = isOptionalMemberExpression;
      exports.isParenthesizedExpression = isParenthesizedExpression;
      exports.isPattern = isPattern;
      exports.isPatternLike = isPatternLike;
      exports.isPipelineBareFunction = isPipelineBareFunction;
      exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
      exports.isPipelineTopicExpression = isPipelineTopicExpression;
      exports.isPlaceholder = isPlaceholder;
      exports.isPrivate = isPrivate;
      exports.isPrivateName = isPrivateName;
      exports.isProgram = isProgram;
      exports.isProperty = isProperty;
      exports.isPureish = isPureish;
      exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
      exports.isRecordExpression = isRecordExpression;
      exports.isRegExpLiteral = isRegExpLiteral;
      exports.isRegexLiteral = isRegexLiteral;
      exports.isRestElement = isRestElement;
      exports.isRestProperty = isRestProperty;
      exports.isReturnStatement = isReturnStatement;
      exports.isScopable = isScopable;
      exports.isSequenceExpression = isSequenceExpression;
      exports.isSpreadElement = isSpreadElement;
      exports.isSpreadProperty = isSpreadProperty;
      exports.isStandardized = isStandardized;
      exports.isStatement = isStatement;
      exports.isStaticBlock = isStaticBlock;
      exports.isStringLiteral = isStringLiteral;
      exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
      exports.isStringTypeAnnotation = isStringTypeAnnotation;
      exports.isSuper = isSuper;
      exports.isSwitchCase = isSwitchCase;
      exports.isSwitchStatement = isSwitchStatement;
      exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
      exports.isTSAnyKeyword = isTSAnyKeyword;
      exports.isTSArrayType = isTSArrayType;
      exports.isTSAsExpression = isTSAsExpression;
      exports.isTSBaseType = isTSBaseType;
      exports.isTSBigIntKeyword = isTSBigIntKeyword;
      exports.isTSBooleanKeyword = isTSBooleanKeyword;
      exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
      exports.isTSConditionalType = isTSConditionalType;
      exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
      exports.isTSConstructorType = isTSConstructorType;
      exports.isTSDeclareFunction = isTSDeclareFunction;
      exports.isTSDeclareMethod = isTSDeclareMethod;
      exports.isTSEntityName = isTSEntityName;
      exports.isTSEnumDeclaration = isTSEnumDeclaration;
      exports.isTSEnumMember = isTSEnumMember;
      exports.isTSExportAssignment = isTSExportAssignment;
      exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
      exports.isTSExternalModuleReference = isTSExternalModuleReference;
      exports.isTSFunctionType = isTSFunctionType;
      exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
      exports.isTSImportType = isTSImportType;
      exports.isTSIndexSignature = isTSIndexSignature;
      exports.isTSIndexedAccessType = isTSIndexedAccessType;
      exports.isTSInferType = isTSInferType;
      exports.isTSInstantiationExpression = isTSInstantiationExpression;
      exports.isTSInterfaceBody = isTSInterfaceBody;
      exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
      exports.isTSIntersectionType = isTSIntersectionType;
      exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
      exports.isTSLiteralType = isTSLiteralType;
      exports.isTSMappedType = isTSMappedType;
      exports.isTSMethodSignature = isTSMethodSignature;
      exports.isTSModuleBlock = isTSModuleBlock;
      exports.isTSModuleDeclaration = isTSModuleDeclaration;
      exports.isTSNamedTupleMember = isTSNamedTupleMember;
      exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
      exports.isTSNeverKeyword = isTSNeverKeyword;
      exports.isTSNonNullExpression = isTSNonNullExpression;
      exports.isTSNullKeyword = isTSNullKeyword;
      exports.isTSNumberKeyword = isTSNumberKeyword;
      exports.isTSObjectKeyword = isTSObjectKeyword;
      exports.isTSOptionalType = isTSOptionalType;
      exports.isTSParameterProperty = isTSParameterProperty;
      exports.isTSParenthesizedType = isTSParenthesizedType;
      exports.isTSPropertySignature = isTSPropertySignature;
      exports.isTSQualifiedName = isTSQualifiedName;
      exports.isTSRestType = isTSRestType;
      exports.isTSStringKeyword = isTSStringKeyword;
      exports.isTSSymbolKeyword = isTSSymbolKeyword;
      exports.isTSThisType = isTSThisType;
      exports.isTSTupleType = isTSTupleType;
      exports.isTSType = isTSType;
      exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
      exports.isTSTypeAnnotation = isTSTypeAnnotation;
      exports.isTSTypeAssertion = isTSTypeAssertion;
      exports.isTSTypeElement = isTSTypeElement;
      exports.isTSTypeLiteral = isTSTypeLiteral;
      exports.isTSTypeOperator = isTSTypeOperator;
      exports.isTSTypeParameter = isTSTypeParameter;
      exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
      exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
      exports.isTSTypePredicate = isTSTypePredicate;
      exports.isTSTypeQuery = isTSTypeQuery;
      exports.isTSTypeReference = isTSTypeReference;
      exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
      exports.isTSUnionType = isTSUnionType;
      exports.isTSUnknownKeyword = isTSUnknownKeyword;
      exports.isTSVoidKeyword = isTSVoidKeyword;
      exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
      exports.isTemplateElement = isTemplateElement;
      exports.isTemplateLiteral = isTemplateLiteral;
      exports.isTerminatorless = isTerminatorless;
      exports.isThisExpression = isThisExpression;
      exports.isThisTypeAnnotation = isThisTypeAnnotation;
      exports.isThrowStatement = isThrowStatement;
      exports.isTopicReference = isTopicReference;
      exports.isTryStatement = isTryStatement;
      exports.isTupleExpression = isTupleExpression;
      exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
      exports.isTypeAlias = isTypeAlias;
      exports.isTypeAnnotation = isTypeAnnotation;
      exports.isTypeCastExpression = isTypeCastExpression;
      exports.isTypeParameter = isTypeParameter;
      exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
      exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
      exports.isTypeScript = isTypeScript;
      exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
      exports.isUnaryExpression = isUnaryExpression;
      exports.isUnaryLike = isUnaryLike;
      exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
      exports.isUpdateExpression = isUpdateExpression;
      exports.isUserWhitespacable = isUserWhitespacable;
      exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
      exports.isVariableDeclaration = isVariableDeclaration;
      exports.isVariableDeclarator = isVariableDeclarator;
      exports.isVariance = isVariance;
      exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
      exports.isWhile = isWhile;
      exports.isWhileStatement = isWhileStatement;
      exports.isWithStatement = isWithStatement;
      exports.isYieldExpression = isYieldExpression;
      var _shallowEqual = require_shallowEqual();
      function isArrayExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAssignmentExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AssignmentExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBinaryExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BinaryExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterpreterDirective(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterpreterDirective") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDirective(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Directive") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDirectiveLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DirectiveLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlockStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BlockStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBreakStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BreakStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCallExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "CallExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCatchClause(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "CatchClause") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isConditionalExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ConditionalExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isContinueStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ContinueStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDebuggerStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DebuggerStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDoWhileStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DoWhileStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEmptyStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EmptyStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpressionStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExpressionStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFile(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "File") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForInStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForInStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Identifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIfStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IfStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLabeledStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "LabeledStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumericLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumericLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRegExpLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RegExpLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLogicalExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "LogicalExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMemberExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNewExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NewExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isProgram(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Program") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRestElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RestElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isReturnStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ReturnStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSequenceExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SequenceExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isParenthesizedExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ParenthesizedExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSwitchCase(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SwitchCase") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSwitchStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SwitchStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThisExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThisExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThrowStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThrowStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTryStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TryStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnaryExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UnaryExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUpdateExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UpdateExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariableDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VariableDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariableDeclarator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VariableDeclarator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWhileStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "WhileStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWithStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "WithStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAssignmentPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AssignmentPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrayPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrowFunctionExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrowFunctionExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportAllDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportAllDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDefaultDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportDefaultDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportNamedDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportNamedDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForOfStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ForOfStatement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportDefaultSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportDefaultSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportNamespaceSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportNamespaceSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMetaProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MetaProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectPattern") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSpreadElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SpreadElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSuper(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Super") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTaggedTemplateExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TaggedTemplateExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTemplateElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TemplateElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTemplateLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TemplateLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isYieldExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "YieldExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAwaitExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AwaitExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImport(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Import") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBigIntLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BigIntLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportNamespaceSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportNamespaceSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalMemberExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalMemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalCallExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalCallExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassAccessorProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassAccessorProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassPrivateProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassPrivateProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassPrivateMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassPrivateMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPrivateName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PrivateName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStaticBlock(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StaticBlock") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAnyTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "AnyTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArrayTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArrayTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBooleanLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BooleanLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClassImplements(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ClassImplements") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareClass(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareClass") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareInterface(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareInterface") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareModule(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareModule") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareModuleExports(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareModuleExports") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareTypeAlias(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareTypeAlias") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareOpaqueType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareOpaqueType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareVariable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareVariable") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareExportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclareExportAllDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclareExportAllDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclaredPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DeclaredPredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExistsTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExistsTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionTypeParam(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "FunctionTypeParam") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isGenericTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "GenericTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInferredPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InferredPredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceExtends(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceExtends") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isInterfaceTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "InterfaceTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIntersectionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IntersectionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMixedTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "MixedTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEmptyTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EmptyTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNullableTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NullableTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeInternalSlot(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeInternalSlot") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeCallProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeCallProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeIndexer(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeIndexer") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectTypeSpreadProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ObjectTypeSpreadProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOpaqueType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OpaqueType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isQualifiedTypeIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "QualifiedTypeIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringLiteralTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringLiteralTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStringTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "StringTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSymbolTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SymbolTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isThisTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ThisTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTupleTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TupleTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeofTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeofTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeAlias(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeAlias") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeCastExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeCastExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameter(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameter") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameterDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameterDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeParameterInstantiation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TypeParameterInstantiation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnionTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "UnionTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVariance(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Variance") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isVoidTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "VoidTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBooleanBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumBooleanBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumNumberBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumNumberBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumStringBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumStringBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumSymbolBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumSymbolBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBooleanMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumBooleanMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumNumberMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumNumberMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumStringMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumStringMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumDefaultedMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "EnumDefaultedMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "IndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isOptionalIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "OptionalIndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXAttribute(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXClosingElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXClosingElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXEmptyExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXEmptyExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXExpressionContainer(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXExpressionContainer") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXSpreadChild(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXSpreadChild") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXMemberExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXMemberExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXNamespacedName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXNamespacedName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXOpeningElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXOpeningElement") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXSpreadAttribute(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXSpreadAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXText(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXText") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXOpeningFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXOpeningFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSXClosingFragment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "JSXClosingFragment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNoop(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Noop") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPlaceholder(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Placeholder") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isV8IntrinsicIdentifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "V8IntrinsicIdentifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isArgumentPlaceholder(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ArgumentPlaceholder") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBindExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "BindExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImportAttribute(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ImportAttribute") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDecorator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "Decorator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDoExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DoExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDefaultSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ExportDefaultSpecifier") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRecordExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RecordExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTupleExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TupleExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDecimalLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "DecimalLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "ModuleExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTopicReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TopicReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelineTopicExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelineTopicExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelineBareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelineBareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPipelinePrimaryTopicReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "PipelinePrimaryTopicReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSParameterProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSParameterProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSDeclareFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSDeclareFunction") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSDeclareMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSDeclareMethod") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSQualifiedName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSQualifiedName") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSCallSignatureDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSCallSignatureDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConstructSignatureDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConstructSignatureDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSPropertySignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSPropertySignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSMethodSignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSMethodSignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIndexSignature(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIndexSignature") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSAnyKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSAnyKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBooleanKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSBooleanKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBigIntKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSBigIntKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIntrinsicKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIntrinsicKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNeverKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNeverKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNullKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNullKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNumberKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNumberKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSObjectKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSObjectKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSStringKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSStringKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSSymbolKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSSymbolKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUndefinedKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUndefinedKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUnknownKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUnknownKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSVoidKeyword(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSVoidKeyword") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSThisType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSThisType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSFunctionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSFunctionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConstructorType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConstructorType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypePredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypePredicate") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeQuery(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeQuery") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSArrayType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSArrayType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTupleType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTupleType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSOptionalType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSOptionalType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSRestType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSRestType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNamedTupleMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNamedTupleMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSUnionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSUnionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIntersectionType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIntersectionType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSConditionalType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSConditionalType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInferType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInferType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSParenthesizedType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSParenthesizedType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeOperator(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeOperator") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSIndexedAccessType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSIndexedAccessType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSMappedType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSMappedType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSLiteralType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSLiteralType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExpressionWithTypeArguments(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExpressionWithTypeArguments") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInterfaceDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInterfaceDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInterfaceBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInterfaceBody") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAliasDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAliasDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSInstantiationExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSInstantiationExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSAsExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSAsExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAssertion(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAssertion") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEnumDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSEnumDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEnumMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSEnumMember") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSModuleDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSModuleDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSModuleBlock(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSModuleBlock") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSImportType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSImportType") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSImportEqualsDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSImportEqualsDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExternalModuleReference(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExternalModuleReference") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNonNullExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNonNullExpression") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSExportAssignment(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSExportAssignment") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSNamespaceExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSNamespaceExportDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeAnnotation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameterInstantiation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameterInstantiation") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameterDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameterDeclaration") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeParameter(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "TSTypeParameter") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStandardized(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpression(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBinary(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isScopable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlockParent(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isBlock(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTerminatorless(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isCompletionStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isConditional(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLoop(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isWhile(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExpressionWrapper(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFor(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isForXStatement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunction(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFunctionParent(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPureish(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPatternLike(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLVal(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSEntityName(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isLiteral(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isImmutable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUserWhitespacable(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMethod(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isObjectMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isProperty(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isUnaryLike(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPattern(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isClass(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isExportDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isModuleSpecifier(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isAccessor(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassAccessorProperty" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isPrivate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlow(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowBaseAnnotation(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowDeclaration(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isFlowPredicate(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumBody(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isEnumMember(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isJSX(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isMiscellaneous(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTypeScript(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSTypeElement(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isTSBaseType(node, opts) {
        if (!node)
          return false;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isNumberLiteral(node, opts) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "NumberLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRegexLiteral(node, opts) {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RegexLiteral") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isRestProperty(node, opts) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "RestProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
      function isSpreadProperty(node, opts) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        if (!node)
          return false;
        const nodeType = node.type;
        if (nodeType === "SpreadProperty") {
          if (typeof opts === "undefined") {
            return true;
          } else {
            return (0, _shallowEqual.default)(node, opts);
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/matchesPattern.js
  var require_matchesPattern = __commonJS({
    "../node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = matchesPattern;
      var _generated = require_generated();
      function matchesPattern(member, match, allowPartial) {
        if (!(0, _generated.isMemberExpression)(member))
          return false;
        const parts = Array.isArray(match) ? match : match.split(".");
        const nodes = [];
        let node;
        for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
          nodes.push(node.property);
        }
        nodes.push(node);
        if (nodes.length < parts.length)
          return false;
        if (!allowPartial && nodes.length > parts.length)
          return false;
        for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
          const node2 = nodes[j];
          let value;
          if ((0, _generated.isIdentifier)(node2)) {
            value = node2.name;
          } else if ((0, _generated.isStringLiteral)(node2)) {
            value = node2.value;
          } else if ((0, _generated.isThisExpression)(node2)) {
            value = "this";
          } else {
            return false;
          }
          if (parts[i] !== value)
            return false;
        }
        return true;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
  var require_buildMatchMemberExpression = __commonJS({
    "../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = buildMatchMemberExpression;
      var _matchesPattern = require_matchesPattern();
      function buildMatchMemberExpression(match, allowPartial) {
        const parts = match.split(".");
        return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
  var require_isReactComponent = __commonJS({
    "../node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _buildMatchMemberExpression = require_buildMatchMemberExpression();
      var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
      var _default = isReactComponent;
      exports.default = _default;
    }
  });

  // ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
  var require_isCompatTag = __commonJS({
    "../node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isCompatTag;
      function isCompatTag(tagName) {
        return !!tagName && /^[a-z]/.test(tagName);
      }
    }
  });

  // ../node_modules/to-fast-properties/index.js
  var require_to_fast_properties = __commonJS({
    "../node_modules/to-fast-properties/index.js"(exports, module) {
      "use strict";
      init_inject();
      var fastProto = null;
      function FastObject(o) {
        if (fastProto !== null && typeof fastProto.property) {
          const result = fastProto;
          fastProto = FastObject.prototype = null;
          return result;
        }
        fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o;
        return new FastObject();
      }
      FastObject();
      module.exports = function toFastproperties(o) {
        return FastObject(o);
      };
    }
  });

  // ../node_modules/@babel/types/lib/validators/isType.js
  var require_isType = __commonJS({
    "../node_modules/@babel/types/lib/validators/isType.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isType;
      var _definitions = require_definitions();
      function isType(nodeType, targetType) {
        if (nodeType === targetType)
          return true;
        if (_definitions.ALIAS_KEYS[targetType])
          return false;
        const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
        if (aliases) {
          if (aliases[0] === nodeType)
            return true;
          for (const alias of aliases) {
            if (nodeType === alias)
              return true;
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
  var require_isPlaceholderType = __commonJS({
    "../node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isPlaceholderType;
      var _definitions = require_definitions();
      function isPlaceholderType(placeholderType, targetType) {
        if (placeholderType === targetType)
          return true;
        const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
        if (aliases) {
          for (const alias of aliases) {
            if (targetType === alias)
              return true;
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/is.js
  var require_is = __commonJS({
    "../node_modules/@babel/types/lib/validators/is.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = is2;
      var _shallowEqual = require_shallowEqual();
      var _isType = require_isType();
      var _isPlaceholderType = require_isPlaceholderType();
      var _definitions = require_definitions();
      function is2(type, node, opts) {
        if (!node)
          return false;
        const matches = (0, _isType.default)(node.type, type);
        if (!matches) {
          if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
            return (0, _isPlaceholderType.default)(node.expectedNode, type);
          }
          return false;
        }
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
    }
  });

  // ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
  var require_identifier = __commonJS({
    "../node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIdentifierChar = isIdentifierChar;
      exports.isIdentifierName = isIdentifierName;
      exports.isIdentifierStart = isIdentifierStart;
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code)
            return false;
          pos += set[i + 1];
          if (pos >= code)
            return true;
        }
        return false;
      }
      function isIdentifierStart(code) {
        if (code < 65)
          return code === 36;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code) {
        if (code < 48)
          return code === 36;
        if (code < 58)
          return true;
        if (code < 65)
          return false;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      function isIdentifierName(name) {
        let isFirst = true;
        for (let i = 0; i < name.length; i++) {
          let cp = name.charCodeAt(i);
          if ((cp & 64512) === 55296 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) {
              return false;
            }
          } else if (!isIdentifierChar(cp)) {
            return false;
          }
        }
        return !isFirst;
      }
    }
  });

  // ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
  var require_keyword = __commonJS({
    "../node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isKeyword = isKeyword;
      exports.isReservedWord = isReservedWord;
      exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
      exports.isStrictBindReservedWord = isStrictBindReservedWord;
      exports.isStrictReservedWord = isStrictReservedWord;
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword(word) {
        return keywords.has(word);
      }
    }
  });

  // ../node_modules/@babel/helper-validator-identifier/lib/index.js
  var require_lib = __commonJS({
    "../node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "isIdentifierChar", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierChar;
        }
      });
      Object.defineProperty(exports, "isIdentifierName", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierName;
        }
      });
      Object.defineProperty(exports, "isIdentifierStart", {
        enumerable: true,
        get: function() {
          return _identifier.isIdentifierStart;
        }
      });
      Object.defineProperty(exports, "isKeyword", {
        enumerable: true,
        get: function() {
          return _keyword.isKeyword;
        }
      });
      Object.defineProperty(exports, "isReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictBindOnlyReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictBindReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictReservedWord", {
        enumerable: true,
        get: function() {
          return _keyword.isStrictReservedWord;
        }
      });
      var _identifier = require_identifier();
      var _keyword = require_keyword();
    }
  });

  // ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
  var require_isValidIdentifier = __commonJS({
    "../node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isValidIdentifier;
      var _helperValidatorIdentifier = require_lib();
      function isValidIdentifier(name, reserved = true) {
        if (typeof name !== "string")
          return false;
        if (reserved) {
          if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
            return false;
          }
        }
        return (0, _helperValidatorIdentifier.isIdentifierName)(name);
      }
    }
  });

  // ../node_modules/@babel/helper-string-parser/lib/index.js
  var require_lib2 = __commonJS({
    "../node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.readCodePoint = readCodePoint;
      exports.readInt = readInt;
      exports.readStringContents = readStringContents;
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let containsInvalid = false;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            let escaped;
            ({
              ch: escaped,
              pos,
              lineStart,
              curLine
            } = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors));
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          containsInvalid,
          lineStart,
          curLine
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code;
            ({
              code,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            let code;
            ({
              code,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCodePoint(code));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = input.charCodeAt(pos);
          let val;
          if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code;
        if (ch === 123) {
          ++pos;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code,
          pos
        };
      }
    }
  });

  // ../node_modules/@babel/types/lib/constants/index.js
  var require_constants = __commonJS({
    "../node_modules/@babel/types/lib/constants/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
      var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
      exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
      var FLATTENABLE_KEYS = ["body", "expressions"];
      exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
      var FOR_INIT_KEYS = ["left", "init"];
      exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
      var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
      exports.COMMENT_KEYS = COMMENT_KEYS;
      var LOGICAL_OPERATORS = ["||", "&&", "??"];
      exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
      var UPDATE_OPERATORS = ["++", "--"];
      exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
      var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
      exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
      var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
      exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
      var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
      exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
      var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
      exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
      var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
      exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
      var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
      exports.BINARY_OPERATORS = BINARY_OPERATORS;
      var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
      exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
      var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
      exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
      var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
      exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
      var STRING_UNARY_OPERATORS = ["typeof"];
      exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
      var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
      exports.UNARY_OPERATORS = UNARY_OPERATORS;
      var INHERIT_KEYS = {
        optional: ["typeAnnotation", "typeParameters", "returnType"],
        force: ["start", "loc", "end"]
      };
      exports.INHERIT_KEYS = INHERIT_KEYS;
      var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
      exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
      var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
      exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
    }
  });

  // ../node_modules/@babel/types/lib/definitions/utils.js
  var require_utils = __commonJS({
    "../node_modules/@babel/types/lib/definitions/utils.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
      exports.arrayOf = arrayOf;
      exports.arrayOfType = arrayOfType;
      exports.assertEach = assertEach;
      exports.assertNodeOrValueType = assertNodeOrValueType;
      exports.assertNodeType = assertNodeType;
      exports.assertOneOf = assertOneOf;
      exports.assertOptionalChainStart = assertOptionalChainStart;
      exports.assertShape = assertShape;
      exports.assertValueType = assertValueType;
      exports.chain = chain;
      exports.default = defineType;
      exports.defineAliasedType = defineAliasedType;
      exports.typeIs = typeIs;
      exports.validate = validate;
      exports.validateArrayOfType = validateArrayOfType;
      exports.validateOptional = validateOptional;
      exports.validateOptionalType = validateOptionalType;
      exports.validateType = validateType;
      var _is = require_is();
      var _validate = require_validate();
      var VISITOR_KEYS = {};
      exports.VISITOR_KEYS = VISITOR_KEYS;
      var ALIAS_KEYS = {};
      exports.ALIAS_KEYS = ALIAS_KEYS;
      var FLIPPED_ALIAS_KEYS = {};
      exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
      var NODE_FIELDS = {};
      exports.NODE_FIELDS = NODE_FIELDS;
      var BUILDER_KEYS = {};
      exports.BUILDER_KEYS = BUILDER_KEYS;
      var DEPRECATED_KEYS = {};
      exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
      var NODE_PARENT_VALIDATIONS = {};
      exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
      function getType(val) {
        if (Array.isArray(val)) {
          return "array";
        } else if (val === null) {
          return "null";
        } else {
          return typeof val;
        }
      }
      function validate(validate2) {
        return {
          validate: validate2
        };
      }
      function typeIs(typeName) {
        return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
      }
      function validateType(typeName) {
        return validate(typeIs(typeName));
      }
      function validateOptional(validate2) {
        return {
          validate: validate2,
          optional: true
        };
      }
      function validateOptionalType(typeName) {
        return {
          validate: typeIs(typeName),
          optional: true
        };
      }
      function arrayOf(elementType) {
        return chain(assertValueType("array"), assertEach(elementType));
      }
      function arrayOfType(typeName) {
        return arrayOf(typeIs(typeName));
      }
      function validateArrayOfType(typeName) {
        return validate(arrayOfType(typeName));
      }
      function assertEach(callback) {
        function validator(node, key, val) {
          if (!Array.isArray(val))
            return;
          for (let i = 0; i < val.length; i++) {
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
            if (false)
              (0, _validate.validateChild)(node, subkey, v);
          }
        }
        validator.each = callback;
        return validator;
      }
      function assertOneOf(...values) {
        function validate2(node, key, val) {
          if (values.indexOf(val) < 0) {
            throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
          }
        }
        validate2.oneOf = values;
        return validate2;
      }
      function assertNodeType(...types) {
        function validate2(node, key, val) {
          for (const type of types) {
            if ((0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node, key, val);
              return;
            }
          }
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
        }
        validate2.oneOfNodeTypes = types;
        return validate2;
      }
      function assertNodeOrValueType(...types) {
        function validate2(node, key, val) {
          for (const type of types) {
            if (getType(val) === type || (0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node, key, val);
              return;
            }
          }
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
        }
        validate2.oneOfNodeOrValueTypes = types;
        return validate2;
      }
      function assertValueType(type) {
        function validate2(node, key, val) {
          const valid = getType(val) === type;
          if (!valid) {
            throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
          }
        }
        validate2.type = type;
        return validate2;
      }
      function assertShape(shape) {
        function validate2(node, key, val) {
          const errors = [];
          for (const property of Object.keys(shape)) {
            try {
              (0, _validate.validateField)(node, property, val[property], shape[property]);
            } catch (error) {
              if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
              }
              throw error;
            }
          }
          if (errors.length) {
            throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
          }
        }
        validate2.shapeOf = shape;
        return validate2;
      }
      function assertOptionalChainStart() {
        function validate2(node) {
          var _current;
          let current = node;
          while (node) {
            const {
              type
            } = current;
            if (type === "OptionalCallExpression") {
              if (current.optional)
                return;
              current = current.callee;
              continue;
            }
            if (type === "OptionalMemberExpression") {
              if (current.optional)
                return;
              current = current.object;
              continue;
            }
            break;
          }
          throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
        }
        return validate2;
      }
      function chain(...fns) {
        function validate2(...args) {
          for (const fn of fns) {
            fn(...args);
          }
        }
        validate2.chainOf = fns;
        if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
          throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
        }
        return validate2;
      }
      var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
      var validFieldKeys = ["default", "optional", "validate"];
      function defineAliasedType(...aliases) {
        return (type, opts = {}) => {
          let defined = opts.aliases;
          if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits)
              defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null ? _defined : defined = [];
            opts.aliases = defined;
          }
          const additional = aliases.filter((a) => !defined.includes(a));
          defined.unshift(...additional);
          return defineType(type, opts);
        };
      }
      function defineType(type, opts = {}) {
        const inherits = opts.inherits && store[opts.inherits] || {};
        let fields = opts.fields;
        if (!fields) {
          fields = {};
          if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys) {
              const field = inherits.fields[key];
              const def = field.default;
              if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
                throw new Error("field defaults can only be primitives or empty arrays currently");
              }
              fields[key] = {
                default: Array.isArray(def) ? [] : def,
                optional: field.optional,
                validate: field.validate
              };
            }
          }
        }
        const visitor = opts.visitor || inherits.visitor || [];
        const aliases = opts.aliases || inherits.aliases || [];
        const builder = opts.builder || inherits.builder || opts.visitor || [];
        for (const k of Object.keys(opts)) {
          if (validTypeOpts.indexOf(k) === -1) {
            throw new Error(`Unknown type option "${k}" on ${type}`);
          }
        }
        if (opts.deprecatedAlias) {
          DEPRECATED_KEYS[opts.deprecatedAlias] = type;
        }
        for (const key of visitor.concat(builder)) {
          fields[key] = fields[key] || {};
        }
        for (const key of Object.keys(fields)) {
          const field = fields[key];
          if (field.default !== void 0 && builder.indexOf(key) === -1) {
            field.optional = true;
          }
          if (field.default === void 0) {
            field.default = null;
          } else if (!field.validate && field.default != null) {
            field.validate = assertValueType(getType(field.default));
          }
          for (const k of Object.keys(field)) {
            if (validFieldKeys.indexOf(k) === -1) {
              throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
            }
          }
        }
        VISITOR_KEYS[type] = opts.visitor = visitor;
        BUILDER_KEYS[type] = opts.builder = builder;
        NODE_FIELDS[type] = opts.fields = fields;
        ALIAS_KEYS[type] = opts.aliases = aliases;
        aliases.forEach((alias) => {
          FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
          FLIPPED_ALIAS_KEYS[alias].push(type);
        });
        if (opts.validate) {
          NODE_PARENT_VALIDATIONS[type] = opts.validate;
        }
        store[type] = opts;
      }
      var store = {};
    }
  });

  // ../node_modules/@babel/types/lib/definitions/core.js
  var require_core = __commonJS({
    "../node_modules/@babel/types/lib/definitions/core.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
      var _is = require_is();
      var _isValidIdentifier = require_isValidIdentifier();
      var _helperValidatorIdentifier = require_lib();
      var _helperStringParser = require_lib2();
      var _constants = require_constants();
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("Standardized");
      defineType("ArrayExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: true ? [] : void 0
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      defineType("AssignmentExpression", {
        fields: {
          operator: {
            validate: function() {
              if (true) {
                return (0, _utils.assertValueType)("string");
              }
              const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
              const pattern = (0, _utils.assertOneOf)("=");
              return function(node, key, val) {
                const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
                validator(node, key, val);
              };
            }()
          },
          left: {
            validate: true ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Expression"]
      });
      defineType("BinaryExpression", {
        builder: ["operator", "left", "right"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
          },
          left: {
            validate: function() {
              const expression = (0, _utils.assertNodeType)("Expression");
              const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
              const validator = Object.assign(function(node, key, val) {
                const validator2 = node.operator === "in" ? inOp : expression;
                validator2(node, key, val);
              }, {
                oneOfNodeTypes: ["Expression", "PrivateName"]
              });
              return validator;
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"]
      });
      defineType("InterpreterDirective", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("Directive", {
        visitor: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
          }
        }
      });
      defineType("DirectiveLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("BlockStatement", {
        builder: ["body", "directives"],
        visitor: ["directives", "body"],
        fields: {
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "Block", "Statement"]
      });
      defineType("BreakStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("CallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments"],
        aliases: ["Expression"],
        fields: Object.assign({
          callee: {
            validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          }
        }, true ? {
          optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
          }
        } : {}, {
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
          }
        })
      });
      defineType("CatchClause", {
        visitor: ["param", "body"],
        fields: {
          param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        },
        aliases: ["Scopable", "BlockParent"]
      });
      defineType("ConditionalExpression", {
        visitor: ["test", "consequent", "alternate"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression", "Conditional"]
      });
      defineType("ContinueStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("DebuggerStatement", {
        aliases: ["Statement"]
      });
      defineType("DoWhileStatement", {
        visitor: ["test", "body"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        },
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
      });
      defineType("EmptyStatement", {
        aliases: ["Statement"]
      });
      defineType("ExpressionStatement", {
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Statement", "ExpressionWrapper"]
      });
      defineType("File", {
        builder: ["program", "comments", "tokens"],
        visitor: ["program"],
        fields: {
          program: {
            validate: (0, _utils.assertNodeType)("Program")
          },
          comments: {
            validate: true ? Object.assign(() => {
            }, {
              each: {
                oneOfNodeTypes: ["CommentBlock", "CommentLine"]
              }
            }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
            optional: true
          },
          tokens: {
            validate: (0, _utils.assertEach)(Object.assign(() => {
            }, {
              type: "any"
            })),
            optional: true
          }
        }
      });
      defineType("ForInStatement", {
        visitor: ["left", "right", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
          left: {
            validate: true ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("ForStatement", {
        visitor: ["init", "test", "update", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
        fields: {
          init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
          },
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      var functionCommon = () => ({
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
        },
        generator: {
          default: false
        },
        async: {
          default: false
        }
      });
      exports.functionCommon = functionCommon;
      var functionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        }
      });
      exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
      var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      });
      exports.functionDeclarationCommon = functionDeclarationCommon;
      defineType("FunctionDeclaration", {
        builder: ["id", "params", "body", "generator", "async"],
        visitor: ["id", "params", "body", "returnType", "typeParameters"],
        fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        }),
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
        validate: function() {
          if (true)
            return () => {
            };
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
              identifier(node, "id", node.id);
            }
          };
        }()
      });
      defineType("FunctionExpression", {
        inherits: "FunctionDeclaration",
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        })
      });
      var patternLikeCommon = () => ({
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      });
      exports.patternLikeCommon = patternLikeCommon;
      defineType("Identifier", {
        builder: ["name"],
        visitor: ["typeAnnotation", "decorators"],
        aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
        fields: Object.assign({}, patternLikeCommon(), {
          name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
              if (true)
                return;
              if (!(0, _isValidIdentifier.default)(val, false)) {
                throw new TypeError(`"${val}" is not a valid identifier name`);
              }
            }, {
              type: "string"
            }))
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        }),
        validate(parent, key, node) {
          if (true)
            return;
          const match = /\.(\w+)$/.exec(key);
          if (!match)
            return;
          const [, parentKey] = match;
          const nonComp = {
            computed: false
          };
          if (parentKey === "property") {
            if ((0, _is.default)("MemberExpression", parent, nonComp))
              return;
            if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
              return;
          } else if (parentKey === "key") {
            if ((0, _is.default)("Property", parent, nonComp))
              return;
            if ((0, _is.default)("Method", parent, nonComp))
              return;
          } else if (parentKey === "exported") {
            if ((0, _is.default)("ExportSpecifier", parent))
              return;
          } else if (parentKey === "imported") {
            if ((0, _is.default)("ImportSpecifier", parent, {
              imported: node
            }))
              return;
          } else if (parentKey === "meta") {
            if ((0, _is.default)("MetaProperty", parent, {
              meta: node
            }))
              return;
          }
          if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
            throw new TypeError(`"${node.name}" is not a valid identifier`);
          }
        }
      });
      defineType("IfStatement", {
        visitor: ["test", "consequent", "alternate"],
        aliases: ["Statement", "Conditional"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("LabeledStatement", {
        visitor: ["label", "body"],
        aliases: ["Statement"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("StringLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NumericLiteral", {
        builder: ["value"],
        deprecatedAlias: "NumberLiteral",
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("number")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NullLiteral", {
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("BooleanLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("boolean")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("RegExpLiteral", {
        builder: ["pattern", "flags"],
        deprecatedAlias: "RegexLiteral",
        aliases: ["Expression", "Pureish", "Literal"],
        fields: {
          pattern: {
            validate: (0, _utils.assertValueType)("string")
          },
          flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
              if (true)
                return;
              const invalid = /[^gimsuy]/.exec(val);
              if (invalid) {
                throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
              }
            }, {
              type: "string"
            })),
            default: ""
          }
        }
      });
      defineType("LogicalExpression", {
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
          },
          left: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("MemberExpression", {
        builder: ["object", "property", "computed", ...true ? ["optional"] : []],
        visitor: ["object", "property"],
        aliases: ["Expression", "LVal"],
        fields: Object.assign({
          object: {
            validate: (0, _utils.assertNodeType)("Expression", "Super")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
              const computed = (0, _utils.assertNodeType)("Expression");
              const validator = function(node, key, val) {
                const validator2 = node.computed ? computed : normal;
                validator2(node, key, val);
              };
              validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
              return validator;
            }()
          },
          computed: {
            default: false
          }
        }, true ? {
          optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
          }
        } : {})
      });
      defineType("NewExpression", {
        inherits: "CallExpression"
      });
      defineType("Program", {
        visitor: ["directives", "body"],
        builder: ["body", "directives", "sourceType", "interpreter"],
        fields: {
          sourceFile: {
            validate: (0, _utils.assertValueType)("string")
          },
          sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
          },
          interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
          },
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "Block"]
      });
      defineType("ObjectExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
          }
        }
      });
      defineType("ObjectMethod", {
        builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }, true ? {
            default: "method"
          } : {}),
          computed: {
            default: false
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
              const computed = (0, _utils.assertNodeType)("Expression");
              const validator = function(node, key, val) {
                const validator2 = node.computed ? computed : normal;
                validator2(node, key, val);
              };
              validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
              return validator;
            }()
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }),
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
      });
      defineType("ObjectProperty", {
        builder: ["key", "value", "computed", "shorthand", ...true ? ["decorators"] : []],
        fields: {
          computed: {
            default: false
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
              const computed = (0, _utils.assertNodeType)("Expression");
              const validator = Object.assign(function(node, key, val) {
                const validator2 = node.computed ? computed : normal;
                validator2(node, key, val);
              }, {
                oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
              });
              return validator;
            }()
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
          },
          shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
              if (true)
                return;
              if (val && node.computed) {
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
              }
            }, {
              type: "boolean"
            }), function(node, key, val) {
              if (true)
                return;
              if (val && !(0, _is.default)("Identifier", node.key)) {
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
              }
            }),
            default: false
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        },
        visitor: ["key", "value", "decorators"],
        aliases: ["UserWhitespacable", "Property", "ObjectMember"],
        validate: function() {
          const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSNonNullExpression", "TSTypeAssertion");
          const expression = (0, _utils.assertNodeType)("Expression");
          return function(parent, key, node) {
            if (true)
              return;
            const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
            validator(node, "value", node.value);
          };
        }()
      });
      defineType("RestElement", {
        visitor: ["argument", "typeAnnotation"],
        builder: ["argument"],
        aliases: ["LVal", "PatternLike"],
        deprecatedAlias: "RestProperty",
        fields: Object.assign({}, patternLikeCommon(), {
          argument: {
            validate: true ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        }),
        validate(parent, key) {
          if (true)
            return;
          const match = /(\w+)\[(\d+)\]/.exec(key);
          if (!match)
            throw new Error("Internal Babel error: malformed key.");
          const [, listKey, index] = match;
          if (parent[listKey].length > +index + 1) {
            throw new TypeError(`RestElement must be last element of ${listKey}`);
          }
        }
      });
      defineType("ReturnStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          }
        }
      });
      defineType("SequenceExpression", {
        visitor: ["expressions"],
        fields: {
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
          }
        },
        aliases: ["Expression"]
      });
      defineType("ParenthesizedExpression", {
        visitor: ["expression"],
        aliases: ["Expression", "ExpressionWrapper"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("SwitchCase", {
        visitor: ["test", "consequent"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        }
      });
      defineType("SwitchStatement", {
        visitor: ["discriminant", "cases"],
        aliases: ["Statement", "BlockParent", "Scopable"],
        fields: {
          discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
          }
        }
      });
      defineType("ThisExpression", {
        aliases: ["Expression"]
      });
      defineType("ThrowStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("TryStatement", {
        visitor: ["block", "handler", "finalizer"],
        aliases: ["Statement"],
        fields: {
          block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
              if (true)
                return;
              if (!node.handler && !node.finalizer) {
                throw new TypeError("TryStatement expects either a handler or finalizer, or both");
              }
            }, {
              oneOfNodeTypes: ["BlockStatement"]
            }))
          },
          handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
          },
          finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }
      });
      defineType("UnaryExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: {
            default: true
          },
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
          }
        },
        visitor: ["argument"],
        aliases: ["UnaryLike", "Expression"]
      });
      defineType("UpdateExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: {
            default: false
          },
          argument: {
            validate: true ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
          }
        },
        visitor: ["argument"],
        aliases: ["Expression"]
      });
      defineType("VariableDeclaration", {
        builder: ["kind", "declarations"],
        visitor: ["declarations"],
        aliases: ["Statement", "Declaration"],
        fields: {
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const")
          },
          declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
          }
        },
        validate(parent, key, node) {
          if (true)
            return;
          if (!(0, _is.default)("ForXStatement", parent, {
            left: node
          }))
            return;
          if (node.declarations.length !== 1) {
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          }
        }
      });
      defineType("VariableDeclarator", {
        visitor: ["id", "init"],
        fields: {
          id: {
            validate: function() {
              if (true) {
                return (0, _utils.assertNodeType)("LVal");
              }
              const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
              const without = (0, _utils.assertNodeType)("Identifier");
              return function(node, key, val) {
                const validator = node.init ? normal : without;
                validator(node, key, val);
              };
            }()
          },
          definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
          },
          init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("WhileStatement", {
        visitor: ["test", "body"],
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("WithStatement", {
        visitor: ["object", "body"],
        aliases: ["Statement"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("AssignmentPattern", {
        visitor: ["left", "right", "decorators"],
        builder: ["left", "right"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        })
      });
      defineType("ArrayPattern", {
        visitor: ["elements", "typeAnnotation"],
        builder: ["elements"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        })
      });
      defineType("ArrowFunctionExpression", {
        builder: ["params", "body", "async"],
        visitor: ["params", "body", "returnType", "typeParameters"],
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
          expression: {
            validate: (0, _utils.assertValueType)("boolean")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
          },
          predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
          }
        })
      });
      defineType("ClassBody", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
          }
        }
      });
      defineType("ClassExpression", {
        builder: ["id", "superClass", "body", "decorators"],
        visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
        aliases: ["Scopable", "Class", "Expression"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          }
        }
      });
      defineType("ClassDeclaration", {
        inherits: "ClassExpression",
        aliases: ["Scopable", "Class", "Statement", "Declaration"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        },
        validate: function() {
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            if (true)
              return;
            if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
              identifier(node, "id", node.id);
            }
          };
        }()
      });
      defineType("ExportAllDeclaration", {
        visitor: ["source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          }
        }
      });
      defineType("ExportDefaultDeclaration", {
        visitor: ["declaration"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          declaration: {
            validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
        }
      });
      defineType("ExportNamedDeclaration", {
        visitor: ["declaration", "specifiers", "source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
        fields: {
          declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
              if (true)
                return;
              if (val && node.specifiers.length) {
                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
              }
            }, {
              oneOfNodeTypes: ["Declaration"]
            }), function(node, key, val) {
              if (true)
                return;
              if (val && node.source) {
                throw new TypeError("Cannot export a declaration from a source");
              }
            })
          },
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          },
          specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
              const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
              const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
              if (true)
                return sourced;
              return function(node, key, val) {
                const validator = node.source ? sourced : sourceless;
                validator(node, key, val);
              };
            }()))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      });
      defineType("ExportSpecifier", {
        visitor: ["local", "exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("ForOfStatement", {
        visitor: ["left", "right", "body"],
        builder: ["left", "right", "body", "await"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
          left: {
            validate: function() {
              if (true) {
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
              }
              const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
              const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression");
              return function(node, key, val) {
                if ((0, _is.default)("VariableDeclaration", val)) {
                  declaration(node, key, val);
                } else {
                  lval(node, key, val);
                }
              };
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          await: {
            default: false
          }
        }
      });
      defineType("ImportDeclaration", {
        visitor: ["specifiers", "source"],
        aliases: ["Statement", "Declaration", "ModuleDeclaration"],
        fields: {
          assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
          },
          specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        }
      });
      defineType("ImportDefaultSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("ImportNamespaceSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("ImportSpecifier", {
        visitor: ["local", "imported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        }
      });
      defineType("MetaProperty", {
        visitor: ["meta", "property"],
        aliases: ["Expression"],
        fields: {
          meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
              if (true)
                return;
              let property;
              switch (val.name) {
                case "function":
                  property = "sent";
                  break;
                case "new":
                  property = "target";
                  break;
                case "import":
                  property = "meta";
                  break;
              }
              if (!(0, _is.default)("Identifier", node.property, {
                name: property
              })) {
                throw new TypeError("Unrecognised MetaProperty");
              }
            }, {
              oneOfNodeTypes: ["Identifier"]
            }))
          },
          property: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      var classMethodOrPropertyCommon = () => ({
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        static: {
          default: false
        },
        override: {
          default: false
        },
        computed: {
          default: false
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
        }
      });
      exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
      var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
        },
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
          default: "method"
        },
        access: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      });
      exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
      defineType("ClassMethod", {
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
        builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      });
      defineType("ObjectPattern", {
        visitor: ["properties", "typeAnnotation", "decorators"],
        builder: ["properties"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
          }
        })
      });
      defineType("SpreadElement", {
        visitor: ["argument"],
        aliases: ["UnaryLike"],
        deprecatedAlias: "SpreadProperty",
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("Super", {
        aliases: ["Expression"]
      });
      defineType("TaggedTemplateExpression", {
        visitor: ["tag", "quasi", "typeParameters"],
        builder: ["tag", "quasi"],
        aliases: ["Expression"],
        fields: {
          tag: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("TemplateElement", {
        builder: ["value", "tail"],
        fields: {
          value: {
            validate: (0, _utils.chain)((0, _utils.assertShape)({
              raw: {
                validate: (0, _utils.assertValueType)("string")
              },
              cooked: {
                validate: (0, _utils.assertValueType)("string"),
                optional: true
              }
            }), function templateElementCookedValidator(node) {
              const raw = node.value.raw;
              let str, containsInvalid, unterminatedCalled = false;
              try {
                const error = () => {
                  throw new Error();
                };
                ({
                  str,
                  containsInvalid
                } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
                  unterminated() {
                    unterminatedCalled = true;
                  },
                  strictNumericEscape: error,
                  invalidEscapeSequence: error,
                  numericSeparatorInEscapeSequence: error,
                  unexpectedNumericSeparator: error,
                  invalidDigit: error,
                  invalidCodePoint: error
                }));
              } catch (_unused) {
                unterminatedCalled = true;
                containsInvalid = true;
              }
              if (!unterminatedCalled)
                throw new Error("Invalid raw");
              node.value.cooked = containsInvalid ? null : str;
            })
          },
          tail: {
            default: false
          }
        }
      });
      defineType("TemplateLiteral", {
        visitor: ["quasis", "expressions"],
        aliases: ["Expression", "Literal"],
        fields: {
          quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
          },
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
              if (node.quasis.length !== val.length + 1) {
                throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
              }
            })
          }
        }
      });
      defineType("YieldExpression", {
        builder: ["argument", "delegate"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
              if (true)
                return;
              if (val && !node.argument) {
                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
              }
            }, {
              type: "boolean"
            })),
            default: false
          },
          argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("AwaitExpression", {
        builder: ["argument"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("Import", {
        aliases: ["Expression"]
      });
      defineType("BigIntLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("ExportNamespaceSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("OptionalMemberExpression", {
        builder: ["object", "property", "computed", "optional"],
        visitor: ["object", "property"],
        aliases: ["Expression"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier");
              const computed = (0, _utils.assertNodeType)("Expression");
              const validator = Object.assign(function(node, key, val) {
                const validator2 = node.computed ? computed : normal;
                validator2(node, key, val);
              }, {
                oneOfNodeTypes: ["Expression", "Identifier"]
              });
              return validator;
            }()
          },
          computed: {
            default: false
          },
          optional: {
            validate: true ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
          }
        }
      });
      defineType("OptionalCallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments", "optional"],
        aliases: ["Expression"],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          },
          optional: {
            validate: true ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
          },
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("ClassProperty", {
        visitor: ["key", "value", "typeAnnotation", "decorators"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassAccessorProperty", {
        visitor: ["key", "value", "typeAnnotation", "decorators"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property", "Accessor"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          key: {
            validate: (0, _utils.chain)(function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
              const computed = (0, _utils.assertNodeType)("Expression");
              return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
              };
            }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassPrivateProperty", {
        visitor: ["key", "value", "decorators", "typeAnnotation"],
        builder: ["key", "value", "decorators", "static"],
        aliases: ["Property", "Private"],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          },
          static: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        }
      });
      defineType("ClassPrivateMethod", {
        builder: ["kind", "key", "params", "body", "static"],
        visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
          kind: {
            validate: (0, _utils.assertOneOf)("get", "set", "method"),
            default: "method"
          },
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      });
      defineType("PrivateName", {
        visitor: ["id"],
        aliases: ["Private"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      defineType("StaticBlock", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
          }
        },
        aliases: ["Scopable", "BlockParent", "FunctionParent"]
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/flow.js
  var require_flow = __commonJS({
    "../node_modules/@babel/types/lib/definitions/flow.js"() {
      "use strict";
      init_inject();
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("Flow");
      var defineInterfaceishType = (name) => {
        defineType(name, {
          builder: ["id", "typeParameters", "extends", "body"],
          visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
          aliases: ["FlowDeclaration", "Statement", "Declaration"],
          fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
          }
        });
      };
      defineType("AnyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ArrayTypeAnnotation", {
        visitor: ["elementType"],
        aliases: ["FlowType"],
        fields: {
          elementType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("BooleanTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("BooleanLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("NullLiteralTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ClassImplements", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineInterfaceishType("DeclareClass");
      defineType("DeclareFunction", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
        }
      });
      defineInterfaceishType("DeclareInterface");
      defineType("DeclareModule", {
        builder: ["id", "body", "kind"],
        visitor: ["id", "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          body: (0, _utils.validateType)("BlockStatement"),
          kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
        }
      });
      defineType("DeclareModuleExports", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      });
      defineType("DeclareTypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("DeclareOpaqueType", {
        visitor: ["id", "typeParameters", "supertype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateOptionalType)("FlowType")
        }
      });
      defineType("DeclareVariable", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("DeclareExportDeclaration", {
        visitor: ["declaration", "specifiers", "source"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          declaration: (0, _utils.validateOptionalType)("Flow"),
          specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
          source: (0, _utils.validateOptionalType)("StringLiteral"),
          default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("DeclareExportAllDeclaration", {
        visitor: ["source"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          source: (0, _utils.validateType)("StringLiteral"),
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      });
      defineType("DeclaredPredicate", {
        visitor: ["value"],
        aliases: ["FlowPredicate"],
        fields: {
          value: (0, _utils.validateType)("Flow")
        }
      });
      defineType("ExistsTypeAnnotation", {
        aliases: ["FlowType"]
      });
      defineType("FunctionTypeAnnotation", {
        visitor: ["typeParameters", "params", "rest", "returnType"],
        aliases: ["FlowType"],
        fields: {
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
          rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          returnType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("FunctionTypeParam", {
        visitor: ["name", "typeAnnotation"],
        fields: {
          name: (0, _utils.validateOptionalType)("Identifier"),
          typeAnnotation: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("GenericTypeAnnotation", {
        visitor: ["id", "typeParameters"],
        aliases: ["FlowType"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineType("InferredPredicate", {
        aliases: ["FlowPredicate"]
      });
      defineType("InterfaceExtends", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      });
      defineInterfaceishType("InterfaceDeclaration");
      defineType("InterfaceTypeAnnotation", {
        visitor: ["extends", "body"],
        aliases: ["FlowType"],
        fields: {
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      });
      defineType("IntersectionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("MixedTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EmptyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("NullableTypeAnnotation", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowType"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("NumberLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
        }
      });
      defineType("NumberTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ObjectTypeAnnotation", {
        visitor: ["properties", "indexers", "callProperties", "internalSlots"],
        aliases: ["FlowType"],
        builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
        fields: {
          properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
          indexers: {
            validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
            optional: true,
            default: []
          },
          callProperties: {
            validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
            optional: true,
            default: []
          },
          internalSlots: {
            validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
            optional: true,
            default: []
          },
          exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeInternalSlot", {
        visitor: ["id", "value", "optional", "static", "method"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          value: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeCallProperty", {
        visitor: ["value"],
        aliases: ["UserWhitespacable"],
        fields: {
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeIndexer", {
        visitor: ["id", "key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateOptionalType)("Identifier"),
          key: (0, _utils.validateType)("FlowType"),
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("ObjectTypeProperty", {
        visitor: ["key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          value: (0, _utils.validateType)("FlowType"),
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance"),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeSpreadProperty", {
        visitor: ["argument"],
        aliases: ["UserWhitespacable"],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("OpaqueType", {
        visitor: ["id", "typeParameters", "supertype", "impltype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("QualifiedTypeIdentifier", {
        visitor: ["id", "qualification"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
        }
      });
      defineType("StringLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
        }
      });
      defineType("StringTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("SymbolTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ThisTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("TupleTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("TypeofTypeAnnotation", {
        visitor: ["argument"],
        aliases: ["FlowType"],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeCastExpression", {
        visitor: ["expression", "typeAnnotation"],
        aliases: ["ExpressionWrapper", "Expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      });
      defineType("TypeParameter", {
        visitor: ["bound", "default", "variance"],
        fields: {
          name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
          default: (0, _utils.validateOptionalType)("FlowType"),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("TypeParameterDeclaration", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
        }
      });
      defineType("TypeParameterInstantiation", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("UnionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("Variance", {
        builder: ["kind"],
        fields: {
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
        }
      });
      defineType("VoidTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
        }
      });
      defineType("EnumBooleanBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumNumberBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumStringBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumSymbolBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("EnumBooleanMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("BooleanLiteral")
        }
      });
      defineType("EnumNumberMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("NumericLiteral")
        }
      });
      defineType("EnumStringMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("StringLiteral")
        }
      });
      defineType("EnumDefaultedMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("IndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("OptionalIndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/jsx.js
  var require_jsx = __commonJS({
    "../node_modules/@babel/types/lib/definitions/jsx.js"() {
      "use strict";
      init_inject();
      var _utils = require_utils();
      var defineType = (0, _utils.defineAliasedType)("JSX");
      defineType("JSXAttribute", {
        visitor: ["name", "value"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
          },
          value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
          }
        }
      });
      defineType("JSXClosingElement", {
        visitor: ["name"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          }
        }
      });
      defineType("JSXElement", {
        builder: ["openingElement", "closingElement", "children", "selfClosing"],
        visitor: ["openingElement", "children", "closingElement"],
        aliases: ["Immutable", "Expression"],
        fields: Object.assign({
          openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
          },
          closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }, {
          selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        })
      });
      defineType("JSXEmptyExpression", {});
      defineType("JSXExpressionContainer", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
          }
        }
      });
      defineType("JSXSpreadChild", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("JSXIdentifier", {
        builder: ["name"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("JSXMemberExpression", {
        visitor: ["object", "property"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
          },
          property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      });
      defineType("JSXNamespacedName", {
        visitor: ["namespace", "name"],
        fields: {
          namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          },
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      });
      defineType("JSXOpeningElement", {
        builder: ["name", "attributes", "selfClosing"],
        visitor: ["name", "attributes"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          },
          selfClosing: {
            default: false
          },
          attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
          }
        }
      });
      defineType("JSXSpreadAttribute", {
        visitor: ["argument"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("JSXText", {
        aliases: ["Immutable"],
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
      defineType("JSXFragment", {
        builder: ["openingFragment", "closingFragment", "children"],
        visitor: ["openingFragment", "children", "closingFragment"],
        aliases: ["Immutable", "Expression"],
        fields: {
          openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
          },
          closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }
      });
      defineType("JSXOpeningFragment", {
        aliases: ["Immutable"]
      });
      defineType("JSXClosingFragment", {
        aliases: ["Immutable"]
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/placeholders.js
  var require_placeholders = __commonJS({
    "../node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
      var _utils = require_utils();
      var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
      exports.PLACEHOLDERS = PLACEHOLDERS;
      var PLACEHOLDERS_ALIAS = {
        Declaration: ["Statement"],
        Pattern: ["PatternLike", "LVal"]
      };
      exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
      for (const type of PLACEHOLDERS) {
        const alias = _utils.ALIAS_KEYS[type];
        if (alias != null && alias.length)
          PLACEHOLDERS_ALIAS[type] = alias;
      }
      var PLACEHOLDERS_FLIPPED_ALIAS = {};
      exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
      Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
        PLACEHOLDERS_ALIAS[type].forEach((alias) => {
          if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
            PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
          }
          PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
        });
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/misc.js
  var require_misc = __commonJS({
    "../node_modules/@babel/types/lib/definitions/misc.js"() {
      "use strict";
      init_inject();
      var _utils = require_utils();
      var _placeholders = require_placeholders();
      var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
      {
        defineType("Noop", {
          visitor: []
        });
      }
      defineType("Placeholder", {
        visitor: [],
        builder: ["expectedNode", "name"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
          }
        }
      });
      defineType("V8IntrinsicIdentifier", {
        builder: ["name"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/experimental.js
  var require_experimental = __commonJS({
    "../node_modules/@babel/types/lib/definitions/experimental.js"() {
      "use strict";
      init_inject();
      var _utils = require_utils();
      (0, _utils.default)("ArgumentPlaceholder", {});
      (0, _utils.default)("BindExpression", {
        visitor: ["object", "callee"],
        aliases: ["Expression"],
        fields: true ? {
          object: {
            validate: Object.assign(() => {
            }, {
              oneOfNodeTypes: ["Expression"]
            })
          },
          callee: {
            validate: Object.assign(() => {
            }, {
              oneOfNodeTypes: ["Expression"]
            })
          }
        } : {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      (0, _utils.default)("ImportAttribute", {
        visitor: ["key", "value"],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          }
        }
      });
      (0, _utils.default)("Decorator", {
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      (0, _utils.default)("DoExpression", {
        visitor: ["body"],
        builder: ["body", "async"],
        aliases: ["Expression"],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          }
        }
      });
      (0, _utils.default)("ExportDefaultSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      (0, _utils.default)("RecordExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
          }
        }
      });
      (0, _utils.default)("TupleExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      (0, _utils.default)("DecimalLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      (0, _utils.default)("ModuleExpression", {
        visitor: ["body"],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("Program")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("TopicReference", {
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelineTopicExpression", {
        builder: ["expression"],
        visitor: ["expression"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelineBareFunction", {
        builder: ["callee"],
        visitor: ["callee"],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: ["Expression"]
      });
      (0, _utils.default)("PipelinePrimaryTopicReference", {
        aliases: ["Expression"]
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/typescript.js
  var require_typescript = __commonJS({
    "../node_modules/@babel/types/lib/definitions/typescript.js"() {
      "use strict";
      init_inject();
      var _utils = require_utils();
      var _core = require_core();
      var _is = require_is();
      var defineType = (0, _utils.defineAliasedType)("TypeScript");
      var bool = (0, _utils.assertValueType)("boolean");
      var tSFunctionTypeAnnotationCommon = () => ({
        returnType: {
          validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
          optional: true
        }
      });
      defineType("TSParameterProperty", {
        aliases: ["LVal"],
        visitor: ["parameter"],
        fields: {
          accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
          },
          override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
          }
        }
      });
      defineType("TSDeclareFunction", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
      });
      defineType("TSDeclareMethod", {
        visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
      });
      defineType("TSQualifiedName", {
        aliases: ["TSEntityName"],
        visitor: ["left", "right"],
        fields: {
          left: (0, _utils.validateType)("TSEntityName"),
          right: (0, _utils.validateType)("Identifier")
        }
      });
      var signatureDeclarationCommon = () => ({
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        ["parameters"]: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
        ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      });
      var callConstructSignatureDeclaration = {
        aliases: ["TSTypeElement"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"],
        fields: signatureDeclarationCommon()
      };
      defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
      defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
      var namedTypeElementCommon = () => ({
        key: (0, _utils.validateType)("Expression"),
        computed: {
          default: false
        },
        optional: (0, _utils.validateOptional)(bool)
      });
      defineType("TSPropertySignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeAnnotation", "initializer"],
        fields: Object.assign({}, namedTypeElementCommon(), {
          readonly: (0, _utils.validateOptional)(bool),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          initializer: (0, _utils.validateOptionalType)("Expression"),
          kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
          }
        })
      });
      defineType("TSMethodSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
        fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
          kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }
        })
      });
      defineType("TSIndexSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["parameters", "typeAnnotation"],
        fields: {
          readonly: (0, _utils.validateOptional)(bool),
          static: (0, _utils.validateOptional)(bool),
          parameters: (0, _utils.validateArrayOfType)("Identifier"),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
        }
      });
      var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
      for (const type of tsKeywordTypes) {
        defineType(type, {
          aliases: ["TSType", "TSBaseType"],
          visitor: [],
          fields: {}
        });
      }
      defineType("TSThisType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
      var fnOrCtrBase = {
        aliases: ["TSType"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"]
      };
      defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
        fields: signatureDeclarationCommon()
      }));
      defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
        fields: Object.assign({}, signatureDeclarationCommon(), {
          abstract: (0, _utils.validateOptional)(bool)
        })
      }));
      defineType("TSTypeReference", {
        aliases: ["TSType"],
        visitor: ["typeName", "typeParameters"],
        fields: {
          typeName: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSTypePredicate", {
        aliases: ["TSType"],
        visitor: ["parameterName", "typeAnnotation"],
        builder: ["parameterName", "typeAnnotation", "asserts"],
        fields: {
          parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          asserts: (0, _utils.validateOptional)(bool)
        }
      });
      defineType("TSTypeQuery", {
        aliases: ["TSType"],
        visitor: ["exprName", "typeParameters"],
        fields: {
          exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSTypeLiteral", {
        aliases: ["TSType"],
        visitor: ["members"],
        fields: {
          members: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      });
      defineType("TSArrayType", {
        aliases: ["TSType"],
        visitor: ["elementType"],
        fields: {
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSTupleType", {
        aliases: ["TSType"],
        visitor: ["elementTypes"],
        fields: {
          elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
        }
      });
      defineType("TSOptionalType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSRestType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSNamedTupleMember", {
        visitor: ["label", "elementType"],
        builder: ["label", "elementType", "optional"],
        fields: {
          label: (0, _utils.validateType)("Identifier"),
          optional: {
            validate: bool,
            default: false
          },
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      var unionOrIntersection = {
        aliases: ["TSType"],
        visitor: ["types"],
        fields: {
          types: (0, _utils.validateArrayOfType)("TSType")
        }
      };
      defineType("TSUnionType", unionOrIntersection);
      defineType("TSIntersectionType", unionOrIntersection);
      defineType("TSConditionalType", {
        aliases: ["TSType"],
        visitor: ["checkType", "extendsType", "trueType", "falseType"],
        fields: {
          checkType: (0, _utils.validateType)("TSType"),
          extendsType: (0, _utils.validateType)("TSType"),
          trueType: (0, _utils.validateType)("TSType"),
          falseType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInferType", {
        aliases: ["TSType"],
        visitor: ["typeParameter"],
        fields: {
          typeParameter: (0, _utils.validateType)("TSTypeParameter")
        }
      });
      defineType("TSParenthesizedType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSTypeOperator", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSIndexedAccessType", {
        aliases: ["TSType"],
        visitor: ["objectType", "indexType"],
        fields: {
          objectType: (0, _utils.validateType)("TSType"),
          indexType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSMappedType", {
        aliases: ["TSType"],
        visitor: ["typeParameter", "typeAnnotation", "nameType"],
        fields: {
          readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
          typeParameter: (0, _utils.validateType)("TSTypeParameter"),
          optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
          typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
          nameType: (0, _utils.validateOptionalType)("TSType")
        }
      });
      defineType("TSLiteralType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: ["literal"],
        fields: {
          literal: {
            validate: function() {
              const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
              const unaryOperator = (0, _utils.assertOneOf)("-");
              const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
              function validator(parent, key, node) {
                if ((0, _is.default)("UnaryExpression", node)) {
                  unaryOperator(node, "operator", node.operator);
                  unaryExpression(node, "argument", node.argument);
                } else {
                  literal(parent, key, node);
                }
              }
              validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
              return validator;
            }()
          }
        }
      });
      defineType("TSExpressionWithTypeArguments", {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSInterfaceDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "extends", "body"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
          body: (0, _utils.validateType)("TSInterfaceBody")
        }
      });
      defineType("TSInterfaceBody", {
        visitor: ["body"],
        fields: {
          body: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      });
      defineType("TSTypeAliasDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "typeAnnotation"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInstantiationExpression", {
        aliases: ["Expression"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSAsExpression", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression", "typeAnnotation"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSTypeAssertion", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["typeAnnotation", "expression"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType"),
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSEnumMember", {
        visitor: ["id", "initializer"],
        fields: {
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSModuleDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          global: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
          body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
        }
      });
      defineType("TSModuleBlock", {
        aliases: ["Scopable", "Block", "BlockParent"],
        visitor: ["body"],
        fields: {
          body: (0, _utils.validateArrayOfType)("Statement")
        }
      });
      defineType("TSImportType", {
        aliases: ["TSType"],
        visitor: ["argument", "qualifier", "typeParameters"],
        fields: {
          argument: (0, _utils.validateType)("StringLiteral"),
          qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
      defineType("TSImportEqualsDeclaration", {
        aliases: ["Statement"],
        visitor: ["id", "moduleReference"],
        fields: {
          isExport: (0, _utils.validate)(bool),
          id: (0, _utils.validateType)("Identifier"),
          moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("TSExternalModuleReference", {
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("StringLiteral")
        }
      });
      defineType("TSNonNullExpression", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSExportAssignment", {
        aliases: ["Statement"],
        visitor: ["expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSNamespaceExportDeclaration", {
        aliases: ["Statement"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      });
      defineType("TSTypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
          }
        }
      });
      defineType("TSTypeParameterInstantiation", {
        visitor: ["params"],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
          }
        }
      });
      defineType("TSTypeParameterDeclaration", {
        visitor: ["params"],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
          }
        }
      });
      defineType("TSTypeParameter", {
        builder: ["constraint", "default", "name"],
        visitor: ["constraint", "default"],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          },
          in: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          out: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          },
          default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          }
        }
      });
    }
  });

  // ../node_modules/@babel/types/lib/definitions/index.js
  var require_definitions = __commonJS({
    "../node_modules/@babel/types/lib/definitions/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ALIAS_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.ALIAS_KEYS;
        }
      });
      Object.defineProperty(exports, "BUILDER_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.BUILDER_KEYS;
        }
      });
      Object.defineProperty(exports, "DEPRECATED_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.DEPRECATED_KEYS;
        }
      });
      Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.FLIPPED_ALIAS_KEYS;
        }
      });
      Object.defineProperty(exports, "NODE_FIELDS", {
        enumerable: true,
        get: function() {
          return _utils.NODE_FIELDS;
        }
      });
      Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
        enumerable: true,
        get: function() {
          return _utils.NODE_PARENT_VALIDATIONS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS_ALIAS;
        }
      });
      Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
        enumerable: true,
        get: function() {
          return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
        }
      });
      exports.TYPES = void 0;
      Object.defineProperty(exports, "VISITOR_KEYS", {
        enumerable: true,
        get: function() {
          return _utils.VISITOR_KEYS;
        }
      });
      var _toFastProperties = require_to_fast_properties();
      require_core();
      require_flow();
      require_jsx();
      require_misc();
      require_experimental();
      require_typescript();
      var _utils = require_utils();
      var _placeholders = require_placeholders();
      _toFastProperties(_utils.VISITOR_KEYS);
      _toFastProperties(_utils.ALIAS_KEYS);
      _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
      _toFastProperties(_utils.NODE_FIELDS);
      _toFastProperties(_utils.BUILDER_KEYS);
      _toFastProperties(_utils.DEPRECATED_KEYS);
      _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
      _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
      var TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
      exports.TYPES = TYPES;
    }
  });

  // ../node_modules/@babel/types/lib/validators/validate.js
  var require_validate = __commonJS({
    "../node_modules/@babel/types/lib/validators/validate.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = validate;
      exports.validateChild = validateChild;
      exports.validateField = validateField;
      var _definitions = require_definitions();
      function validate(node, key, val) {
        if (!node)
          return;
        const fields = _definitions.NODE_FIELDS[node.type];
        if (!fields)
          return;
        const field = fields[key];
        validateField(node, key, val, field);
        validateChild(node, key, val);
      }
      function validateField(node, key, val, field) {
        if (!(field != null && field.validate))
          return;
        if (field.optional && val == null)
          return;
        field.validate(node, key, val);
      }
      function validateChild(node, key, val) {
        if (val == null)
          return;
        const validate2 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
        if (!validate2)
          return;
        validate2(node, key, val);
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/validateNode.js
  var require_validateNode = __commonJS({
    "../node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = validateNode;
      var _validate = require_validate();
      var _ = require_lib3();
      function validateNode(node) {
        const keys = _.BUILDER_KEYS[node.type];
        for (const key of keys) {
          (0, _validate.default)(node, key, node[key]);
        }
        return node;
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/generated/index.js
  var require_generated2 = __commonJS({
    "../node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.anyTypeAnnotation = anyTypeAnnotation;
      exports.argumentPlaceholder = argumentPlaceholder;
      exports.arrayExpression = arrayExpression;
      exports.arrayPattern = arrayPattern;
      exports.arrayTypeAnnotation = arrayTypeAnnotation;
      exports.arrowFunctionExpression = arrowFunctionExpression;
      exports.assignmentExpression = assignmentExpression;
      exports.assignmentPattern = assignmentPattern;
      exports.awaitExpression = awaitExpression;
      exports.bigIntLiteral = bigIntLiteral;
      exports.binaryExpression = binaryExpression;
      exports.bindExpression = bindExpression;
      exports.blockStatement = blockStatement;
      exports.booleanLiteral = booleanLiteral;
      exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
      exports.booleanTypeAnnotation = booleanTypeAnnotation;
      exports.breakStatement = breakStatement;
      exports.callExpression = callExpression;
      exports.catchClause = catchClause;
      exports.classAccessorProperty = classAccessorProperty;
      exports.classBody = classBody;
      exports.classDeclaration = classDeclaration;
      exports.classExpression = classExpression;
      exports.classImplements = classImplements;
      exports.classMethod = classMethod;
      exports.classPrivateMethod = classPrivateMethod;
      exports.classPrivateProperty = classPrivateProperty;
      exports.classProperty = classProperty;
      exports.conditionalExpression = conditionalExpression;
      exports.continueStatement = continueStatement;
      exports.debuggerStatement = debuggerStatement;
      exports.decimalLiteral = decimalLiteral;
      exports.declareClass = declareClass;
      exports.declareExportAllDeclaration = declareExportAllDeclaration;
      exports.declareExportDeclaration = declareExportDeclaration;
      exports.declareFunction = declareFunction;
      exports.declareInterface = declareInterface;
      exports.declareModule = declareModule;
      exports.declareModuleExports = declareModuleExports;
      exports.declareOpaqueType = declareOpaqueType;
      exports.declareTypeAlias = declareTypeAlias;
      exports.declareVariable = declareVariable;
      exports.declaredPredicate = declaredPredicate;
      exports.decorator = decorator;
      exports.directive = directive;
      exports.directiveLiteral = directiveLiteral;
      exports.doExpression = doExpression;
      exports.doWhileStatement = doWhileStatement;
      exports.emptyStatement = emptyStatement;
      exports.emptyTypeAnnotation = emptyTypeAnnotation;
      exports.enumBooleanBody = enumBooleanBody;
      exports.enumBooleanMember = enumBooleanMember;
      exports.enumDeclaration = enumDeclaration;
      exports.enumDefaultedMember = enumDefaultedMember;
      exports.enumNumberBody = enumNumberBody;
      exports.enumNumberMember = enumNumberMember;
      exports.enumStringBody = enumStringBody;
      exports.enumStringMember = enumStringMember;
      exports.enumSymbolBody = enumSymbolBody;
      exports.existsTypeAnnotation = existsTypeAnnotation;
      exports.exportAllDeclaration = exportAllDeclaration;
      exports.exportDefaultDeclaration = exportDefaultDeclaration;
      exports.exportDefaultSpecifier = exportDefaultSpecifier;
      exports.exportNamedDeclaration = exportNamedDeclaration;
      exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
      exports.exportSpecifier = exportSpecifier;
      exports.expressionStatement = expressionStatement;
      exports.file = file;
      exports.forInStatement = forInStatement;
      exports.forOfStatement = forOfStatement;
      exports.forStatement = forStatement;
      exports.functionDeclaration = functionDeclaration;
      exports.functionExpression = functionExpression;
      exports.functionTypeAnnotation = functionTypeAnnotation;
      exports.functionTypeParam = functionTypeParam;
      exports.genericTypeAnnotation = genericTypeAnnotation;
      exports.identifier = identifier;
      exports.ifStatement = ifStatement;
      exports.import = _import;
      exports.importAttribute = importAttribute;
      exports.importDeclaration = importDeclaration;
      exports.importDefaultSpecifier = importDefaultSpecifier;
      exports.importNamespaceSpecifier = importNamespaceSpecifier;
      exports.importSpecifier = importSpecifier;
      exports.indexedAccessType = indexedAccessType;
      exports.inferredPredicate = inferredPredicate;
      exports.interfaceDeclaration = interfaceDeclaration;
      exports.interfaceExtends = interfaceExtends;
      exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
      exports.interpreterDirective = interpreterDirective;
      exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
      exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
      exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
      exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
      exports.jSXElement = exports.jsxElement = jsxElement;
      exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
      exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
      exports.jSXFragment = exports.jsxFragment = jsxFragment;
      exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
      exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
      exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
      exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
      exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
      exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
      exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
      exports.jSXText = exports.jsxText = jsxText;
      exports.labeledStatement = labeledStatement;
      exports.logicalExpression = logicalExpression;
      exports.memberExpression = memberExpression;
      exports.metaProperty = metaProperty;
      exports.mixedTypeAnnotation = mixedTypeAnnotation;
      exports.moduleExpression = moduleExpression;
      exports.newExpression = newExpression;
      exports.noop = noop;
      exports.nullLiteral = nullLiteral;
      exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
      exports.nullableTypeAnnotation = nullableTypeAnnotation;
      exports.numberLiteral = NumberLiteral;
      exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
      exports.numberTypeAnnotation = numberTypeAnnotation;
      exports.numericLiteral = numericLiteral;
      exports.objectExpression = objectExpression;
      exports.objectMethod = objectMethod;
      exports.objectPattern = objectPattern;
      exports.objectProperty = objectProperty;
      exports.objectTypeAnnotation = objectTypeAnnotation;
      exports.objectTypeCallProperty = objectTypeCallProperty;
      exports.objectTypeIndexer = objectTypeIndexer;
      exports.objectTypeInternalSlot = objectTypeInternalSlot;
      exports.objectTypeProperty = objectTypeProperty;
      exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
      exports.opaqueType = opaqueType;
      exports.optionalCallExpression = optionalCallExpression;
      exports.optionalIndexedAccessType = optionalIndexedAccessType;
      exports.optionalMemberExpression = optionalMemberExpression;
      exports.parenthesizedExpression = parenthesizedExpression;
      exports.pipelineBareFunction = pipelineBareFunction;
      exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
      exports.pipelineTopicExpression = pipelineTopicExpression;
      exports.placeholder = placeholder;
      exports.privateName = privateName;
      exports.program = program;
      exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
      exports.recordExpression = recordExpression;
      exports.regExpLiteral = regExpLiteral;
      exports.regexLiteral = RegexLiteral;
      exports.restElement = restElement;
      exports.restProperty = RestProperty;
      exports.returnStatement = returnStatement;
      exports.sequenceExpression = sequenceExpression;
      exports.spreadElement = spreadElement;
      exports.spreadProperty = SpreadProperty;
      exports.staticBlock = staticBlock;
      exports.stringLiteral = stringLiteral2;
      exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
      exports.stringTypeAnnotation = stringTypeAnnotation;
      exports.super = _super;
      exports.switchCase = switchCase;
      exports.switchStatement = switchStatement;
      exports.symbolTypeAnnotation = symbolTypeAnnotation;
      exports.taggedTemplateExpression = taggedTemplateExpression;
      exports.templateElement = templateElement2;
      exports.templateLiteral = templateLiteral2;
      exports.thisExpression = thisExpression;
      exports.thisTypeAnnotation = thisTypeAnnotation;
      exports.throwStatement = throwStatement;
      exports.topicReference = topicReference;
      exports.tryStatement = tryStatement;
      exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
      exports.tSArrayType = exports.tsArrayType = tsArrayType;
      exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
      exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
      exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
      exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
      exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
      exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
      exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
      exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
      exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
      exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
      exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
      exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
      exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
      exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
      exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
      exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
      exports.tSImportType = exports.tsImportType = tsImportType;
      exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
      exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
      exports.tSInferType = exports.tsInferType = tsInferType;
      exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
      exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
      exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
      exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
      exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
      exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
      exports.tSMappedType = exports.tsMappedType = tsMappedType;
      exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
      exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
      exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
      exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
      exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
      exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
      exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
      exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
      exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
      exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
      exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
      exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
      exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
      exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
      exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
      exports.tSRestType = exports.tsRestType = tsRestType;
      exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
      exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
      exports.tSThisType = exports.tsThisType = tsThisType;
      exports.tSTupleType = exports.tsTupleType = tsTupleType;
      exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
      exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
      exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
      exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
      exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
      exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
      exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
      exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
      exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
      exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
      exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
      exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
      exports.tSUnionType = exports.tsUnionType = tsUnionType;
      exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
      exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
      exports.tupleExpression = tupleExpression;
      exports.tupleTypeAnnotation = tupleTypeAnnotation;
      exports.typeAlias = typeAlias;
      exports.typeAnnotation = typeAnnotation;
      exports.typeCastExpression = typeCastExpression;
      exports.typeParameter = typeParameter;
      exports.typeParameterDeclaration = typeParameterDeclaration;
      exports.typeParameterInstantiation = typeParameterInstantiation;
      exports.typeofTypeAnnotation = typeofTypeAnnotation;
      exports.unaryExpression = unaryExpression;
      exports.unionTypeAnnotation = unionTypeAnnotation;
      exports.updateExpression = updateExpression;
      exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
      exports.variableDeclaration = variableDeclaration;
      exports.variableDeclarator = variableDeclarator;
      exports.variance = variance;
      exports.voidTypeAnnotation = voidTypeAnnotation;
      exports.whileStatement = whileStatement;
      exports.withStatement = withStatement;
      exports.yieldExpression = yieldExpression;
      var _validateNode = require_validateNode();
      function arrayExpression(elements = []) {
        return (0, _validateNode.default)({
          type: "ArrayExpression",
          elements
        });
      }
      function assignmentExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "AssignmentExpression",
          operator,
          left,
          right
        });
      }
      function binaryExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "BinaryExpression",
          operator,
          left,
          right
        });
      }
      function interpreterDirective(value) {
        return (0, _validateNode.default)({
          type: "InterpreterDirective",
          value
        });
      }
      function directive(value) {
        return (0, _validateNode.default)({
          type: "Directive",
          value
        });
      }
      function directiveLiteral(value) {
        return (0, _validateNode.default)({
          type: "DirectiveLiteral",
          value
        });
      }
      function blockStatement(body, directives = []) {
        return (0, _validateNode.default)({
          type: "BlockStatement",
          body,
          directives
        });
      }
      function breakStatement(label = null) {
        return (0, _validateNode.default)({
          type: "BreakStatement",
          label
        });
      }
      function callExpression(callee, _arguments) {
        return (0, _validateNode.default)({
          type: "CallExpression",
          callee,
          arguments: _arguments
        });
      }
      function catchClause(param = null, body) {
        return (0, _validateNode.default)({
          type: "CatchClause",
          param,
          body
        });
      }
      function conditionalExpression(test, consequent, alternate) {
        return (0, _validateNode.default)({
          type: "ConditionalExpression",
          test,
          consequent,
          alternate
        });
      }
      function continueStatement(label = null) {
        return (0, _validateNode.default)({
          type: "ContinueStatement",
          label
        });
      }
      function debuggerStatement() {
        return {
          type: "DebuggerStatement"
        };
      }
      function doWhileStatement(test, body) {
        return (0, _validateNode.default)({
          type: "DoWhileStatement",
          test,
          body
        });
      }
      function emptyStatement() {
        return {
          type: "EmptyStatement"
        };
      }
      function expressionStatement(expression) {
        return (0, _validateNode.default)({
          type: "ExpressionStatement",
          expression
        });
      }
      function file(program2, comments = null, tokens = null) {
        return (0, _validateNode.default)({
          type: "File",
          program: program2,
          comments,
          tokens
        });
      }
      function forInStatement(left, right, body) {
        return (0, _validateNode.default)({
          type: "ForInStatement",
          left,
          right,
          body
        });
      }
      function forStatement(init = null, test = null, update = null, body) {
        return (0, _validateNode.default)({
          type: "ForStatement",
          init,
          test,
          update,
          body
        });
      }
      function functionDeclaration(id = null, params, body, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "FunctionDeclaration",
          id,
          params,
          body,
          generator,
          async
        });
      }
      function functionExpression(id = null, params, body, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "FunctionExpression",
          id,
          params,
          body,
          generator,
          async
        });
      }
      function identifier(name) {
        return (0, _validateNode.default)({
          type: "Identifier",
          name
        });
      }
      function ifStatement(test, consequent, alternate = null) {
        return (0, _validateNode.default)({
          type: "IfStatement",
          test,
          consequent,
          alternate
        });
      }
      function labeledStatement(label, body) {
        return (0, _validateNode.default)({
          type: "LabeledStatement",
          label,
          body
        });
      }
      function stringLiteral2(value) {
        return (0, _validateNode.default)({
          type: "StringLiteral",
          value
        });
      }
      function numericLiteral(value) {
        return (0, _validateNode.default)({
          type: "NumericLiteral",
          value
        });
      }
      function nullLiteral() {
        return {
          type: "NullLiteral"
        };
      }
      function booleanLiteral(value) {
        return (0, _validateNode.default)({
          type: "BooleanLiteral",
          value
        });
      }
      function regExpLiteral(pattern, flags = "") {
        return (0, _validateNode.default)({
          type: "RegExpLiteral",
          pattern,
          flags
        });
      }
      function logicalExpression(operator, left, right) {
        return (0, _validateNode.default)({
          type: "LogicalExpression",
          operator,
          left,
          right
        });
      }
      function memberExpression(object, property, computed = false, optional = null) {
        return (0, _validateNode.default)({
          type: "MemberExpression",
          object,
          property,
          computed,
          optional
        });
      }
      function newExpression(callee, _arguments) {
        return (0, _validateNode.default)({
          type: "NewExpression",
          callee,
          arguments: _arguments
        });
      }
      function program(body, directives = [], sourceType = "script", interpreter = null) {
        return (0, _validateNode.default)({
          type: "Program",
          body,
          directives,
          sourceType,
          interpreter,
          sourceFile: null
        });
      }
      function objectExpression(properties) {
        return (0, _validateNode.default)({
          type: "ObjectExpression",
          properties
        });
      }
      function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "ObjectMethod",
          kind,
          key,
          params,
          body,
          computed,
          generator,
          async
        });
      }
      function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
        return (0, _validateNode.default)({
          type: "ObjectProperty",
          key,
          value,
          computed,
          shorthand,
          decorators
        });
      }
      function restElement(argument) {
        return (0, _validateNode.default)({
          type: "RestElement",
          argument
        });
      }
      function returnStatement(argument = null) {
        return (0, _validateNode.default)({
          type: "ReturnStatement",
          argument
        });
      }
      function sequenceExpression(expressions) {
        return (0, _validateNode.default)({
          type: "SequenceExpression",
          expressions
        });
      }
      function parenthesizedExpression(expression) {
        return (0, _validateNode.default)({
          type: "ParenthesizedExpression",
          expression
        });
      }
      function switchCase(test = null, consequent) {
        return (0, _validateNode.default)({
          type: "SwitchCase",
          test,
          consequent
        });
      }
      function switchStatement(discriminant, cases) {
        return (0, _validateNode.default)({
          type: "SwitchStatement",
          discriminant,
          cases
        });
      }
      function thisExpression() {
        return {
          type: "ThisExpression"
        };
      }
      function throwStatement(argument) {
        return (0, _validateNode.default)({
          type: "ThrowStatement",
          argument
        });
      }
      function tryStatement(block, handler = null, finalizer = null) {
        return (0, _validateNode.default)({
          type: "TryStatement",
          block,
          handler,
          finalizer
        });
      }
      function unaryExpression(operator, argument, prefix = true) {
        return (0, _validateNode.default)({
          type: "UnaryExpression",
          operator,
          argument,
          prefix
        });
      }
      function updateExpression(operator, argument, prefix = false) {
        return (0, _validateNode.default)({
          type: "UpdateExpression",
          operator,
          argument,
          prefix
        });
      }
      function variableDeclaration(kind, declarations) {
        return (0, _validateNode.default)({
          type: "VariableDeclaration",
          kind,
          declarations
        });
      }
      function variableDeclarator(id, init = null) {
        return (0, _validateNode.default)({
          type: "VariableDeclarator",
          id,
          init
        });
      }
      function whileStatement(test, body) {
        return (0, _validateNode.default)({
          type: "WhileStatement",
          test,
          body
        });
      }
      function withStatement(object, body) {
        return (0, _validateNode.default)({
          type: "WithStatement",
          object,
          body
        });
      }
      function assignmentPattern(left, right) {
        return (0, _validateNode.default)({
          type: "AssignmentPattern",
          left,
          right
        });
      }
      function arrayPattern(elements) {
        return (0, _validateNode.default)({
          type: "ArrayPattern",
          elements
        });
      }
      function arrowFunctionExpression(params, body, async = false) {
        return (0, _validateNode.default)({
          type: "ArrowFunctionExpression",
          params,
          body,
          async,
          expression: null
        });
      }
      function classBody(body) {
        return (0, _validateNode.default)({
          type: "ClassBody",
          body
        });
      }
      function classExpression(id = null, superClass = null, body, decorators = null) {
        return (0, _validateNode.default)({
          type: "ClassExpression",
          id,
          superClass,
          body,
          decorators
        });
      }
      function classDeclaration(id, superClass = null, body, decorators = null) {
        return (0, _validateNode.default)({
          type: "ClassDeclaration",
          id,
          superClass,
          body,
          decorators
        });
      }
      function exportAllDeclaration(source) {
        return (0, _validateNode.default)({
          type: "ExportAllDeclaration",
          source
        });
      }
      function exportDefaultDeclaration(declaration) {
        return (0, _validateNode.default)({
          type: "ExportDefaultDeclaration",
          declaration
        });
      }
      function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
        return (0, _validateNode.default)({
          type: "ExportNamedDeclaration",
          declaration,
          specifiers,
          source
        });
      }
      function exportSpecifier(local, exported) {
        return (0, _validateNode.default)({
          type: "ExportSpecifier",
          local,
          exported
        });
      }
      function forOfStatement(left, right, body, _await = false) {
        return (0, _validateNode.default)({
          type: "ForOfStatement",
          left,
          right,
          body,
          await: _await
        });
      }
      function importDeclaration(specifiers, source) {
        return (0, _validateNode.default)({
          type: "ImportDeclaration",
          specifiers,
          source
        });
      }
      function importDefaultSpecifier(local) {
        return (0, _validateNode.default)({
          type: "ImportDefaultSpecifier",
          local
        });
      }
      function importNamespaceSpecifier(local) {
        return (0, _validateNode.default)({
          type: "ImportNamespaceSpecifier",
          local
        });
      }
      function importSpecifier(local, imported) {
        return (0, _validateNode.default)({
          type: "ImportSpecifier",
          local,
          imported
        });
      }
      function metaProperty(meta, property) {
        return (0, _validateNode.default)({
          type: "MetaProperty",
          meta,
          property
        });
      }
      function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
        return (0, _validateNode.default)({
          type: "ClassMethod",
          kind,
          key,
          params,
          body,
          computed,
          static: _static,
          generator,
          async
        });
      }
      function objectPattern(properties) {
        return (0, _validateNode.default)({
          type: "ObjectPattern",
          properties
        });
      }
      function spreadElement(argument) {
        return (0, _validateNode.default)({
          type: "SpreadElement",
          argument
        });
      }
      function _super() {
        return {
          type: "Super"
        };
      }
      function taggedTemplateExpression(tag, quasi) {
        return (0, _validateNode.default)({
          type: "TaggedTemplateExpression",
          tag,
          quasi
        });
      }
      function templateElement2(value, tail = false) {
        return (0, _validateNode.default)({
          type: "TemplateElement",
          value,
          tail
        });
      }
      function templateLiteral2(quasis, expressions) {
        return (0, _validateNode.default)({
          type: "TemplateLiteral",
          quasis,
          expressions
        });
      }
      function yieldExpression(argument = null, delegate = false) {
        return (0, _validateNode.default)({
          type: "YieldExpression",
          argument,
          delegate
        });
      }
      function awaitExpression(argument) {
        return (0, _validateNode.default)({
          type: "AwaitExpression",
          argument
        });
      }
      function _import() {
        return {
          type: "Import"
        };
      }
      function bigIntLiteral(value) {
        return (0, _validateNode.default)({
          type: "BigIntLiteral",
          value
        });
      }
      function exportNamespaceSpecifier(exported) {
        return (0, _validateNode.default)({
          type: "ExportNamespaceSpecifier",
          exported
        });
      }
      function optionalMemberExpression(object, property, computed = false, optional) {
        return (0, _validateNode.default)({
          type: "OptionalMemberExpression",
          object,
          property,
          computed,
          optional
        });
      }
      function optionalCallExpression(callee, _arguments, optional) {
        return (0, _validateNode.default)({
          type: "OptionalCallExpression",
          callee,
          arguments: _arguments,
          optional
        });
      }
      function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassProperty",
          key,
          value,
          typeAnnotation: typeAnnotation2,
          decorators,
          computed,
          static: _static
        });
      }
      function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassAccessorProperty",
          key,
          value,
          typeAnnotation: typeAnnotation2,
          decorators,
          computed,
          static: _static
        });
      }
      function classPrivateProperty(key, value = null, decorators = null, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassPrivateProperty",
          key,
          value,
          decorators,
          static: _static
        });
      }
      function classPrivateMethod(kind = "method", key, params, body, _static = false) {
        return (0, _validateNode.default)({
          type: "ClassPrivateMethod",
          kind,
          key,
          params,
          body,
          static: _static
        });
      }
      function privateName(id) {
        return (0, _validateNode.default)({
          type: "PrivateName",
          id
        });
      }
      function staticBlock(body) {
        return (0, _validateNode.default)({
          type: "StaticBlock",
          body
        });
      }
      function anyTypeAnnotation() {
        return {
          type: "AnyTypeAnnotation"
        };
      }
      function arrayTypeAnnotation(elementType) {
        return (0, _validateNode.default)({
          type: "ArrayTypeAnnotation",
          elementType
        });
      }
      function booleanTypeAnnotation() {
        return {
          type: "BooleanTypeAnnotation"
        };
      }
      function booleanLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "BooleanLiteralTypeAnnotation",
          value
        });
      }
      function nullLiteralTypeAnnotation() {
        return {
          type: "NullLiteralTypeAnnotation"
        };
      }
      function classImplements(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "ClassImplements",
          id,
          typeParameters
        });
      }
      function declareClass(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "DeclareClass",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function declareFunction(id) {
        return (0, _validateNode.default)({
          type: "DeclareFunction",
          id
        });
      }
      function declareInterface(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "DeclareInterface",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function declareModule(id, body, kind = null) {
        return (0, _validateNode.default)({
          type: "DeclareModule",
          id,
          body,
          kind
        });
      }
      function declareModuleExports(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "DeclareModuleExports",
          typeAnnotation: typeAnnotation2
        });
      }
      function declareTypeAlias(id, typeParameters = null, right) {
        return (0, _validateNode.default)({
          type: "DeclareTypeAlias",
          id,
          typeParameters,
          right
        });
      }
      function declareOpaqueType(id, typeParameters = null, supertype = null) {
        return (0, _validateNode.default)({
          type: "DeclareOpaqueType",
          id,
          typeParameters,
          supertype
        });
      }
      function declareVariable(id) {
        return (0, _validateNode.default)({
          type: "DeclareVariable",
          id
        });
      }
      function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
        return (0, _validateNode.default)({
          type: "DeclareExportDeclaration",
          declaration,
          specifiers,
          source
        });
      }
      function declareExportAllDeclaration(source) {
        return (0, _validateNode.default)({
          type: "DeclareExportAllDeclaration",
          source
        });
      }
      function declaredPredicate(value) {
        return (0, _validateNode.default)({
          type: "DeclaredPredicate",
          value
        });
      }
      function existsTypeAnnotation() {
        return {
          type: "ExistsTypeAnnotation"
        };
      }
      function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
        return (0, _validateNode.default)({
          type: "FunctionTypeAnnotation",
          typeParameters,
          params,
          rest,
          returnType
        });
      }
      function functionTypeParam(name = null, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "FunctionTypeParam",
          name,
          typeAnnotation: typeAnnotation2
        });
      }
      function genericTypeAnnotation(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "GenericTypeAnnotation",
          id,
          typeParameters
        });
      }
      function inferredPredicate() {
        return {
          type: "InferredPredicate"
        };
      }
      function interfaceExtends(id, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "InterfaceExtends",
          id,
          typeParameters
        });
      }
      function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "InterfaceDeclaration",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function interfaceTypeAnnotation(_extends = null, body) {
        return (0, _validateNode.default)({
          type: "InterfaceTypeAnnotation",
          extends: _extends,
          body
        });
      }
      function intersectionTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "IntersectionTypeAnnotation",
          types
        });
      }
      function mixedTypeAnnotation() {
        return {
          type: "MixedTypeAnnotation"
        };
      }
      function emptyTypeAnnotation() {
        return {
          type: "EmptyTypeAnnotation"
        };
      }
      function nullableTypeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "NullableTypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function numberLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "NumberLiteralTypeAnnotation",
          value
        });
      }
      function numberTypeAnnotation() {
        return {
          type: "NumberTypeAnnotation"
        };
      }
      function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
        return (0, _validateNode.default)({
          type: "ObjectTypeAnnotation",
          properties,
          indexers,
          callProperties,
          internalSlots,
          exact
        });
      }
      function objectTypeInternalSlot(id, value, optional, _static, method) {
        return (0, _validateNode.default)({
          type: "ObjectTypeInternalSlot",
          id,
          value,
          optional,
          static: _static,
          method
        });
      }
      function objectTypeCallProperty(value) {
        return (0, _validateNode.default)({
          type: "ObjectTypeCallProperty",
          value,
          static: null
        });
      }
      function objectTypeIndexer(id = null, key, value, variance2 = null) {
        return (0, _validateNode.default)({
          type: "ObjectTypeIndexer",
          id,
          key,
          value,
          variance: variance2,
          static: null
        });
      }
      function objectTypeProperty(key, value, variance2 = null) {
        return (0, _validateNode.default)({
          type: "ObjectTypeProperty",
          key,
          value,
          variance: variance2,
          kind: null,
          method: null,
          optional: null,
          proto: null,
          static: null
        });
      }
      function objectTypeSpreadProperty(argument) {
        return (0, _validateNode.default)({
          type: "ObjectTypeSpreadProperty",
          argument
        });
      }
      function opaqueType(id, typeParameters = null, supertype = null, impltype) {
        return (0, _validateNode.default)({
          type: "OpaqueType",
          id,
          typeParameters,
          supertype,
          impltype
        });
      }
      function qualifiedTypeIdentifier(id, qualification) {
        return (0, _validateNode.default)({
          type: "QualifiedTypeIdentifier",
          id,
          qualification
        });
      }
      function stringLiteralTypeAnnotation(value) {
        return (0, _validateNode.default)({
          type: "StringLiteralTypeAnnotation",
          value
        });
      }
      function stringTypeAnnotation() {
        return {
          type: "StringTypeAnnotation"
        };
      }
      function symbolTypeAnnotation() {
        return {
          type: "SymbolTypeAnnotation"
        };
      }
      function thisTypeAnnotation() {
        return {
          type: "ThisTypeAnnotation"
        };
      }
      function tupleTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "TupleTypeAnnotation",
          types
        });
      }
      function typeofTypeAnnotation(argument) {
        return (0, _validateNode.default)({
          type: "TypeofTypeAnnotation",
          argument
        });
      }
      function typeAlias(id, typeParameters = null, right) {
        return (0, _validateNode.default)({
          type: "TypeAlias",
          id,
          typeParameters,
          right
        });
      }
      function typeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function typeCastExpression(expression, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TypeCastExpression",
          expression,
          typeAnnotation: typeAnnotation2
        });
      }
      function typeParameter(bound = null, _default = null, variance2 = null) {
        return (0, _validateNode.default)({
          type: "TypeParameter",
          bound,
          default: _default,
          variance: variance2,
          name: null
        });
      }
      function typeParameterDeclaration(params) {
        return (0, _validateNode.default)({
          type: "TypeParameterDeclaration",
          params
        });
      }
      function typeParameterInstantiation(params) {
        return (0, _validateNode.default)({
          type: "TypeParameterInstantiation",
          params
        });
      }
      function unionTypeAnnotation(types) {
        return (0, _validateNode.default)({
          type: "UnionTypeAnnotation",
          types
        });
      }
      function variance(kind) {
        return (0, _validateNode.default)({
          type: "Variance",
          kind
        });
      }
      function voidTypeAnnotation() {
        return {
          type: "VoidTypeAnnotation"
        };
      }
      function enumDeclaration(id, body) {
        return (0, _validateNode.default)({
          type: "EnumDeclaration",
          id,
          body
        });
      }
      function enumBooleanBody(members) {
        return (0, _validateNode.default)({
          type: "EnumBooleanBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumNumberBody(members) {
        return (0, _validateNode.default)({
          type: "EnumNumberBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumStringBody(members) {
        return (0, _validateNode.default)({
          type: "EnumStringBody",
          members,
          explicitType: null,
          hasUnknownMembers: null
        });
      }
      function enumSymbolBody(members) {
        return (0, _validateNode.default)({
          type: "EnumSymbolBody",
          members,
          hasUnknownMembers: null
        });
      }
      function enumBooleanMember(id) {
        return (0, _validateNode.default)({
          type: "EnumBooleanMember",
          id,
          init: null
        });
      }
      function enumNumberMember(id, init) {
        return (0, _validateNode.default)({
          type: "EnumNumberMember",
          id,
          init
        });
      }
      function enumStringMember(id, init) {
        return (0, _validateNode.default)({
          type: "EnumStringMember",
          id,
          init
        });
      }
      function enumDefaultedMember(id) {
        return (0, _validateNode.default)({
          type: "EnumDefaultedMember",
          id
        });
      }
      function indexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "IndexedAccessType",
          objectType,
          indexType
        });
      }
      function optionalIndexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "OptionalIndexedAccessType",
          objectType,
          indexType,
          optional: null
        });
      }
      function jsxAttribute(name, value = null) {
        return (0, _validateNode.default)({
          type: "JSXAttribute",
          name,
          value
        });
      }
      function jsxClosingElement(name) {
        return (0, _validateNode.default)({
          type: "JSXClosingElement",
          name
        });
      }
      function jsxElement(openingElement, closingElement = null, children2, selfClosing = null) {
        return (0, _validateNode.default)({
          type: "JSXElement",
          openingElement,
          closingElement,
          children: children2,
          selfClosing
        });
      }
      function jsxEmptyExpression() {
        return {
          type: "JSXEmptyExpression"
        };
      }
      function jsxExpressionContainer(expression) {
        return (0, _validateNode.default)({
          type: "JSXExpressionContainer",
          expression
        });
      }
      function jsxSpreadChild(expression) {
        return (0, _validateNode.default)({
          type: "JSXSpreadChild",
          expression
        });
      }
      function jsxIdentifier(name) {
        return (0, _validateNode.default)({
          type: "JSXIdentifier",
          name
        });
      }
      function jsxMemberExpression(object, property) {
        return (0, _validateNode.default)({
          type: "JSXMemberExpression",
          object,
          property
        });
      }
      function jsxNamespacedName(namespace, name) {
        return (0, _validateNode.default)({
          type: "JSXNamespacedName",
          namespace,
          name
        });
      }
      function jsxOpeningElement(name, attributes, selfClosing = false) {
        return (0, _validateNode.default)({
          type: "JSXOpeningElement",
          name,
          attributes,
          selfClosing
        });
      }
      function jsxSpreadAttribute(argument) {
        return (0, _validateNode.default)({
          type: "JSXSpreadAttribute",
          argument
        });
      }
      function jsxText(value) {
        return (0, _validateNode.default)({
          type: "JSXText",
          value
        });
      }
      function jsxFragment(openingFragment, closingFragment, children2) {
        return (0, _validateNode.default)({
          type: "JSXFragment",
          openingFragment,
          closingFragment,
          children: children2
        });
      }
      function jsxOpeningFragment() {
        return {
          type: "JSXOpeningFragment"
        };
      }
      function jsxClosingFragment() {
        return {
          type: "JSXClosingFragment"
        };
      }
      function noop() {
        return {
          type: "Noop"
        };
      }
      function placeholder(expectedNode, name) {
        return (0, _validateNode.default)({
          type: "Placeholder",
          expectedNode,
          name
        });
      }
      function v8IntrinsicIdentifier(name) {
        return (0, _validateNode.default)({
          type: "V8IntrinsicIdentifier",
          name
        });
      }
      function argumentPlaceholder() {
        return {
          type: "ArgumentPlaceholder"
        };
      }
      function bindExpression(object, callee) {
        return (0, _validateNode.default)({
          type: "BindExpression",
          object,
          callee
        });
      }
      function importAttribute(key, value) {
        return (0, _validateNode.default)({
          type: "ImportAttribute",
          key,
          value
        });
      }
      function decorator(expression) {
        return (0, _validateNode.default)({
          type: "Decorator",
          expression
        });
      }
      function doExpression(body, async = false) {
        return (0, _validateNode.default)({
          type: "DoExpression",
          body,
          async
        });
      }
      function exportDefaultSpecifier(exported) {
        return (0, _validateNode.default)({
          type: "ExportDefaultSpecifier",
          exported
        });
      }
      function recordExpression(properties) {
        return (0, _validateNode.default)({
          type: "RecordExpression",
          properties
        });
      }
      function tupleExpression(elements = []) {
        return (0, _validateNode.default)({
          type: "TupleExpression",
          elements
        });
      }
      function decimalLiteral(value) {
        return (0, _validateNode.default)({
          type: "DecimalLiteral",
          value
        });
      }
      function moduleExpression(body) {
        return (0, _validateNode.default)({
          type: "ModuleExpression",
          body
        });
      }
      function topicReference() {
        return {
          type: "TopicReference"
        };
      }
      function pipelineTopicExpression(expression) {
        return (0, _validateNode.default)({
          type: "PipelineTopicExpression",
          expression
        });
      }
      function pipelineBareFunction(callee) {
        return (0, _validateNode.default)({
          type: "PipelineBareFunction",
          callee
        });
      }
      function pipelinePrimaryTopicReference() {
        return {
          type: "PipelinePrimaryTopicReference"
        };
      }
      function tsParameterProperty(parameter) {
        return (0, _validateNode.default)({
          type: "TSParameterProperty",
          parameter
        });
      }
      function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
        return (0, _validateNode.default)({
          type: "TSDeclareFunction",
          id,
          typeParameters,
          params,
          returnType
        });
      }
      function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
        return (0, _validateNode.default)({
          type: "TSDeclareMethod",
          decorators,
          key,
          typeParameters,
          params,
          returnType
        });
      }
      function tsQualifiedName(left, right) {
        return (0, _validateNode.default)({
          type: "TSQualifiedName",
          left,
          right
        });
      }
      function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSCallSignatureDeclaration",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSConstructSignatureDeclaration",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
        return (0, _validateNode.default)({
          type: "TSPropertySignature",
          key,
          typeAnnotation: typeAnnotation2,
          initializer,
          kind: null
        });
      }
      function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSMethodSignature",
          key,
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2,
          kind: null
        });
      }
      function tsIndexSignature(parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSIndexSignature",
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsAnyKeyword() {
        return {
          type: "TSAnyKeyword"
        };
      }
      function tsBooleanKeyword() {
        return {
          type: "TSBooleanKeyword"
        };
      }
      function tsBigIntKeyword() {
        return {
          type: "TSBigIntKeyword"
        };
      }
      function tsIntrinsicKeyword() {
        return {
          type: "TSIntrinsicKeyword"
        };
      }
      function tsNeverKeyword() {
        return {
          type: "TSNeverKeyword"
        };
      }
      function tsNullKeyword() {
        return {
          type: "TSNullKeyword"
        };
      }
      function tsNumberKeyword() {
        return {
          type: "TSNumberKeyword"
        };
      }
      function tsObjectKeyword() {
        return {
          type: "TSObjectKeyword"
        };
      }
      function tsStringKeyword() {
        return {
          type: "TSStringKeyword"
        };
      }
      function tsSymbolKeyword() {
        return {
          type: "TSSymbolKeyword"
        };
      }
      function tsUndefinedKeyword() {
        return {
          type: "TSUndefinedKeyword"
        };
      }
      function tsUnknownKeyword() {
        return {
          type: "TSUnknownKeyword"
        };
      }
      function tsVoidKeyword() {
        return {
          type: "TSVoidKeyword"
        };
      }
      function tsThisType() {
        return {
          type: "TSThisType"
        };
      }
      function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSFunctionType",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
        return (0, _validateNode.default)({
          type: "TSConstructorType",
          typeParameters,
          parameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeReference(typeName, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSTypeReference",
          typeName,
          typeParameters
        });
      }
      function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
        return (0, _validateNode.default)({
          type: "TSTypePredicate",
          parameterName,
          typeAnnotation: typeAnnotation2,
          asserts
        });
      }
      function tsTypeQuery(exprName, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSTypeQuery",
          exprName,
          typeParameters
        });
      }
      function tsTypeLiteral(members) {
        return (0, _validateNode.default)({
          type: "TSTypeLiteral",
          members
        });
      }
      function tsArrayType(elementType) {
        return (0, _validateNode.default)({
          type: "TSArrayType",
          elementType
        });
      }
      function tsTupleType(elementTypes) {
        return (0, _validateNode.default)({
          type: "TSTupleType",
          elementTypes
        });
      }
      function tsOptionalType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSOptionalType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsRestType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSRestType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsNamedTupleMember(label, elementType, optional = false) {
        return (0, _validateNode.default)({
          type: "TSNamedTupleMember",
          label,
          elementType,
          optional
        });
      }
      function tsUnionType(types) {
        return (0, _validateNode.default)({
          type: "TSUnionType",
          types
        });
      }
      function tsIntersectionType(types) {
        return (0, _validateNode.default)({
          type: "TSIntersectionType",
          types
        });
      }
      function tsConditionalType(checkType, extendsType, trueType, falseType) {
        return (0, _validateNode.default)({
          type: "TSConditionalType",
          checkType,
          extendsType,
          trueType,
          falseType
        });
      }
      function tsInferType(typeParameter2) {
        return (0, _validateNode.default)({
          type: "TSInferType",
          typeParameter: typeParameter2
        });
      }
      function tsParenthesizedType(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSParenthesizedType",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeOperator(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeOperator",
          typeAnnotation: typeAnnotation2,
          operator: null
        });
      }
      function tsIndexedAccessType(objectType, indexType) {
        return (0, _validateNode.default)({
          type: "TSIndexedAccessType",
          objectType,
          indexType
        });
      }
      function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
        return (0, _validateNode.default)({
          type: "TSMappedType",
          typeParameter: typeParameter2,
          typeAnnotation: typeAnnotation2,
          nameType
        });
      }
      function tsLiteralType(literal) {
        return (0, _validateNode.default)({
          type: "TSLiteralType",
          literal
        });
      }
      function tsExpressionWithTypeArguments(expression, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSExpressionWithTypeArguments",
          expression,
          typeParameters
        });
      }
      function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
        return (0, _validateNode.default)({
          type: "TSInterfaceDeclaration",
          id,
          typeParameters,
          extends: _extends,
          body
        });
      }
      function tsInterfaceBody(body) {
        return (0, _validateNode.default)({
          type: "TSInterfaceBody",
          body
        });
      }
      function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeAliasDeclaration",
          id,
          typeParameters,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsInstantiationExpression(expression, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSInstantiationExpression",
          expression,
          typeParameters
        });
      }
      function tsAsExpression(expression, typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSAsExpression",
          expression,
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeAssertion(typeAnnotation2, expression) {
        return (0, _validateNode.default)({
          type: "TSTypeAssertion",
          typeAnnotation: typeAnnotation2,
          expression
        });
      }
      function tsEnumDeclaration(id, members) {
        return (0, _validateNode.default)({
          type: "TSEnumDeclaration",
          id,
          members
        });
      }
      function tsEnumMember(id, initializer = null) {
        return (0, _validateNode.default)({
          type: "TSEnumMember",
          id,
          initializer
        });
      }
      function tsModuleDeclaration(id, body) {
        return (0, _validateNode.default)({
          type: "TSModuleDeclaration",
          id,
          body
        });
      }
      function tsModuleBlock(body) {
        return (0, _validateNode.default)({
          type: "TSModuleBlock",
          body
        });
      }
      function tsImportType(argument, qualifier = null, typeParameters = null) {
        return (0, _validateNode.default)({
          type: "TSImportType",
          argument,
          qualifier,
          typeParameters
        });
      }
      function tsImportEqualsDeclaration(id, moduleReference) {
        return (0, _validateNode.default)({
          type: "TSImportEqualsDeclaration",
          id,
          moduleReference,
          isExport: null
        });
      }
      function tsExternalModuleReference(expression) {
        return (0, _validateNode.default)({
          type: "TSExternalModuleReference",
          expression
        });
      }
      function tsNonNullExpression(expression) {
        return (0, _validateNode.default)({
          type: "TSNonNullExpression",
          expression
        });
      }
      function tsExportAssignment(expression) {
        return (0, _validateNode.default)({
          type: "TSExportAssignment",
          expression
        });
      }
      function tsNamespaceExportDeclaration(id) {
        return (0, _validateNode.default)({
          type: "TSNamespaceExportDeclaration",
          id
        });
      }
      function tsTypeAnnotation(typeAnnotation2) {
        return (0, _validateNode.default)({
          type: "TSTypeAnnotation",
          typeAnnotation: typeAnnotation2
        });
      }
      function tsTypeParameterInstantiation(params) {
        return (0, _validateNode.default)({
          type: "TSTypeParameterInstantiation",
          params
        });
      }
      function tsTypeParameterDeclaration(params) {
        return (0, _validateNode.default)({
          type: "TSTypeParameterDeclaration",
          params
        });
      }
      function tsTypeParameter(constraint = null, _default = null, name) {
        return (0, _validateNode.default)({
          type: "TSTypeParameter",
          constraint,
          default: _default,
          name
        });
      }
      function NumberLiteral(value) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        return numericLiteral(value);
      }
      function RegexLiteral(pattern, flags = "") {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        return regExpLiteral(pattern, flags);
      }
      function RestProperty(argument) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        return restElement(argument);
      }
      function SpreadProperty(argument) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        return spreadElement(argument);
      }
    }
  });

  // ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
  var require_cleanJSXElementLiteralChild = __commonJS({
    "../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cleanJSXElementLiteralChild;
      var _generated = require_generated2();
      function cleanJSXElementLiteralChild(child, args) {
        const lines = child.value.split(/\r\n|\n|\r/);
        let lastNonEmptyLine = 0;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].match(/[^ \t]/)) {
            lastNonEmptyLine = i;
          }
        }
        let str = "";
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const isFirstLine = i === 0;
          const isLastLine = i === lines.length - 1;
          const isLastNonEmptyLine = i === lastNonEmptyLine;
          let trimmedLine = line.replace(/\t/g, " ");
          if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^[ ]+/, "");
          }
          if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/[ ]+$/, "");
          }
          if (trimmedLine) {
            if (!isLastNonEmptyLine) {
              trimmedLine += " ";
            }
            str += trimmedLine;
          }
        }
        if (str)
          args.push((0, _generated.stringLiteral)(str));
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/react/buildChildren.js
  var require_buildChildren = __commonJS({
    "../node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = buildChildren;
      var _generated = require_generated();
      var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
      function buildChildren(node) {
        const elements = [];
        for (let i = 0; i < node.children.length; i++) {
          let child = node.children[i];
          if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
          }
          if ((0, _generated.isJSXExpressionContainer)(child))
            child = child.expression;
          if ((0, _generated.isJSXEmptyExpression)(child))
            continue;
          elements.push(child);
        }
        return elements;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isNode.js
  var require_isNode = __commonJS({
    "../node_modules/@babel/types/lib/validators/isNode.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isNode;
      var _definitions = require_definitions();
      function isNode(node) {
        return !!(node && _definitions.VISITOR_KEYS[node.type]);
      }
    }
  });

  // ../node_modules/@babel/types/lib/asserts/assertNode.js
  var require_assertNode = __commonJS({
    "../node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = assertNode;
      var _isNode = require_isNode();
      function assertNode(node) {
        if (!(0, _isNode.default)(node)) {
          var _node$type;
          const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
          throw new TypeError(`Not a valid node of type "${type}"`);
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/asserts/generated/index.js
  var require_generated3 = __commonJS({
    "../node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertAccessor = assertAccessor;
      exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
      exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
      exports.assertArrayExpression = assertArrayExpression;
      exports.assertArrayPattern = assertArrayPattern;
      exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
      exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
      exports.assertAssignmentExpression = assertAssignmentExpression;
      exports.assertAssignmentPattern = assertAssignmentPattern;
      exports.assertAwaitExpression = assertAwaitExpression;
      exports.assertBigIntLiteral = assertBigIntLiteral;
      exports.assertBinary = assertBinary;
      exports.assertBinaryExpression = assertBinaryExpression;
      exports.assertBindExpression = assertBindExpression;
      exports.assertBlock = assertBlock;
      exports.assertBlockParent = assertBlockParent;
      exports.assertBlockStatement = assertBlockStatement;
      exports.assertBooleanLiteral = assertBooleanLiteral;
      exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
      exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
      exports.assertBreakStatement = assertBreakStatement;
      exports.assertCallExpression = assertCallExpression;
      exports.assertCatchClause = assertCatchClause;
      exports.assertClass = assertClass;
      exports.assertClassAccessorProperty = assertClassAccessorProperty;
      exports.assertClassBody = assertClassBody;
      exports.assertClassDeclaration = assertClassDeclaration;
      exports.assertClassExpression = assertClassExpression;
      exports.assertClassImplements = assertClassImplements;
      exports.assertClassMethod = assertClassMethod;
      exports.assertClassPrivateMethod = assertClassPrivateMethod;
      exports.assertClassPrivateProperty = assertClassPrivateProperty;
      exports.assertClassProperty = assertClassProperty;
      exports.assertCompletionStatement = assertCompletionStatement;
      exports.assertConditional = assertConditional;
      exports.assertConditionalExpression = assertConditionalExpression;
      exports.assertContinueStatement = assertContinueStatement;
      exports.assertDebuggerStatement = assertDebuggerStatement;
      exports.assertDecimalLiteral = assertDecimalLiteral;
      exports.assertDeclaration = assertDeclaration;
      exports.assertDeclareClass = assertDeclareClass;
      exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
      exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
      exports.assertDeclareFunction = assertDeclareFunction;
      exports.assertDeclareInterface = assertDeclareInterface;
      exports.assertDeclareModule = assertDeclareModule;
      exports.assertDeclareModuleExports = assertDeclareModuleExports;
      exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
      exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
      exports.assertDeclareVariable = assertDeclareVariable;
      exports.assertDeclaredPredicate = assertDeclaredPredicate;
      exports.assertDecorator = assertDecorator;
      exports.assertDirective = assertDirective;
      exports.assertDirectiveLiteral = assertDirectiveLiteral;
      exports.assertDoExpression = assertDoExpression;
      exports.assertDoWhileStatement = assertDoWhileStatement;
      exports.assertEmptyStatement = assertEmptyStatement;
      exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
      exports.assertEnumBody = assertEnumBody;
      exports.assertEnumBooleanBody = assertEnumBooleanBody;
      exports.assertEnumBooleanMember = assertEnumBooleanMember;
      exports.assertEnumDeclaration = assertEnumDeclaration;
      exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
      exports.assertEnumMember = assertEnumMember;
      exports.assertEnumNumberBody = assertEnumNumberBody;
      exports.assertEnumNumberMember = assertEnumNumberMember;
      exports.assertEnumStringBody = assertEnumStringBody;
      exports.assertEnumStringMember = assertEnumStringMember;
      exports.assertEnumSymbolBody = assertEnumSymbolBody;
      exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
      exports.assertExportAllDeclaration = assertExportAllDeclaration;
      exports.assertExportDeclaration = assertExportDeclaration;
      exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
      exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
      exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
      exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
      exports.assertExportSpecifier = assertExportSpecifier;
      exports.assertExpression = assertExpression;
      exports.assertExpressionStatement = assertExpressionStatement;
      exports.assertExpressionWrapper = assertExpressionWrapper;
      exports.assertFile = assertFile;
      exports.assertFlow = assertFlow;
      exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
      exports.assertFlowDeclaration = assertFlowDeclaration;
      exports.assertFlowPredicate = assertFlowPredicate;
      exports.assertFlowType = assertFlowType;
      exports.assertFor = assertFor;
      exports.assertForInStatement = assertForInStatement;
      exports.assertForOfStatement = assertForOfStatement;
      exports.assertForStatement = assertForStatement;
      exports.assertForXStatement = assertForXStatement;
      exports.assertFunction = assertFunction;
      exports.assertFunctionDeclaration = assertFunctionDeclaration;
      exports.assertFunctionExpression = assertFunctionExpression;
      exports.assertFunctionParent = assertFunctionParent;
      exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
      exports.assertFunctionTypeParam = assertFunctionTypeParam;
      exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
      exports.assertIdentifier = assertIdentifier;
      exports.assertIfStatement = assertIfStatement;
      exports.assertImmutable = assertImmutable;
      exports.assertImport = assertImport;
      exports.assertImportAttribute = assertImportAttribute;
      exports.assertImportDeclaration = assertImportDeclaration;
      exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
      exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
      exports.assertImportSpecifier = assertImportSpecifier;
      exports.assertIndexedAccessType = assertIndexedAccessType;
      exports.assertInferredPredicate = assertInferredPredicate;
      exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
      exports.assertInterfaceExtends = assertInterfaceExtends;
      exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
      exports.assertInterpreterDirective = assertInterpreterDirective;
      exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
      exports.assertJSX = assertJSX;
      exports.assertJSXAttribute = assertJSXAttribute;
      exports.assertJSXClosingElement = assertJSXClosingElement;
      exports.assertJSXClosingFragment = assertJSXClosingFragment;
      exports.assertJSXElement = assertJSXElement;
      exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
      exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
      exports.assertJSXFragment = assertJSXFragment;
      exports.assertJSXIdentifier = assertJSXIdentifier;
      exports.assertJSXMemberExpression = assertJSXMemberExpression;
      exports.assertJSXNamespacedName = assertJSXNamespacedName;
      exports.assertJSXOpeningElement = assertJSXOpeningElement;
      exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
      exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
      exports.assertJSXSpreadChild = assertJSXSpreadChild;
      exports.assertJSXText = assertJSXText;
      exports.assertLVal = assertLVal;
      exports.assertLabeledStatement = assertLabeledStatement;
      exports.assertLiteral = assertLiteral;
      exports.assertLogicalExpression = assertLogicalExpression;
      exports.assertLoop = assertLoop;
      exports.assertMemberExpression = assertMemberExpression;
      exports.assertMetaProperty = assertMetaProperty;
      exports.assertMethod = assertMethod;
      exports.assertMiscellaneous = assertMiscellaneous;
      exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
      exports.assertModuleDeclaration = assertModuleDeclaration;
      exports.assertModuleExpression = assertModuleExpression;
      exports.assertModuleSpecifier = assertModuleSpecifier;
      exports.assertNewExpression = assertNewExpression;
      exports.assertNoop = assertNoop;
      exports.assertNullLiteral = assertNullLiteral;
      exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
      exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
      exports.assertNumberLiteral = assertNumberLiteral;
      exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
      exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
      exports.assertNumericLiteral = assertNumericLiteral;
      exports.assertObjectExpression = assertObjectExpression;
      exports.assertObjectMember = assertObjectMember;
      exports.assertObjectMethod = assertObjectMethod;
      exports.assertObjectPattern = assertObjectPattern;
      exports.assertObjectProperty = assertObjectProperty;
      exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
      exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
      exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
      exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
      exports.assertObjectTypeProperty = assertObjectTypeProperty;
      exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
      exports.assertOpaqueType = assertOpaqueType;
      exports.assertOptionalCallExpression = assertOptionalCallExpression;
      exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
      exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
      exports.assertParenthesizedExpression = assertParenthesizedExpression;
      exports.assertPattern = assertPattern;
      exports.assertPatternLike = assertPatternLike;
      exports.assertPipelineBareFunction = assertPipelineBareFunction;
      exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
      exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
      exports.assertPlaceholder = assertPlaceholder;
      exports.assertPrivate = assertPrivate;
      exports.assertPrivateName = assertPrivateName;
      exports.assertProgram = assertProgram;
      exports.assertProperty = assertProperty;
      exports.assertPureish = assertPureish;
      exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
      exports.assertRecordExpression = assertRecordExpression;
      exports.assertRegExpLiteral = assertRegExpLiteral;
      exports.assertRegexLiteral = assertRegexLiteral;
      exports.assertRestElement = assertRestElement;
      exports.assertRestProperty = assertRestProperty;
      exports.assertReturnStatement = assertReturnStatement;
      exports.assertScopable = assertScopable;
      exports.assertSequenceExpression = assertSequenceExpression;
      exports.assertSpreadElement = assertSpreadElement;
      exports.assertSpreadProperty = assertSpreadProperty;
      exports.assertStandardized = assertStandardized;
      exports.assertStatement = assertStatement;
      exports.assertStaticBlock = assertStaticBlock;
      exports.assertStringLiteral = assertStringLiteral;
      exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
      exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
      exports.assertSuper = assertSuper;
      exports.assertSwitchCase = assertSwitchCase;
      exports.assertSwitchStatement = assertSwitchStatement;
      exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
      exports.assertTSAnyKeyword = assertTSAnyKeyword;
      exports.assertTSArrayType = assertTSArrayType;
      exports.assertTSAsExpression = assertTSAsExpression;
      exports.assertTSBaseType = assertTSBaseType;
      exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
      exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
      exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
      exports.assertTSConditionalType = assertTSConditionalType;
      exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
      exports.assertTSConstructorType = assertTSConstructorType;
      exports.assertTSDeclareFunction = assertTSDeclareFunction;
      exports.assertTSDeclareMethod = assertTSDeclareMethod;
      exports.assertTSEntityName = assertTSEntityName;
      exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
      exports.assertTSEnumMember = assertTSEnumMember;
      exports.assertTSExportAssignment = assertTSExportAssignment;
      exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
      exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
      exports.assertTSFunctionType = assertTSFunctionType;
      exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
      exports.assertTSImportType = assertTSImportType;
      exports.assertTSIndexSignature = assertTSIndexSignature;
      exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
      exports.assertTSInferType = assertTSInferType;
      exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
      exports.assertTSInterfaceBody = assertTSInterfaceBody;
      exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
      exports.assertTSIntersectionType = assertTSIntersectionType;
      exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
      exports.assertTSLiteralType = assertTSLiteralType;
      exports.assertTSMappedType = assertTSMappedType;
      exports.assertTSMethodSignature = assertTSMethodSignature;
      exports.assertTSModuleBlock = assertTSModuleBlock;
      exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
      exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
      exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
      exports.assertTSNeverKeyword = assertTSNeverKeyword;
      exports.assertTSNonNullExpression = assertTSNonNullExpression;
      exports.assertTSNullKeyword = assertTSNullKeyword;
      exports.assertTSNumberKeyword = assertTSNumberKeyword;
      exports.assertTSObjectKeyword = assertTSObjectKeyword;
      exports.assertTSOptionalType = assertTSOptionalType;
      exports.assertTSParameterProperty = assertTSParameterProperty;
      exports.assertTSParenthesizedType = assertTSParenthesizedType;
      exports.assertTSPropertySignature = assertTSPropertySignature;
      exports.assertTSQualifiedName = assertTSQualifiedName;
      exports.assertTSRestType = assertTSRestType;
      exports.assertTSStringKeyword = assertTSStringKeyword;
      exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
      exports.assertTSThisType = assertTSThisType;
      exports.assertTSTupleType = assertTSTupleType;
      exports.assertTSType = assertTSType;
      exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
      exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
      exports.assertTSTypeAssertion = assertTSTypeAssertion;
      exports.assertTSTypeElement = assertTSTypeElement;
      exports.assertTSTypeLiteral = assertTSTypeLiteral;
      exports.assertTSTypeOperator = assertTSTypeOperator;
      exports.assertTSTypeParameter = assertTSTypeParameter;
      exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
      exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
      exports.assertTSTypePredicate = assertTSTypePredicate;
      exports.assertTSTypeQuery = assertTSTypeQuery;
      exports.assertTSTypeReference = assertTSTypeReference;
      exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
      exports.assertTSUnionType = assertTSUnionType;
      exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
      exports.assertTSVoidKeyword = assertTSVoidKeyword;
      exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
      exports.assertTemplateElement = assertTemplateElement;
      exports.assertTemplateLiteral = assertTemplateLiteral;
      exports.assertTerminatorless = assertTerminatorless;
      exports.assertThisExpression = assertThisExpression;
      exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
      exports.assertThrowStatement = assertThrowStatement;
      exports.assertTopicReference = assertTopicReference;
      exports.assertTryStatement = assertTryStatement;
      exports.assertTupleExpression = assertTupleExpression;
      exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
      exports.assertTypeAlias = assertTypeAlias;
      exports.assertTypeAnnotation = assertTypeAnnotation;
      exports.assertTypeCastExpression = assertTypeCastExpression;
      exports.assertTypeParameter = assertTypeParameter;
      exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
      exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
      exports.assertTypeScript = assertTypeScript;
      exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
      exports.assertUnaryExpression = assertUnaryExpression;
      exports.assertUnaryLike = assertUnaryLike;
      exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
      exports.assertUpdateExpression = assertUpdateExpression;
      exports.assertUserWhitespacable = assertUserWhitespacable;
      exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
      exports.assertVariableDeclaration = assertVariableDeclaration;
      exports.assertVariableDeclarator = assertVariableDeclarator;
      exports.assertVariance = assertVariance;
      exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
      exports.assertWhile = assertWhile;
      exports.assertWhileStatement = assertWhileStatement;
      exports.assertWithStatement = assertWithStatement;
      exports.assertYieldExpression = assertYieldExpression;
      var _is = require_is();
      function assert(type, node, opts) {
        if (!(0, _is.default)(type, node, opts)) {
          throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
        }
      }
      function assertArrayExpression(node, opts) {
        assert("ArrayExpression", node, opts);
      }
      function assertAssignmentExpression(node, opts) {
        assert("AssignmentExpression", node, opts);
      }
      function assertBinaryExpression(node, opts) {
        assert("BinaryExpression", node, opts);
      }
      function assertInterpreterDirective(node, opts) {
        assert("InterpreterDirective", node, opts);
      }
      function assertDirective(node, opts) {
        assert("Directive", node, opts);
      }
      function assertDirectiveLiteral(node, opts) {
        assert("DirectiveLiteral", node, opts);
      }
      function assertBlockStatement(node, opts) {
        assert("BlockStatement", node, opts);
      }
      function assertBreakStatement(node, opts) {
        assert("BreakStatement", node, opts);
      }
      function assertCallExpression(node, opts) {
        assert("CallExpression", node, opts);
      }
      function assertCatchClause(node, opts) {
        assert("CatchClause", node, opts);
      }
      function assertConditionalExpression(node, opts) {
        assert("ConditionalExpression", node, opts);
      }
      function assertContinueStatement(node, opts) {
        assert("ContinueStatement", node, opts);
      }
      function assertDebuggerStatement(node, opts) {
        assert("DebuggerStatement", node, opts);
      }
      function assertDoWhileStatement(node, opts) {
        assert("DoWhileStatement", node, opts);
      }
      function assertEmptyStatement(node, opts) {
        assert("EmptyStatement", node, opts);
      }
      function assertExpressionStatement(node, opts) {
        assert("ExpressionStatement", node, opts);
      }
      function assertFile(node, opts) {
        assert("File", node, opts);
      }
      function assertForInStatement(node, opts) {
        assert("ForInStatement", node, opts);
      }
      function assertForStatement(node, opts) {
        assert("ForStatement", node, opts);
      }
      function assertFunctionDeclaration(node, opts) {
        assert("FunctionDeclaration", node, opts);
      }
      function assertFunctionExpression(node, opts) {
        assert("FunctionExpression", node, opts);
      }
      function assertIdentifier(node, opts) {
        assert("Identifier", node, opts);
      }
      function assertIfStatement(node, opts) {
        assert("IfStatement", node, opts);
      }
      function assertLabeledStatement(node, opts) {
        assert("LabeledStatement", node, opts);
      }
      function assertStringLiteral(node, opts) {
        assert("StringLiteral", node, opts);
      }
      function assertNumericLiteral(node, opts) {
        assert("NumericLiteral", node, opts);
      }
      function assertNullLiteral(node, opts) {
        assert("NullLiteral", node, opts);
      }
      function assertBooleanLiteral(node, opts) {
        assert("BooleanLiteral", node, opts);
      }
      function assertRegExpLiteral(node, opts) {
        assert("RegExpLiteral", node, opts);
      }
      function assertLogicalExpression(node, opts) {
        assert("LogicalExpression", node, opts);
      }
      function assertMemberExpression(node, opts) {
        assert("MemberExpression", node, opts);
      }
      function assertNewExpression(node, opts) {
        assert("NewExpression", node, opts);
      }
      function assertProgram(node, opts) {
        assert("Program", node, opts);
      }
      function assertObjectExpression(node, opts) {
        assert("ObjectExpression", node, opts);
      }
      function assertObjectMethod(node, opts) {
        assert("ObjectMethod", node, opts);
      }
      function assertObjectProperty(node, opts) {
        assert("ObjectProperty", node, opts);
      }
      function assertRestElement(node, opts) {
        assert("RestElement", node, opts);
      }
      function assertReturnStatement(node, opts) {
        assert("ReturnStatement", node, opts);
      }
      function assertSequenceExpression(node, opts) {
        assert("SequenceExpression", node, opts);
      }
      function assertParenthesizedExpression(node, opts) {
        assert("ParenthesizedExpression", node, opts);
      }
      function assertSwitchCase(node, opts) {
        assert("SwitchCase", node, opts);
      }
      function assertSwitchStatement(node, opts) {
        assert("SwitchStatement", node, opts);
      }
      function assertThisExpression(node, opts) {
        assert("ThisExpression", node, opts);
      }
      function assertThrowStatement(node, opts) {
        assert("ThrowStatement", node, opts);
      }
      function assertTryStatement(node, opts) {
        assert("TryStatement", node, opts);
      }
      function assertUnaryExpression(node, opts) {
        assert("UnaryExpression", node, opts);
      }
      function assertUpdateExpression(node, opts) {
        assert("UpdateExpression", node, opts);
      }
      function assertVariableDeclaration(node, opts) {
        assert("VariableDeclaration", node, opts);
      }
      function assertVariableDeclarator(node, opts) {
        assert("VariableDeclarator", node, opts);
      }
      function assertWhileStatement(node, opts) {
        assert("WhileStatement", node, opts);
      }
      function assertWithStatement(node, opts) {
        assert("WithStatement", node, opts);
      }
      function assertAssignmentPattern(node, opts) {
        assert("AssignmentPattern", node, opts);
      }
      function assertArrayPattern(node, opts) {
        assert("ArrayPattern", node, opts);
      }
      function assertArrowFunctionExpression(node, opts) {
        assert("ArrowFunctionExpression", node, opts);
      }
      function assertClassBody(node, opts) {
        assert("ClassBody", node, opts);
      }
      function assertClassExpression(node, opts) {
        assert("ClassExpression", node, opts);
      }
      function assertClassDeclaration(node, opts) {
        assert("ClassDeclaration", node, opts);
      }
      function assertExportAllDeclaration(node, opts) {
        assert("ExportAllDeclaration", node, opts);
      }
      function assertExportDefaultDeclaration(node, opts) {
        assert("ExportDefaultDeclaration", node, opts);
      }
      function assertExportNamedDeclaration(node, opts) {
        assert("ExportNamedDeclaration", node, opts);
      }
      function assertExportSpecifier(node, opts) {
        assert("ExportSpecifier", node, opts);
      }
      function assertForOfStatement(node, opts) {
        assert("ForOfStatement", node, opts);
      }
      function assertImportDeclaration(node, opts) {
        assert("ImportDeclaration", node, opts);
      }
      function assertImportDefaultSpecifier(node, opts) {
        assert("ImportDefaultSpecifier", node, opts);
      }
      function assertImportNamespaceSpecifier(node, opts) {
        assert("ImportNamespaceSpecifier", node, opts);
      }
      function assertImportSpecifier(node, opts) {
        assert("ImportSpecifier", node, opts);
      }
      function assertMetaProperty(node, opts) {
        assert("MetaProperty", node, opts);
      }
      function assertClassMethod(node, opts) {
        assert("ClassMethod", node, opts);
      }
      function assertObjectPattern(node, opts) {
        assert("ObjectPattern", node, opts);
      }
      function assertSpreadElement(node, opts) {
        assert("SpreadElement", node, opts);
      }
      function assertSuper(node, opts) {
        assert("Super", node, opts);
      }
      function assertTaggedTemplateExpression(node, opts) {
        assert("TaggedTemplateExpression", node, opts);
      }
      function assertTemplateElement(node, opts) {
        assert("TemplateElement", node, opts);
      }
      function assertTemplateLiteral(node, opts) {
        assert("TemplateLiteral", node, opts);
      }
      function assertYieldExpression(node, opts) {
        assert("YieldExpression", node, opts);
      }
      function assertAwaitExpression(node, opts) {
        assert("AwaitExpression", node, opts);
      }
      function assertImport(node, opts) {
        assert("Import", node, opts);
      }
      function assertBigIntLiteral(node, opts) {
        assert("BigIntLiteral", node, opts);
      }
      function assertExportNamespaceSpecifier(node, opts) {
        assert("ExportNamespaceSpecifier", node, opts);
      }
      function assertOptionalMemberExpression(node, opts) {
        assert("OptionalMemberExpression", node, opts);
      }
      function assertOptionalCallExpression(node, opts) {
        assert("OptionalCallExpression", node, opts);
      }
      function assertClassProperty(node, opts) {
        assert("ClassProperty", node, opts);
      }
      function assertClassAccessorProperty(node, opts) {
        assert("ClassAccessorProperty", node, opts);
      }
      function assertClassPrivateProperty(node, opts) {
        assert("ClassPrivateProperty", node, opts);
      }
      function assertClassPrivateMethod(node, opts) {
        assert("ClassPrivateMethod", node, opts);
      }
      function assertPrivateName(node, opts) {
        assert("PrivateName", node, opts);
      }
      function assertStaticBlock(node, opts) {
        assert("StaticBlock", node, opts);
      }
      function assertAnyTypeAnnotation(node, opts) {
        assert("AnyTypeAnnotation", node, opts);
      }
      function assertArrayTypeAnnotation(node, opts) {
        assert("ArrayTypeAnnotation", node, opts);
      }
      function assertBooleanTypeAnnotation(node, opts) {
        assert("BooleanTypeAnnotation", node, opts);
      }
      function assertBooleanLiteralTypeAnnotation(node, opts) {
        assert("BooleanLiteralTypeAnnotation", node, opts);
      }
      function assertNullLiteralTypeAnnotation(node, opts) {
        assert("NullLiteralTypeAnnotation", node, opts);
      }
      function assertClassImplements(node, opts) {
        assert("ClassImplements", node, opts);
      }
      function assertDeclareClass(node, opts) {
        assert("DeclareClass", node, opts);
      }
      function assertDeclareFunction(node, opts) {
        assert("DeclareFunction", node, opts);
      }
      function assertDeclareInterface(node, opts) {
        assert("DeclareInterface", node, opts);
      }
      function assertDeclareModule(node, opts) {
        assert("DeclareModule", node, opts);
      }
      function assertDeclareModuleExports(node, opts) {
        assert("DeclareModuleExports", node, opts);
      }
      function assertDeclareTypeAlias(node, opts) {
        assert("DeclareTypeAlias", node, opts);
      }
      function assertDeclareOpaqueType(node, opts) {
        assert("DeclareOpaqueType", node, opts);
      }
      function assertDeclareVariable(node, opts) {
        assert("DeclareVariable", node, opts);
      }
      function assertDeclareExportDeclaration(node, opts) {
        assert("DeclareExportDeclaration", node, opts);
      }
      function assertDeclareExportAllDeclaration(node, opts) {
        assert("DeclareExportAllDeclaration", node, opts);
      }
      function assertDeclaredPredicate(node, opts) {
        assert("DeclaredPredicate", node, opts);
      }
      function assertExistsTypeAnnotation(node, opts) {
        assert("ExistsTypeAnnotation", node, opts);
      }
      function assertFunctionTypeAnnotation(node, opts) {
        assert("FunctionTypeAnnotation", node, opts);
      }
      function assertFunctionTypeParam(node, opts) {
        assert("FunctionTypeParam", node, opts);
      }
      function assertGenericTypeAnnotation(node, opts) {
        assert("GenericTypeAnnotation", node, opts);
      }
      function assertInferredPredicate(node, opts) {
        assert("InferredPredicate", node, opts);
      }
      function assertInterfaceExtends(node, opts) {
        assert("InterfaceExtends", node, opts);
      }
      function assertInterfaceDeclaration(node, opts) {
        assert("InterfaceDeclaration", node, opts);
      }
      function assertInterfaceTypeAnnotation(node, opts) {
        assert("InterfaceTypeAnnotation", node, opts);
      }
      function assertIntersectionTypeAnnotation(node, opts) {
        assert("IntersectionTypeAnnotation", node, opts);
      }
      function assertMixedTypeAnnotation(node, opts) {
        assert("MixedTypeAnnotation", node, opts);
      }
      function assertEmptyTypeAnnotation(node, opts) {
        assert("EmptyTypeAnnotation", node, opts);
      }
      function assertNullableTypeAnnotation(node, opts) {
        assert("NullableTypeAnnotation", node, opts);
      }
      function assertNumberLiteralTypeAnnotation(node, opts) {
        assert("NumberLiteralTypeAnnotation", node, opts);
      }
      function assertNumberTypeAnnotation(node, opts) {
        assert("NumberTypeAnnotation", node, opts);
      }
      function assertObjectTypeAnnotation(node, opts) {
        assert("ObjectTypeAnnotation", node, opts);
      }
      function assertObjectTypeInternalSlot(node, opts) {
        assert("ObjectTypeInternalSlot", node, opts);
      }
      function assertObjectTypeCallProperty(node, opts) {
        assert("ObjectTypeCallProperty", node, opts);
      }
      function assertObjectTypeIndexer(node, opts) {
        assert("ObjectTypeIndexer", node, opts);
      }
      function assertObjectTypeProperty(node, opts) {
        assert("ObjectTypeProperty", node, opts);
      }
      function assertObjectTypeSpreadProperty(node, opts) {
        assert("ObjectTypeSpreadProperty", node, opts);
      }
      function assertOpaqueType(node, opts) {
        assert("OpaqueType", node, opts);
      }
      function assertQualifiedTypeIdentifier(node, opts) {
        assert("QualifiedTypeIdentifier", node, opts);
      }
      function assertStringLiteralTypeAnnotation(node, opts) {
        assert("StringLiteralTypeAnnotation", node, opts);
      }
      function assertStringTypeAnnotation(node, opts) {
        assert("StringTypeAnnotation", node, opts);
      }
      function assertSymbolTypeAnnotation(node, opts) {
        assert("SymbolTypeAnnotation", node, opts);
      }
      function assertThisTypeAnnotation(node, opts) {
        assert("ThisTypeAnnotation", node, opts);
      }
      function assertTupleTypeAnnotation(node, opts) {
        assert("TupleTypeAnnotation", node, opts);
      }
      function assertTypeofTypeAnnotation(node, opts) {
        assert("TypeofTypeAnnotation", node, opts);
      }
      function assertTypeAlias(node, opts) {
        assert("TypeAlias", node, opts);
      }
      function assertTypeAnnotation(node, opts) {
        assert("TypeAnnotation", node, opts);
      }
      function assertTypeCastExpression(node, opts) {
        assert("TypeCastExpression", node, opts);
      }
      function assertTypeParameter(node, opts) {
        assert("TypeParameter", node, opts);
      }
      function assertTypeParameterDeclaration(node, opts) {
        assert("TypeParameterDeclaration", node, opts);
      }
      function assertTypeParameterInstantiation(node, opts) {
        assert("TypeParameterInstantiation", node, opts);
      }
      function assertUnionTypeAnnotation(node, opts) {
        assert("UnionTypeAnnotation", node, opts);
      }
      function assertVariance(node, opts) {
        assert("Variance", node, opts);
      }
      function assertVoidTypeAnnotation(node, opts) {
        assert("VoidTypeAnnotation", node, opts);
      }
      function assertEnumDeclaration(node, opts) {
        assert("EnumDeclaration", node, opts);
      }
      function assertEnumBooleanBody(node, opts) {
        assert("EnumBooleanBody", node, opts);
      }
      function assertEnumNumberBody(node, opts) {
        assert("EnumNumberBody", node, opts);
      }
      function assertEnumStringBody(node, opts) {
        assert("EnumStringBody", node, opts);
      }
      function assertEnumSymbolBody(node, opts) {
        assert("EnumSymbolBody", node, opts);
      }
      function assertEnumBooleanMember(node, opts) {
        assert("EnumBooleanMember", node, opts);
      }
      function assertEnumNumberMember(node, opts) {
        assert("EnumNumberMember", node, opts);
      }
      function assertEnumStringMember(node, opts) {
        assert("EnumStringMember", node, opts);
      }
      function assertEnumDefaultedMember(node, opts) {
        assert("EnumDefaultedMember", node, opts);
      }
      function assertIndexedAccessType(node, opts) {
        assert("IndexedAccessType", node, opts);
      }
      function assertOptionalIndexedAccessType(node, opts) {
        assert("OptionalIndexedAccessType", node, opts);
      }
      function assertJSXAttribute(node, opts) {
        assert("JSXAttribute", node, opts);
      }
      function assertJSXClosingElement(node, opts) {
        assert("JSXClosingElement", node, opts);
      }
      function assertJSXElement(node, opts) {
        assert("JSXElement", node, opts);
      }
      function assertJSXEmptyExpression(node, opts) {
        assert("JSXEmptyExpression", node, opts);
      }
      function assertJSXExpressionContainer(node, opts) {
        assert("JSXExpressionContainer", node, opts);
      }
      function assertJSXSpreadChild(node, opts) {
        assert("JSXSpreadChild", node, opts);
      }
      function assertJSXIdentifier(node, opts) {
        assert("JSXIdentifier", node, opts);
      }
      function assertJSXMemberExpression(node, opts) {
        assert("JSXMemberExpression", node, opts);
      }
      function assertJSXNamespacedName(node, opts) {
        assert("JSXNamespacedName", node, opts);
      }
      function assertJSXOpeningElement(node, opts) {
        assert("JSXOpeningElement", node, opts);
      }
      function assertJSXSpreadAttribute(node, opts) {
        assert("JSXSpreadAttribute", node, opts);
      }
      function assertJSXText(node, opts) {
        assert("JSXText", node, opts);
      }
      function assertJSXFragment(node, opts) {
        assert("JSXFragment", node, opts);
      }
      function assertJSXOpeningFragment(node, opts) {
        assert("JSXOpeningFragment", node, opts);
      }
      function assertJSXClosingFragment(node, opts) {
        assert("JSXClosingFragment", node, opts);
      }
      function assertNoop(node, opts) {
        assert("Noop", node, opts);
      }
      function assertPlaceholder(node, opts) {
        assert("Placeholder", node, opts);
      }
      function assertV8IntrinsicIdentifier(node, opts) {
        assert("V8IntrinsicIdentifier", node, opts);
      }
      function assertArgumentPlaceholder(node, opts) {
        assert("ArgumentPlaceholder", node, opts);
      }
      function assertBindExpression(node, opts) {
        assert("BindExpression", node, opts);
      }
      function assertImportAttribute(node, opts) {
        assert("ImportAttribute", node, opts);
      }
      function assertDecorator(node, opts) {
        assert("Decorator", node, opts);
      }
      function assertDoExpression(node, opts) {
        assert("DoExpression", node, opts);
      }
      function assertExportDefaultSpecifier(node, opts) {
        assert("ExportDefaultSpecifier", node, opts);
      }
      function assertRecordExpression(node, opts) {
        assert("RecordExpression", node, opts);
      }
      function assertTupleExpression(node, opts) {
        assert("TupleExpression", node, opts);
      }
      function assertDecimalLiteral(node, opts) {
        assert("DecimalLiteral", node, opts);
      }
      function assertModuleExpression(node, opts) {
        assert("ModuleExpression", node, opts);
      }
      function assertTopicReference(node, opts) {
        assert("TopicReference", node, opts);
      }
      function assertPipelineTopicExpression(node, opts) {
        assert("PipelineTopicExpression", node, opts);
      }
      function assertPipelineBareFunction(node, opts) {
        assert("PipelineBareFunction", node, opts);
      }
      function assertPipelinePrimaryTopicReference(node, opts) {
        assert("PipelinePrimaryTopicReference", node, opts);
      }
      function assertTSParameterProperty(node, opts) {
        assert("TSParameterProperty", node, opts);
      }
      function assertTSDeclareFunction(node, opts) {
        assert("TSDeclareFunction", node, opts);
      }
      function assertTSDeclareMethod(node, opts) {
        assert("TSDeclareMethod", node, opts);
      }
      function assertTSQualifiedName(node, opts) {
        assert("TSQualifiedName", node, opts);
      }
      function assertTSCallSignatureDeclaration(node, opts) {
        assert("TSCallSignatureDeclaration", node, opts);
      }
      function assertTSConstructSignatureDeclaration(node, opts) {
        assert("TSConstructSignatureDeclaration", node, opts);
      }
      function assertTSPropertySignature(node, opts) {
        assert("TSPropertySignature", node, opts);
      }
      function assertTSMethodSignature(node, opts) {
        assert("TSMethodSignature", node, opts);
      }
      function assertTSIndexSignature(node, opts) {
        assert("TSIndexSignature", node, opts);
      }
      function assertTSAnyKeyword(node, opts) {
        assert("TSAnyKeyword", node, opts);
      }
      function assertTSBooleanKeyword(node, opts) {
        assert("TSBooleanKeyword", node, opts);
      }
      function assertTSBigIntKeyword(node, opts) {
        assert("TSBigIntKeyword", node, opts);
      }
      function assertTSIntrinsicKeyword(node, opts) {
        assert("TSIntrinsicKeyword", node, opts);
      }
      function assertTSNeverKeyword(node, opts) {
        assert("TSNeverKeyword", node, opts);
      }
      function assertTSNullKeyword(node, opts) {
        assert("TSNullKeyword", node, opts);
      }
      function assertTSNumberKeyword(node, opts) {
        assert("TSNumberKeyword", node, opts);
      }
      function assertTSObjectKeyword(node, opts) {
        assert("TSObjectKeyword", node, opts);
      }
      function assertTSStringKeyword(node, opts) {
        assert("TSStringKeyword", node, opts);
      }
      function assertTSSymbolKeyword(node, opts) {
        assert("TSSymbolKeyword", node, opts);
      }
      function assertTSUndefinedKeyword(node, opts) {
        assert("TSUndefinedKeyword", node, opts);
      }
      function assertTSUnknownKeyword(node, opts) {
        assert("TSUnknownKeyword", node, opts);
      }
      function assertTSVoidKeyword(node, opts) {
        assert("TSVoidKeyword", node, opts);
      }
      function assertTSThisType(node, opts) {
        assert("TSThisType", node, opts);
      }
      function assertTSFunctionType(node, opts) {
        assert("TSFunctionType", node, opts);
      }
      function assertTSConstructorType(node, opts) {
        assert("TSConstructorType", node, opts);
      }
      function assertTSTypeReference(node, opts) {
        assert("TSTypeReference", node, opts);
      }
      function assertTSTypePredicate(node, opts) {
        assert("TSTypePredicate", node, opts);
      }
      function assertTSTypeQuery(node, opts) {
        assert("TSTypeQuery", node, opts);
      }
      function assertTSTypeLiteral(node, opts) {
        assert("TSTypeLiteral", node, opts);
      }
      function assertTSArrayType(node, opts) {
        assert("TSArrayType", node, opts);
      }
      function assertTSTupleType(node, opts) {
        assert("TSTupleType", node, opts);
      }
      function assertTSOptionalType(node, opts) {
        assert("TSOptionalType", node, opts);
      }
      function assertTSRestType(node, opts) {
        assert("TSRestType", node, opts);
      }
      function assertTSNamedTupleMember(node, opts) {
        assert("TSNamedTupleMember", node, opts);
      }
      function assertTSUnionType(node, opts) {
        assert("TSUnionType", node, opts);
      }
      function assertTSIntersectionType(node, opts) {
        assert("TSIntersectionType", node, opts);
      }
      function assertTSConditionalType(node, opts) {
        assert("TSConditionalType", node, opts);
      }
      function assertTSInferType(node, opts) {
        assert("TSInferType", node, opts);
      }
      function assertTSParenthesizedType(node, opts) {
        assert("TSParenthesizedType", node, opts);
      }
      function assertTSTypeOperator(node, opts) {
        assert("TSTypeOperator", node, opts);
      }
      function assertTSIndexedAccessType(node, opts) {
        assert("TSIndexedAccessType", node, opts);
      }
      function assertTSMappedType(node, opts) {
        assert("TSMappedType", node, opts);
      }
      function assertTSLiteralType(node, opts) {
        assert("TSLiteralType", node, opts);
      }
      function assertTSExpressionWithTypeArguments(node, opts) {
        assert("TSExpressionWithTypeArguments", node, opts);
      }
      function assertTSInterfaceDeclaration(node, opts) {
        assert("TSInterfaceDeclaration", node, opts);
      }
      function assertTSInterfaceBody(node, opts) {
        assert("TSInterfaceBody", node, opts);
      }
      function assertTSTypeAliasDeclaration(node, opts) {
        assert("TSTypeAliasDeclaration", node, opts);
      }
      function assertTSInstantiationExpression(node, opts) {
        assert("TSInstantiationExpression", node, opts);
      }
      function assertTSAsExpression(node, opts) {
        assert("TSAsExpression", node, opts);
      }
      function assertTSTypeAssertion(node, opts) {
        assert("TSTypeAssertion", node, opts);
      }
      function assertTSEnumDeclaration(node, opts) {
        assert("TSEnumDeclaration", node, opts);
      }
      function assertTSEnumMember(node, opts) {
        assert("TSEnumMember", node, opts);
      }
      function assertTSModuleDeclaration(node, opts) {
        assert("TSModuleDeclaration", node, opts);
      }
      function assertTSModuleBlock(node, opts) {
        assert("TSModuleBlock", node, opts);
      }
      function assertTSImportType(node, opts) {
        assert("TSImportType", node, opts);
      }
      function assertTSImportEqualsDeclaration(node, opts) {
        assert("TSImportEqualsDeclaration", node, opts);
      }
      function assertTSExternalModuleReference(node, opts) {
        assert("TSExternalModuleReference", node, opts);
      }
      function assertTSNonNullExpression(node, opts) {
        assert("TSNonNullExpression", node, opts);
      }
      function assertTSExportAssignment(node, opts) {
        assert("TSExportAssignment", node, opts);
      }
      function assertTSNamespaceExportDeclaration(node, opts) {
        assert("TSNamespaceExportDeclaration", node, opts);
      }
      function assertTSTypeAnnotation(node, opts) {
        assert("TSTypeAnnotation", node, opts);
      }
      function assertTSTypeParameterInstantiation(node, opts) {
        assert("TSTypeParameterInstantiation", node, opts);
      }
      function assertTSTypeParameterDeclaration(node, opts) {
        assert("TSTypeParameterDeclaration", node, opts);
      }
      function assertTSTypeParameter(node, opts) {
        assert("TSTypeParameter", node, opts);
      }
      function assertStandardized(node, opts) {
        assert("Standardized", node, opts);
      }
      function assertExpression(node, opts) {
        assert("Expression", node, opts);
      }
      function assertBinary(node, opts) {
        assert("Binary", node, opts);
      }
      function assertScopable(node, opts) {
        assert("Scopable", node, opts);
      }
      function assertBlockParent(node, opts) {
        assert("BlockParent", node, opts);
      }
      function assertBlock(node, opts) {
        assert("Block", node, opts);
      }
      function assertStatement(node, opts) {
        assert("Statement", node, opts);
      }
      function assertTerminatorless(node, opts) {
        assert("Terminatorless", node, opts);
      }
      function assertCompletionStatement(node, opts) {
        assert("CompletionStatement", node, opts);
      }
      function assertConditional(node, opts) {
        assert("Conditional", node, opts);
      }
      function assertLoop(node, opts) {
        assert("Loop", node, opts);
      }
      function assertWhile(node, opts) {
        assert("While", node, opts);
      }
      function assertExpressionWrapper(node, opts) {
        assert("ExpressionWrapper", node, opts);
      }
      function assertFor(node, opts) {
        assert("For", node, opts);
      }
      function assertForXStatement(node, opts) {
        assert("ForXStatement", node, opts);
      }
      function assertFunction(node, opts) {
        assert("Function", node, opts);
      }
      function assertFunctionParent(node, opts) {
        assert("FunctionParent", node, opts);
      }
      function assertPureish(node, opts) {
        assert("Pureish", node, opts);
      }
      function assertDeclaration(node, opts) {
        assert("Declaration", node, opts);
      }
      function assertPatternLike(node, opts) {
        assert("PatternLike", node, opts);
      }
      function assertLVal(node, opts) {
        assert("LVal", node, opts);
      }
      function assertTSEntityName(node, opts) {
        assert("TSEntityName", node, opts);
      }
      function assertLiteral(node, opts) {
        assert("Literal", node, opts);
      }
      function assertImmutable(node, opts) {
        assert("Immutable", node, opts);
      }
      function assertUserWhitespacable(node, opts) {
        assert("UserWhitespacable", node, opts);
      }
      function assertMethod(node, opts) {
        assert("Method", node, opts);
      }
      function assertObjectMember(node, opts) {
        assert("ObjectMember", node, opts);
      }
      function assertProperty(node, opts) {
        assert("Property", node, opts);
      }
      function assertUnaryLike(node, opts) {
        assert("UnaryLike", node, opts);
      }
      function assertPattern(node, opts) {
        assert("Pattern", node, opts);
      }
      function assertClass(node, opts) {
        assert("Class", node, opts);
      }
      function assertModuleDeclaration(node, opts) {
        assert("ModuleDeclaration", node, opts);
      }
      function assertExportDeclaration(node, opts) {
        assert("ExportDeclaration", node, opts);
      }
      function assertModuleSpecifier(node, opts) {
        assert("ModuleSpecifier", node, opts);
      }
      function assertAccessor(node, opts) {
        assert("Accessor", node, opts);
      }
      function assertPrivate(node, opts) {
        assert("Private", node, opts);
      }
      function assertFlow(node, opts) {
        assert("Flow", node, opts);
      }
      function assertFlowType(node, opts) {
        assert("FlowType", node, opts);
      }
      function assertFlowBaseAnnotation(node, opts) {
        assert("FlowBaseAnnotation", node, opts);
      }
      function assertFlowDeclaration(node, opts) {
        assert("FlowDeclaration", node, opts);
      }
      function assertFlowPredicate(node, opts) {
        assert("FlowPredicate", node, opts);
      }
      function assertEnumBody(node, opts) {
        assert("EnumBody", node, opts);
      }
      function assertEnumMember(node, opts) {
        assert("EnumMember", node, opts);
      }
      function assertJSX(node, opts) {
        assert("JSX", node, opts);
      }
      function assertMiscellaneous(node, opts) {
        assert("Miscellaneous", node, opts);
      }
      function assertTypeScript(node, opts) {
        assert("TypeScript", node, opts);
      }
      function assertTSTypeElement(node, opts) {
        assert("TSTypeElement", node, opts);
      }
      function assertTSType(node, opts) {
        assert("TSType", node, opts);
      }
      function assertTSBaseType(node, opts) {
        assert("TSBaseType", node, opts);
      }
      function assertNumberLiteral(node, opts) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
        assert("NumberLiteral", node, opts);
      }
      function assertRegexLiteral(node, opts) {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
        assert("RegexLiteral", node, opts);
      }
      function assertRestProperty(node, opts) {
        console.trace("The node type RestProperty has been renamed to RestElement");
        assert("RestProperty", node, opts);
      }
      function assertSpreadProperty(node, opts) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement");
        assert("SpreadProperty", node, opts);
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
  var require_createTypeAnnotationBasedOnTypeof = __commonJS({
    "../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated2();
      var _default = createTypeAnnotationBasedOnTypeof;
      exports.default = _default;
      function createTypeAnnotationBasedOnTypeof(type) {
        switch (type) {
          case "string":
            return (0, _generated.stringTypeAnnotation)();
          case "number":
            return (0, _generated.numberTypeAnnotation)();
          case "undefined":
            return (0, _generated.voidTypeAnnotation)();
          case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
          case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
          case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
          case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
          case "bigint":
            return (0, _generated.anyTypeAnnotation)();
        }
        throw new Error("Invalid typeof value: " + type);
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
  var require_removeTypeDuplicates = __commonJS({
    "../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeTypeDuplicates;
      var _generated = require_generated();
      function getQualifiedName(node) {
        return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
      }
      function removeTypeDuplicates(nodes) {
        const generics = /* @__PURE__ */ new Map();
        const bases = /* @__PURE__ */ new Map();
        const typeGroups = /* @__PURE__ */ new Set();
        const types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node)
            continue;
          if (types.indexOf(node) >= 0) {
            continue;
          }
          if ((0, _generated.isAnyTypeAnnotation)(node)) {
            return [node];
          }
          if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases.set(node.type, node);
            continue;
          }
          if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
              nodes = nodes.concat(node.types);
              typeGroups.add(node.types);
            }
            continue;
          }
          if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name = getQualifiedName(node.id);
            if (generics.has(name)) {
              let existing = generics.get(name);
              if (existing.typeParameters) {
                if (node.typeParameters) {
                  existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                }
              } else {
                existing = node.typeParameters;
              }
            } else {
              generics.set(name, node);
            }
            continue;
          }
          types.push(node);
        }
        for (const [, baseType] of bases) {
          types.push(baseType);
        }
        for (const [, genericName] of generics) {
          types.push(genericName);
        }
        return types;
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
  var require_createFlowUnionType = __commonJS({
    "../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createFlowUnionType;
      var _generated = require_generated2();
      var _removeTypeDuplicates = require_removeTypeDuplicates();
      function createFlowUnionType(types) {
        const flattened = (0, _removeTypeDuplicates.default)(types);
        if (flattened.length === 1) {
          return flattened[0];
        } else {
          return (0, _generated.unionTypeAnnotation)(flattened);
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
  var require_removeTypeDuplicates2 = __commonJS({
    "../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeTypeDuplicates;
      var _generated = require_generated();
      function getQualifiedName(node) {
        return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
      }
      function removeTypeDuplicates(nodes) {
        const generics = /* @__PURE__ */ new Map();
        const bases = /* @__PURE__ */ new Map();
        const typeGroups = /* @__PURE__ */ new Set();
        const types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node)
            continue;
          if (types.indexOf(node) >= 0) {
            continue;
          }
          if ((0, _generated.isTSAnyKeyword)(node)) {
            return [node];
          }
          if ((0, _generated.isTSBaseType)(node)) {
            bases.set(node.type, node);
            continue;
          }
          if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
              nodes.push(...node.types);
              typeGroups.add(node.types);
            }
            continue;
          }
          if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
            const name = getQualifiedName(node.typeName);
            if (generics.has(name)) {
              let existing = generics.get(name);
              if (existing.typeParameters) {
                if (node.typeParameters) {
                  existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                }
              } else {
                existing = node.typeParameters;
              }
            } else {
              generics.set(name, node);
            }
            continue;
          }
          types.push(node);
        }
        for (const [, baseType] of bases) {
          types.push(baseType);
        }
        for (const [, genericName] of generics) {
          types.push(genericName);
        }
        return types;
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
  var require_createTSUnionType = __commonJS({
    "../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createTSUnionType;
      var _generated = require_generated2();
      var _removeTypeDuplicates = require_removeTypeDuplicates2();
      var _index = require_generated();
      function createTSUnionType(typeAnnotations) {
        const types = typeAnnotations.map((type) => {
          return (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
        });
        const flattened = (0, _removeTypeDuplicates.default)(types);
        if (flattened.length === 1) {
          return flattened[0];
        } else {
          return (0, _generated.tsUnionType)(flattened);
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/builders/generated/uppercase.js
  var require_uppercase = __commonJS({
    "../node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AnyTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.anyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArgumentPlaceholder", {
        enumerable: true,
        get: function() {
          return _index.argumentPlaceholder;
        }
      });
      Object.defineProperty(exports, "ArrayExpression", {
        enumerable: true,
        get: function() {
          return _index.arrayExpression;
        }
      });
      Object.defineProperty(exports, "ArrayPattern", {
        enumerable: true,
        get: function() {
          return _index.arrayPattern;
        }
      });
      Object.defineProperty(exports, "ArrayTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.arrayTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArrowFunctionExpression", {
        enumerable: true,
        get: function() {
          return _index.arrowFunctionExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentExpression", {
        enumerable: true,
        get: function() {
          return _index.assignmentExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentPattern", {
        enumerable: true,
        get: function() {
          return _index.assignmentPattern;
        }
      });
      Object.defineProperty(exports, "AwaitExpression", {
        enumerable: true,
        get: function() {
          return _index.awaitExpression;
        }
      });
      Object.defineProperty(exports, "BigIntLiteral", {
        enumerable: true,
        get: function() {
          return _index.bigIntLiteral;
        }
      });
      Object.defineProperty(exports, "BinaryExpression", {
        enumerable: true,
        get: function() {
          return _index.binaryExpression;
        }
      });
      Object.defineProperty(exports, "BindExpression", {
        enumerable: true,
        get: function() {
          return _index.bindExpression;
        }
      });
      Object.defineProperty(exports, "BlockStatement", {
        enumerable: true,
        get: function() {
          return _index.blockStatement;
        }
      });
      Object.defineProperty(exports, "BooleanLiteral", {
        enumerable: true,
        get: function() {
          return _index.booleanLiteral;
        }
      });
      Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.booleanLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BooleanTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.booleanTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BreakStatement", {
        enumerable: true,
        get: function() {
          return _index.breakStatement;
        }
      });
      Object.defineProperty(exports, "CallExpression", {
        enumerable: true,
        get: function() {
          return _index.callExpression;
        }
      });
      Object.defineProperty(exports, "CatchClause", {
        enumerable: true,
        get: function() {
          return _index.catchClause;
        }
      });
      Object.defineProperty(exports, "ClassAccessorProperty", {
        enumerable: true,
        get: function() {
          return _index.classAccessorProperty;
        }
      });
      Object.defineProperty(exports, "ClassBody", {
        enumerable: true,
        get: function() {
          return _index.classBody;
        }
      });
      Object.defineProperty(exports, "ClassDeclaration", {
        enumerable: true,
        get: function() {
          return _index.classDeclaration;
        }
      });
      Object.defineProperty(exports, "ClassExpression", {
        enumerable: true,
        get: function() {
          return _index.classExpression;
        }
      });
      Object.defineProperty(exports, "ClassImplements", {
        enumerable: true,
        get: function() {
          return _index.classImplements;
        }
      });
      Object.defineProperty(exports, "ClassMethod", {
        enumerable: true,
        get: function() {
          return _index.classMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateMethod", {
        enumerable: true,
        get: function() {
          return _index.classPrivateMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateProperty", {
        enumerable: true,
        get: function() {
          return _index.classPrivateProperty;
        }
      });
      Object.defineProperty(exports, "ClassProperty", {
        enumerable: true,
        get: function() {
          return _index.classProperty;
        }
      });
      Object.defineProperty(exports, "ConditionalExpression", {
        enumerable: true,
        get: function() {
          return _index.conditionalExpression;
        }
      });
      Object.defineProperty(exports, "ContinueStatement", {
        enumerable: true,
        get: function() {
          return _index.continueStatement;
        }
      });
      Object.defineProperty(exports, "DebuggerStatement", {
        enumerable: true,
        get: function() {
          return _index.debuggerStatement;
        }
      });
      Object.defineProperty(exports, "DecimalLiteral", {
        enumerable: true,
        get: function() {
          return _index.decimalLiteral;
        }
      });
      Object.defineProperty(exports, "DeclareClass", {
        enumerable: true,
        get: function() {
          return _index.declareClass;
        }
      });
      Object.defineProperty(exports, "DeclareExportAllDeclaration", {
        enumerable: true,
        get: function() {
          return _index.declareExportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareExportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.declareExportDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareFunction", {
        enumerable: true,
        get: function() {
          return _index.declareFunction;
        }
      });
      Object.defineProperty(exports, "DeclareInterface", {
        enumerable: true,
        get: function() {
          return _index.declareInterface;
        }
      });
      Object.defineProperty(exports, "DeclareModule", {
        enumerable: true,
        get: function() {
          return _index.declareModule;
        }
      });
      Object.defineProperty(exports, "DeclareModuleExports", {
        enumerable: true,
        get: function() {
          return _index.declareModuleExports;
        }
      });
      Object.defineProperty(exports, "DeclareOpaqueType", {
        enumerable: true,
        get: function() {
          return _index.declareOpaqueType;
        }
      });
      Object.defineProperty(exports, "DeclareTypeAlias", {
        enumerable: true,
        get: function() {
          return _index.declareTypeAlias;
        }
      });
      Object.defineProperty(exports, "DeclareVariable", {
        enumerable: true,
        get: function() {
          return _index.declareVariable;
        }
      });
      Object.defineProperty(exports, "DeclaredPredicate", {
        enumerable: true,
        get: function() {
          return _index.declaredPredicate;
        }
      });
      Object.defineProperty(exports, "Decorator", {
        enumerable: true,
        get: function() {
          return _index.decorator;
        }
      });
      Object.defineProperty(exports, "Directive", {
        enumerable: true,
        get: function() {
          return _index.directive;
        }
      });
      Object.defineProperty(exports, "DirectiveLiteral", {
        enumerable: true,
        get: function() {
          return _index.directiveLiteral;
        }
      });
      Object.defineProperty(exports, "DoExpression", {
        enumerable: true,
        get: function() {
          return _index.doExpression;
        }
      });
      Object.defineProperty(exports, "DoWhileStatement", {
        enumerable: true,
        get: function() {
          return _index.doWhileStatement;
        }
      });
      Object.defineProperty(exports, "EmptyStatement", {
        enumerable: true,
        get: function() {
          return _index.emptyStatement;
        }
      });
      Object.defineProperty(exports, "EmptyTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.emptyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "EnumBooleanBody", {
        enumerable: true,
        get: function() {
          return _index.enumBooleanBody;
        }
      });
      Object.defineProperty(exports, "EnumBooleanMember", {
        enumerable: true,
        get: function() {
          return _index.enumBooleanMember;
        }
      });
      Object.defineProperty(exports, "EnumDeclaration", {
        enumerable: true,
        get: function() {
          return _index.enumDeclaration;
        }
      });
      Object.defineProperty(exports, "EnumDefaultedMember", {
        enumerable: true,
        get: function() {
          return _index.enumDefaultedMember;
        }
      });
      Object.defineProperty(exports, "EnumNumberBody", {
        enumerable: true,
        get: function() {
          return _index.enumNumberBody;
        }
      });
      Object.defineProperty(exports, "EnumNumberMember", {
        enumerable: true,
        get: function() {
          return _index.enumNumberMember;
        }
      });
      Object.defineProperty(exports, "EnumStringBody", {
        enumerable: true,
        get: function() {
          return _index.enumStringBody;
        }
      });
      Object.defineProperty(exports, "EnumStringMember", {
        enumerable: true,
        get: function() {
          return _index.enumStringMember;
        }
      });
      Object.defineProperty(exports, "EnumSymbolBody", {
        enumerable: true,
        get: function() {
          return _index.enumSymbolBody;
        }
      });
      Object.defineProperty(exports, "ExistsTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.existsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ExportAllDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportDefaultDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportNamedDeclaration", {
        enumerable: true,
        get: function() {
          return _index.exportNamedDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportNamespaceSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportSpecifier", {
        enumerable: true,
        get: function() {
          return _index.exportSpecifier;
        }
      });
      Object.defineProperty(exports, "ExpressionStatement", {
        enumerable: true,
        get: function() {
          return _index.expressionStatement;
        }
      });
      Object.defineProperty(exports, "File", {
        enumerable: true,
        get: function() {
          return _index.file;
        }
      });
      Object.defineProperty(exports, "ForInStatement", {
        enumerable: true,
        get: function() {
          return _index.forInStatement;
        }
      });
      Object.defineProperty(exports, "ForOfStatement", {
        enumerable: true,
        get: function() {
          return _index.forOfStatement;
        }
      });
      Object.defineProperty(exports, "ForStatement", {
        enumerable: true,
        get: function() {
          return _index.forStatement;
        }
      });
      Object.defineProperty(exports, "FunctionDeclaration", {
        enumerable: true,
        get: function() {
          return _index.functionDeclaration;
        }
      });
      Object.defineProperty(exports, "FunctionExpression", {
        enumerable: true,
        get: function() {
          return _index.functionExpression;
        }
      });
      Object.defineProperty(exports, "FunctionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.functionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "FunctionTypeParam", {
        enumerable: true,
        get: function() {
          return _index.functionTypeParam;
        }
      });
      Object.defineProperty(exports, "GenericTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.genericTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Identifier", {
        enumerable: true,
        get: function() {
          return _index.identifier;
        }
      });
      Object.defineProperty(exports, "IfStatement", {
        enumerable: true,
        get: function() {
          return _index.ifStatement;
        }
      });
      Object.defineProperty(exports, "Import", {
        enumerable: true,
        get: function() {
          return _index.import;
        }
      });
      Object.defineProperty(exports, "ImportAttribute", {
        enumerable: true,
        get: function() {
          return _index.importAttribute;
        }
      });
      Object.defineProperty(exports, "ImportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.importDeclaration;
        }
      });
      Object.defineProperty(exports, "ImportDefaultSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportNamespaceSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportSpecifier", {
        enumerable: true,
        get: function() {
          return _index.importSpecifier;
        }
      });
      Object.defineProperty(exports, "IndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.indexedAccessType;
        }
      });
      Object.defineProperty(exports, "InferredPredicate", {
        enumerable: true,
        get: function() {
          return _index.inferredPredicate;
        }
      });
      Object.defineProperty(exports, "InterfaceDeclaration", {
        enumerable: true,
        get: function() {
          return _index.interfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "InterfaceExtends", {
        enumerable: true,
        get: function() {
          return _index.interfaceExtends;
        }
      });
      Object.defineProperty(exports, "InterfaceTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.interfaceTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "InterpreterDirective", {
        enumerable: true,
        get: function() {
          return _index.interpreterDirective;
        }
      });
      Object.defineProperty(exports, "IntersectionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.intersectionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "JSXAttribute", {
        enumerable: true,
        get: function() {
          return _index.jsxAttribute;
        }
      });
      Object.defineProperty(exports, "JSXClosingElement", {
        enumerable: true,
        get: function() {
          return _index.jsxClosingElement;
        }
      });
      Object.defineProperty(exports, "JSXClosingFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxClosingFragment;
        }
      });
      Object.defineProperty(exports, "JSXElement", {
        enumerable: true,
        get: function() {
          return _index.jsxElement;
        }
      });
      Object.defineProperty(exports, "JSXEmptyExpression", {
        enumerable: true,
        get: function() {
          return _index.jsxEmptyExpression;
        }
      });
      Object.defineProperty(exports, "JSXExpressionContainer", {
        enumerable: true,
        get: function() {
          return _index.jsxExpressionContainer;
        }
      });
      Object.defineProperty(exports, "JSXFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxFragment;
        }
      });
      Object.defineProperty(exports, "JSXIdentifier", {
        enumerable: true,
        get: function() {
          return _index.jsxIdentifier;
        }
      });
      Object.defineProperty(exports, "JSXMemberExpression", {
        enumerable: true,
        get: function() {
          return _index.jsxMemberExpression;
        }
      });
      Object.defineProperty(exports, "JSXNamespacedName", {
        enumerable: true,
        get: function() {
          return _index.jsxNamespacedName;
        }
      });
      Object.defineProperty(exports, "JSXOpeningElement", {
        enumerable: true,
        get: function() {
          return _index.jsxOpeningElement;
        }
      });
      Object.defineProperty(exports, "JSXOpeningFragment", {
        enumerable: true,
        get: function() {
          return _index.jsxOpeningFragment;
        }
      });
      Object.defineProperty(exports, "JSXSpreadAttribute", {
        enumerable: true,
        get: function() {
          return _index.jsxSpreadAttribute;
        }
      });
      Object.defineProperty(exports, "JSXSpreadChild", {
        enumerable: true,
        get: function() {
          return _index.jsxSpreadChild;
        }
      });
      Object.defineProperty(exports, "JSXText", {
        enumerable: true,
        get: function() {
          return _index.jsxText;
        }
      });
      Object.defineProperty(exports, "LabeledStatement", {
        enumerable: true,
        get: function() {
          return _index.labeledStatement;
        }
      });
      Object.defineProperty(exports, "LogicalExpression", {
        enumerable: true,
        get: function() {
          return _index.logicalExpression;
        }
      });
      Object.defineProperty(exports, "MemberExpression", {
        enumerable: true,
        get: function() {
          return _index.memberExpression;
        }
      });
      Object.defineProperty(exports, "MetaProperty", {
        enumerable: true,
        get: function() {
          return _index.metaProperty;
        }
      });
      Object.defineProperty(exports, "MixedTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.mixedTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ModuleExpression", {
        enumerable: true,
        get: function() {
          return _index.moduleExpression;
        }
      });
      Object.defineProperty(exports, "NewExpression", {
        enumerable: true,
        get: function() {
          return _index.newExpression;
        }
      });
      Object.defineProperty(exports, "Noop", {
        enumerable: true,
        get: function() {
          return _index.noop;
        }
      });
      Object.defineProperty(exports, "NullLiteral", {
        enumerable: true,
        get: function() {
          return _index.nullLiteral;
        }
      });
      Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.nullLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NullableTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.nullableTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberLiteral", {
        enumerable: true,
        get: function() {
          return _index.numberLiteral;
        }
      });
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.numberLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.numberTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumericLiteral", {
        enumerable: true,
        get: function() {
          return _index.numericLiteral;
        }
      });
      Object.defineProperty(exports, "ObjectExpression", {
        enumerable: true,
        get: function() {
          return _index.objectExpression;
        }
      });
      Object.defineProperty(exports, "ObjectMethod", {
        enumerable: true,
        get: function() {
          return _index.objectMethod;
        }
      });
      Object.defineProperty(exports, "ObjectPattern", {
        enumerable: true,
        get: function() {
          return _index.objectPattern;
        }
      });
      Object.defineProperty(exports, "ObjectProperty", {
        enumerable: true,
        get: function() {
          return _index.objectProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.objectTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ObjectTypeCallProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeCallProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeIndexer", {
        enumerable: true,
        get: function() {
          return _index.objectTypeIndexer;
        }
      });
      Object.defineProperty(exports, "ObjectTypeInternalSlot", {
        enumerable: true,
        get: function() {
          return _index.objectTypeInternalSlot;
        }
      });
      Object.defineProperty(exports, "ObjectTypeProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
        enumerable: true,
        get: function() {
          return _index.objectTypeSpreadProperty;
        }
      });
      Object.defineProperty(exports, "OpaqueType", {
        enumerable: true,
        get: function() {
          return _index.opaqueType;
        }
      });
      Object.defineProperty(exports, "OptionalCallExpression", {
        enumerable: true,
        get: function() {
          return _index.optionalCallExpression;
        }
      });
      Object.defineProperty(exports, "OptionalIndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.optionalIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "OptionalMemberExpression", {
        enumerable: true,
        get: function() {
          return _index.optionalMemberExpression;
        }
      });
      Object.defineProperty(exports, "ParenthesizedExpression", {
        enumerable: true,
        get: function() {
          return _index.parenthesizedExpression;
        }
      });
      Object.defineProperty(exports, "PipelineBareFunction", {
        enumerable: true,
        get: function() {
          return _index.pipelineBareFunction;
        }
      });
      Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
        enumerable: true,
        get: function() {
          return _index.pipelinePrimaryTopicReference;
        }
      });
      Object.defineProperty(exports, "PipelineTopicExpression", {
        enumerable: true,
        get: function() {
          return _index.pipelineTopicExpression;
        }
      });
      Object.defineProperty(exports, "Placeholder", {
        enumerable: true,
        get: function() {
          return _index.placeholder;
        }
      });
      Object.defineProperty(exports, "PrivateName", {
        enumerable: true,
        get: function() {
          return _index.privateName;
        }
      });
      Object.defineProperty(exports, "Program", {
        enumerable: true,
        get: function() {
          return _index.program;
        }
      });
      Object.defineProperty(exports, "QualifiedTypeIdentifier", {
        enumerable: true,
        get: function() {
          return _index.qualifiedTypeIdentifier;
        }
      });
      Object.defineProperty(exports, "RecordExpression", {
        enumerable: true,
        get: function() {
          return _index.recordExpression;
        }
      });
      Object.defineProperty(exports, "RegExpLiteral", {
        enumerable: true,
        get: function() {
          return _index.regExpLiteral;
        }
      });
      Object.defineProperty(exports, "RegexLiteral", {
        enumerable: true,
        get: function() {
          return _index.regexLiteral;
        }
      });
      Object.defineProperty(exports, "RestElement", {
        enumerable: true,
        get: function() {
          return _index.restElement;
        }
      });
      Object.defineProperty(exports, "RestProperty", {
        enumerable: true,
        get: function() {
          return _index.restProperty;
        }
      });
      Object.defineProperty(exports, "ReturnStatement", {
        enumerable: true,
        get: function() {
          return _index.returnStatement;
        }
      });
      Object.defineProperty(exports, "SequenceExpression", {
        enumerable: true,
        get: function() {
          return _index.sequenceExpression;
        }
      });
      Object.defineProperty(exports, "SpreadElement", {
        enumerable: true,
        get: function() {
          return _index.spreadElement;
        }
      });
      Object.defineProperty(exports, "SpreadProperty", {
        enumerable: true,
        get: function() {
          return _index.spreadProperty;
        }
      });
      Object.defineProperty(exports, "StaticBlock", {
        enumerable: true,
        get: function() {
          return _index.staticBlock;
        }
      });
      Object.defineProperty(exports, "StringLiteral", {
        enumerable: true,
        get: function() {
          return _index.stringLiteral;
        }
      });
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.stringLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "StringTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.stringTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Super", {
        enumerable: true,
        get: function() {
          return _index.super;
        }
      });
      Object.defineProperty(exports, "SwitchCase", {
        enumerable: true,
        get: function() {
          return _index.switchCase;
        }
      });
      Object.defineProperty(exports, "SwitchStatement", {
        enumerable: true,
        get: function() {
          return _index.switchStatement;
        }
      });
      Object.defineProperty(exports, "SymbolTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.symbolTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSAnyKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsAnyKeyword;
        }
      });
      Object.defineProperty(exports, "TSArrayType", {
        enumerable: true,
        get: function() {
          return _index.tsArrayType;
        }
      });
      Object.defineProperty(exports, "TSAsExpression", {
        enumerable: true,
        get: function() {
          return _index.tsAsExpression;
        }
      });
      Object.defineProperty(exports, "TSBigIntKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsBigIntKeyword;
        }
      });
      Object.defineProperty(exports, "TSBooleanKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsBooleanKeyword;
        }
      });
      Object.defineProperty(exports, "TSCallSignatureDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsCallSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConditionalType", {
        enumerable: true,
        get: function() {
          return _index.tsConditionalType;
        }
      });
      Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsConstructSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConstructorType", {
        enumerable: true,
        get: function() {
          return _index.tsConstructorType;
        }
      });
      Object.defineProperty(exports, "TSDeclareFunction", {
        enumerable: true,
        get: function() {
          return _index.tsDeclareFunction;
        }
      });
      Object.defineProperty(exports, "TSDeclareMethod", {
        enumerable: true,
        get: function() {
          return _index.tsDeclareMethod;
        }
      });
      Object.defineProperty(exports, "TSEnumDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsEnumDeclaration;
        }
      });
      Object.defineProperty(exports, "TSEnumMember", {
        enumerable: true,
        get: function() {
          return _index.tsEnumMember;
        }
      });
      Object.defineProperty(exports, "TSExportAssignment", {
        enumerable: true,
        get: function() {
          return _index.tsExportAssignment;
        }
      });
      Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
        enumerable: true,
        get: function() {
          return _index.tsExpressionWithTypeArguments;
        }
      });
      Object.defineProperty(exports, "TSExternalModuleReference", {
        enumerable: true,
        get: function() {
          return _index.tsExternalModuleReference;
        }
      });
      Object.defineProperty(exports, "TSFunctionType", {
        enumerable: true,
        get: function() {
          return _index.tsFunctionType;
        }
      });
      Object.defineProperty(exports, "TSImportEqualsDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsImportEqualsDeclaration;
        }
      });
      Object.defineProperty(exports, "TSImportType", {
        enumerable: true,
        get: function() {
          return _index.tsImportType;
        }
      });
      Object.defineProperty(exports, "TSIndexSignature", {
        enumerable: true,
        get: function() {
          return _index.tsIndexSignature;
        }
      });
      Object.defineProperty(exports, "TSIndexedAccessType", {
        enumerable: true,
        get: function() {
          return _index.tsIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "TSInferType", {
        enumerable: true,
        get: function() {
          return _index.tsInferType;
        }
      });
      Object.defineProperty(exports, "TSInstantiationExpression", {
        enumerable: true,
        get: function() {
          return _index.tsInstantiationExpression;
        }
      });
      Object.defineProperty(exports, "TSInterfaceBody", {
        enumerable: true,
        get: function() {
          return _index.tsInterfaceBody;
        }
      });
      Object.defineProperty(exports, "TSInterfaceDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsInterfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "TSIntersectionType", {
        enumerable: true,
        get: function() {
          return _index.tsIntersectionType;
        }
      });
      Object.defineProperty(exports, "TSIntrinsicKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsIntrinsicKeyword;
        }
      });
      Object.defineProperty(exports, "TSLiteralType", {
        enumerable: true,
        get: function() {
          return _index.tsLiteralType;
        }
      });
      Object.defineProperty(exports, "TSMappedType", {
        enumerable: true,
        get: function() {
          return _index.tsMappedType;
        }
      });
      Object.defineProperty(exports, "TSMethodSignature", {
        enumerable: true,
        get: function() {
          return _index.tsMethodSignature;
        }
      });
      Object.defineProperty(exports, "TSModuleBlock", {
        enumerable: true,
        get: function() {
          return _index.tsModuleBlock;
        }
      });
      Object.defineProperty(exports, "TSModuleDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsModuleDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNamedTupleMember", {
        enumerable: true,
        get: function() {
          return _index.tsNamedTupleMember;
        }
      });
      Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsNamespaceExportDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNeverKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNeverKeyword;
        }
      });
      Object.defineProperty(exports, "TSNonNullExpression", {
        enumerable: true,
        get: function() {
          return _index.tsNonNullExpression;
        }
      });
      Object.defineProperty(exports, "TSNullKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNullKeyword;
        }
      });
      Object.defineProperty(exports, "TSNumberKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsNumberKeyword;
        }
      });
      Object.defineProperty(exports, "TSObjectKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsObjectKeyword;
        }
      });
      Object.defineProperty(exports, "TSOptionalType", {
        enumerable: true,
        get: function() {
          return _index.tsOptionalType;
        }
      });
      Object.defineProperty(exports, "TSParameterProperty", {
        enumerable: true,
        get: function() {
          return _index.tsParameterProperty;
        }
      });
      Object.defineProperty(exports, "TSParenthesizedType", {
        enumerable: true,
        get: function() {
          return _index.tsParenthesizedType;
        }
      });
      Object.defineProperty(exports, "TSPropertySignature", {
        enumerable: true,
        get: function() {
          return _index.tsPropertySignature;
        }
      });
      Object.defineProperty(exports, "TSQualifiedName", {
        enumerable: true,
        get: function() {
          return _index.tsQualifiedName;
        }
      });
      Object.defineProperty(exports, "TSRestType", {
        enumerable: true,
        get: function() {
          return _index.tsRestType;
        }
      });
      Object.defineProperty(exports, "TSStringKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsStringKeyword;
        }
      });
      Object.defineProperty(exports, "TSSymbolKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsSymbolKeyword;
        }
      });
      Object.defineProperty(exports, "TSThisType", {
        enumerable: true,
        get: function() {
          return _index.tsThisType;
        }
      });
      Object.defineProperty(exports, "TSTupleType", {
        enumerable: true,
        get: function() {
          return _index.tsTupleType;
        }
      });
      Object.defineProperty(exports, "TSTypeAliasDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAliasDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSTypeAssertion", {
        enumerable: true,
        get: function() {
          return _index.tsTypeAssertion;
        }
      });
      Object.defineProperty(exports, "TSTypeLiteral", {
        enumerable: true,
        get: function() {
          return _index.tsTypeLiteral;
        }
      });
      Object.defineProperty(exports, "TSTypeOperator", {
        enumerable: true,
        get: function() {
          return _index.tsTypeOperator;
        }
      });
      Object.defineProperty(exports, "TSTypeParameter", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameter;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterDeclaration", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterInstantiation", {
        enumerable: true,
        get: function() {
          return _index.tsTypeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TSTypePredicate", {
        enumerable: true,
        get: function() {
          return _index.tsTypePredicate;
        }
      });
      Object.defineProperty(exports, "TSTypeQuery", {
        enumerable: true,
        get: function() {
          return _index.tsTypeQuery;
        }
      });
      Object.defineProperty(exports, "TSTypeReference", {
        enumerable: true,
        get: function() {
          return _index.tsTypeReference;
        }
      });
      Object.defineProperty(exports, "TSUndefinedKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsUndefinedKeyword;
        }
      });
      Object.defineProperty(exports, "TSUnionType", {
        enumerable: true,
        get: function() {
          return _index.tsUnionType;
        }
      });
      Object.defineProperty(exports, "TSUnknownKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsUnknownKeyword;
        }
      });
      Object.defineProperty(exports, "TSVoidKeyword", {
        enumerable: true,
        get: function() {
          return _index.tsVoidKeyword;
        }
      });
      Object.defineProperty(exports, "TaggedTemplateExpression", {
        enumerable: true,
        get: function() {
          return _index.taggedTemplateExpression;
        }
      });
      Object.defineProperty(exports, "TemplateElement", {
        enumerable: true,
        get: function() {
          return _index.templateElement;
        }
      });
      Object.defineProperty(exports, "TemplateLiteral", {
        enumerable: true,
        get: function() {
          return _index.templateLiteral;
        }
      });
      Object.defineProperty(exports, "ThisExpression", {
        enumerable: true,
        get: function() {
          return _index.thisExpression;
        }
      });
      Object.defineProperty(exports, "ThisTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.thisTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ThrowStatement", {
        enumerable: true,
        get: function() {
          return _index.throwStatement;
        }
      });
      Object.defineProperty(exports, "TopicReference", {
        enumerable: true,
        get: function() {
          return _index.topicReference;
        }
      });
      Object.defineProperty(exports, "TryStatement", {
        enumerable: true,
        get: function() {
          return _index.tryStatement;
        }
      });
      Object.defineProperty(exports, "TupleExpression", {
        enumerable: true,
        get: function() {
          return _index.tupleExpression;
        }
      });
      Object.defineProperty(exports, "TupleTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.tupleTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeAlias", {
        enumerable: true,
        get: function() {
          return _index.typeAlias;
        }
      });
      Object.defineProperty(exports, "TypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.typeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeCastExpression", {
        enumerable: true,
        get: function() {
          return _index.typeCastExpression;
        }
      });
      Object.defineProperty(exports, "TypeParameter", {
        enumerable: true,
        get: function() {
          return _index.typeParameter;
        }
      });
      Object.defineProperty(exports, "TypeParameterDeclaration", {
        enumerable: true,
        get: function() {
          return _index.typeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TypeParameterInstantiation", {
        enumerable: true,
        get: function() {
          return _index.typeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TypeofTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.typeofTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UnaryExpression", {
        enumerable: true,
        get: function() {
          return _index.unaryExpression;
        }
      });
      Object.defineProperty(exports, "UnionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.unionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UpdateExpression", {
        enumerable: true,
        get: function() {
          return _index.updateExpression;
        }
      });
      Object.defineProperty(exports, "V8IntrinsicIdentifier", {
        enumerable: true,
        get: function() {
          return _index.v8IntrinsicIdentifier;
        }
      });
      Object.defineProperty(exports, "VariableDeclaration", {
        enumerable: true,
        get: function() {
          return _index.variableDeclaration;
        }
      });
      Object.defineProperty(exports, "VariableDeclarator", {
        enumerable: true,
        get: function() {
          return _index.variableDeclarator;
        }
      });
      Object.defineProperty(exports, "Variance", {
        enumerable: true,
        get: function() {
          return _index.variance;
        }
      });
      Object.defineProperty(exports, "VoidTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _index.voidTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "WhileStatement", {
        enumerable: true,
        get: function() {
          return _index.whileStatement;
        }
      });
      Object.defineProperty(exports, "WithStatement", {
        enumerable: true,
        get: function() {
          return _index.withStatement;
        }
      });
      Object.defineProperty(exports, "YieldExpression", {
        enumerable: true,
        get: function() {
          return _index.yieldExpression;
        }
      });
      var _index = require_generated2();
    }
  });

  // ../node_modules/@babel/types/lib/clone/cloneNode.js
  var require_cloneNode = __commonJS({
    "../node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneNode;
      var _definitions = require_definitions();
      var _generated = require_generated();
      var has = Function.call.bind(Object.prototype.hasOwnProperty);
      function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
        if (obj && typeof obj.type === "string") {
          return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
        }
        return obj;
      }
      function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
        if (Array.isArray(obj)) {
          return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
        }
        return cloneIfNode(obj, deep, withoutLoc, commentsCache);
      }
      function cloneNode(node, deep = true, withoutLoc = false) {
        return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
      }
      function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
        if (!node)
          return node;
        const {
          type
        } = node;
        const newNode = {
          type: node.type
        };
        if ((0, _generated.isIdentifier)(node)) {
          newNode.name = node.name;
          if (has(node, "optional") && typeof node.optional === "boolean") {
            newNode.optional = node.optional;
          }
          if (has(node, "typeAnnotation")) {
            newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
          }
        } else if (!has(_definitions.NODE_FIELDS, type)) {
          throw new Error(`Unknown node type: "${type}"`);
        } else {
          for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
            if (has(node, field)) {
              if (deep) {
                newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
              } else {
                newNode[field] = node[field];
              }
            }
          }
        }
        if (has(node, "loc")) {
          if (withoutLoc) {
            newNode.loc = null;
          } else {
            newNode.loc = node.loc;
          }
        }
        if (has(node, "leadingComments")) {
          newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "innerComments")) {
          newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "trailingComments")) {
          newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
        }
        if (has(node, "extra")) {
          newNode.extra = Object.assign({}, node.extra);
        }
        return newNode;
      }
      function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
        if (!comments || !deep) {
          return comments;
        }
        return comments.map((comment) => {
          const cache = commentsCache.get(comment);
          if (cache)
            return cache;
          const {
            type,
            value,
            loc
          } = comment;
          const ret = {
            type,
            value,
            loc
          };
          if (withoutLoc) {
            ret.loc = null;
          }
          commentsCache.set(comment, ret);
          return ret;
        });
      }
    }
  });

  // ../node_modules/@babel/types/lib/clone/clone.js
  var require_clone = __commonJS({
    "../node_modules/@babel/types/lib/clone/clone.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = clone;
      var _cloneNode = require_cloneNode();
      function clone(node) {
        return (0, _cloneNode.default)(node, false);
      }
    }
  });

  // ../node_modules/@babel/types/lib/clone/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "../node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneDeep;
      var _cloneNode = require_cloneNode();
      function cloneDeep(node) {
        return (0, _cloneNode.default)(node);
      }
    }
  });

  // ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
  var require_cloneDeepWithoutLoc = __commonJS({
    "../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneDeepWithoutLoc;
      var _cloneNode = require_cloneNode();
      function cloneDeepWithoutLoc(node) {
        return (0, _cloneNode.default)(node, true, true);
      }
    }
  });

  // ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
  var require_cloneWithoutLoc = __commonJS({
    "../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = cloneWithoutLoc;
      var _cloneNode = require_cloneNode();
      function cloneWithoutLoc(node) {
        return (0, _cloneNode.default)(node, false, true);
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/addComments.js
  var require_addComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/addComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = addComments;
      function addComments(node, type, comments) {
        if (!comments || !node)
          return node;
        const key = `${type}Comments`;
        if (node[key]) {
          if (type === "leading") {
            node[key] = comments.concat(node[key]);
          } else {
            node[key].push(...comments);
          }
        } else {
          node[key] = comments;
        }
        return node;
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/addComment.js
  var require_addComment = __commonJS({
    "../node_modules/@babel/types/lib/comments/addComment.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = addComment;
      var _addComments = require_addComments();
      function addComment(node, type, content, line) {
        return (0, _addComments.default)(node, type, [{
          type: line ? "CommentLine" : "CommentBlock",
          value: content
        }]);
      }
    }
  });

  // ../node_modules/@babel/types/lib/utils/inherit.js
  var require_inherit = __commonJS({
    "../node_modules/@babel/types/lib/utils/inherit.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inherit;
      function inherit(key, child, parent) {
        if (child && parent) {
          child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
  var require_inheritInnerComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritInnerComments;
      var _inherit = require_inherit();
      function inheritInnerComments(child, parent) {
        (0, _inherit.default)("innerComments", child, parent);
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
  var require_inheritLeadingComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritLeadingComments;
      var _inherit = require_inherit();
      function inheritLeadingComments(child, parent) {
        (0, _inherit.default)("leadingComments", child, parent);
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
  var require_inheritTrailingComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritTrailingComments;
      var _inherit = require_inherit();
      function inheritTrailingComments(child, parent) {
        (0, _inherit.default)("trailingComments", child, parent);
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/inheritsComments.js
  var require_inheritsComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inheritsComments;
      var _inheritTrailingComments = require_inheritTrailingComments();
      var _inheritLeadingComments = require_inheritLeadingComments();
      var _inheritInnerComments = require_inheritInnerComments();
      function inheritsComments(child, parent) {
        (0, _inheritTrailingComments.default)(child, parent);
        (0, _inheritLeadingComments.default)(child, parent);
        (0, _inheritInnerComments.default)(child, parent);
        return child;
      }
    }
  });

  // ../node_modules/@babel/types/lib/comments/removeComments.js
  var require_removeComments = __commonJS({
    "../node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeComments;
      var _constants = require_constants();
      function removeComments(node) {
        _constants.COMMENT_KEYS.forEach((key) => {
          node[key] = null;
        });
        return node;
      }
    }
  });

  // ../node_modules/@babel/types/lib/constants/generated/index.js
  var require_generated4 = __commonJS({
    "../node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
      var _definitions = require_definitions();
      var STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
      exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
      var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
      exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
      var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
      exports.BINARY_TYPES = BINARY_TYPES;
      var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
      exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
      var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
      exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
      var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
      exports.BLOCK_TYPES = BLOCK_TYPES;
      var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
      exports.STATEMENT_TYPES = STATEMENT_TYPES;
      var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
      exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
      var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
      exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
      var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
      exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
      var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
      exports.LOOP_TYPES = LOOP_TYPES;
      var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
      exports.WHILE_TYPES = WHILE_TYPES;
      var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
      exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
      var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
      exports.FOR_TYPES = FOR_TYPES;
      var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
      exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
      var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
      exports.FUNCTION_TYPES = FUNCTION_TYPES;
      var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
      exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
      var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
      exports.PUREISH_TYPES = PUREISH_TYPES;
      var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
      exports.DECLARATION_TYPES = DECLARATION_TYPES;
      var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
      exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
      var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
      exports.LVAL_TYPES = LVAL_TYPES;
      var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
      exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
      var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
      exports.LITERAL_TYPES = LITERAL_TYPES;
      var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
      exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
      var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
      exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
      var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
      exports.METHOD_TYPES = METHOD_TYPES;
      var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
      exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
      var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
      exports.PROPERTY_TYPES = PROPERTY_TYPES;
      var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
      exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
      var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
      exports.PATTERN_TYPES = PATTERN_TYPES;
      var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
      exports.CLASS_TYPES = CLASS_TYPES;
      var MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
      exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
      var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
      exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
      var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
      exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
      var ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
      exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
      var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
      exports.PRIVATE_TYPES = PRIVATE_TYPES;
      var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
      exports.FLOW_TYPES = FLOW_TYPES;
      var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
      exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
      var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
      exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
      var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
      exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
      var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
      exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
      var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
      exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
      var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
      exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
      var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
      exports.JSX_TYPES = JSX_TYPES;
      var MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
      exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
      var TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
      exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
      var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
      exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
      var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
      exports.TSTYPE_TYPES = TSTYPE_TYPES;
      var TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
      exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    }
  });

  // ../node_modules/@babel/types/lib/converters/toBlock.js
  var require_toBlock = __commonJS({
    "../node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toBlock;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      function toBlock(node, parent) {
        if ((0, _generated.isBlockStatement)(node)) {
          return node;
        }
        let blockNodes = [];
        if ((0, _generated.isEmptyStatement)(node)) {
          blockNodes = [];
        } else {
          if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) {
              node = (0, _generated2.returnStatement)(node);
            } else {
              node = (0, _generated2.expressionStatement)(node);
            }
          }
          blockNodes = [node];
        }
        return (0, _generated2.blockStatement)(blockNodes);
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/ensureBlock.js
  var require_ensureBlock = __commonJS({
    "../node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ensureBlock;
      var _toBlock = require_toBlock();
      function ensureBlock(node, key = "body") {
        const result = (0, _toBlock.default)(node[key], node);
        node[key] = result;
        return result;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toIdentifier.js
  var require_toIdentifier = __commonJS({
    "../node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toIdentifier;
      var _isValidIdentifier = require_isValidIdentifier();
      var _helperValidatorIdentifier = require_lib();
      function toIdentifier(input) {
        input = input + "";
        let name = "";
        for (const c of input) {
          name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
        }
        name = name.replace(/^[-0-9]+/, "");
        name = name.replace(/[-\s]+(.)?/g, function(match, c) {
          return c ? c.toUpperCase() : "";
        });
        if (!(0, _isValidIdentifier.default)(name)) {
          name = `_${name}`;
        }
        return name || "_";
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
  var require_toBindingIdentifierName = __commonJS({
    "../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toBindingIdentifierName;
      var _toIdentifier = require_toIdentifier();
      function toBindingIdentifierName(name) {
        name = (0, _toIdentifier.default)(name);
        if (name === "eval" || name === "arguments")
          name = "_" + name;
        return name;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toComputedKey.js
  var require_toComputedKey = __commonJS({
    "../node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toComputedKey;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      function toComputedKey(node, key = node.key || node.property) {
        if (!node.computed && (0, _generated.isIdentifier)(key))
          key = (0, _generated2.stringLiteral)(key.name);
        return key;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toExpression.js
  var require_toExpression = __commonJS({
    "../node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated();
      var _default = toExpression;
      exports.default = _default;
      function toExpression(node) {
        if ((0, _generated.isExpressionStatement)(node)) {
          node = node.expression;
        }
        if ((0, _generated.isExpression)(node)) {
          return node;
        }
        if ((0, _generated.isClass)(node)) {
          node.type = "ClassExpression";
        } else if ((0, _generated.isFunction)(node)) {
          node.type = "FunctionExpression";
        }
        if (!(0, _generated.isExpression)(node)) {
          throw new Error(`cannot turn ${node.type} to an expression`);
        }
        return node;
      }
    }
  });

  // ../node_modules/@babel/types/lib/traverse/traverseFast.js
  var require_traverseFast = __commonJS({
    "../node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = traverseFast;
      var _definitions = require_definitions();
      function traverseFast(node, enter, opts) {
        if (!node)
          return;
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (!keys)
          return;
        opts = opts || {};
        enter(node, opts);
        for (const key of keys) {
          const subNode = node[key];
          if (Array.isArray(subNode)) {
            for (const node2 of subNode) {
              traverseFast(node2, enter, opts);
            }
          } else {
            traverseFast(subNode, enter, opts);
          }
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/removeProperties.js
  var require_removeProperties = __commonJS({
    "../node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removeProperties;
      var _constants = require_constants();
      var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
      var CLEAR_KEYS_PLUS_COMMENTS = [..._constants.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
      function removeProperties(node, opts = {}) {
        const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
        for (const key of map) {
          if (node[key] != null)
            node[key] = void 0;
        }
        for (const key of Object.keys(node)) {
          if (key[0] === "_" && node[key] != null)
            node[key] = void 0;
        }
        const symbols = Object.getOwnPropertySymbols(node);
        for (const sym of symbols) {
          node[sym] = null;
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
  var require_removePropertiesDeep = __commonJS({
    "../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = removePropertiesDeep;
      var _traverseFast = require_traverseFast();
      var _removeProperties = require_removeProperties();
      function removePropertiesDeep(tree, opts) {
        (0, _traverseFast.default)(tree, _removeProperties.default, opts);
        return tree;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toKeyAlias.js
  var require_toKeyAlias = __commonJS({
    "../node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toKeyAlias;
      var _generated = require_generated();
      var _cloneNode = require_cloneNode();
      var _removePropertiesDeep = require_removePropertiesDeep();
      function toKeyAlias(node, key = node.key) {
        let alias;
        if (node.kind === "method") {
          return toKeyAlias.increment() + "";
        } else if ((0, _generated.isIdentifier)(key)) {
          alias = key.name;
        } else if ((0, _generated.isStringLiteral)(key)) {
          alias = JSON.stringify(key.value);
        } else {
          alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
        }
        if (node.computed) {
          alias = `[${alias}]`;
        }
        if (node.static) {
          alias = `static:${alias}`;
        }
        return alias;
      }
      toKeyAlias.uid = 0;
      toKeyAlias.increment = function() {
        if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
          return toKeyAlias.uid = 0;
        } else {
          return toKeyAlias.uid++;
        }
      };
    }
  });

  // ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
  var require_getBindingIdentifiers = __commonJS({
    "../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = getBindingIdentifiers;
      var _generated = require_generated();
      function getBindingIdentifiers(node, duplicates, outerOnly) {
        const search = [].concat(node);
        const ids = /* @__PURE__ */ Object.create(null);
        while (search.length) {
          const id = search.shift();
          if (!id)
            continue;
          const keys = getBindingIdentifiers.keys[id.type];
          if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
              const _ids = ids[id.name] = ids[id.name] || [];
              _ids.push(id);
            } else {
              ids[id.name] = id;
            }
            continue;
          }
          if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) {
              search.push(id.declaration);
            }
            continue;
          }
          if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
              search.push(id.id);
              continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) {
              continue;
            }
          }
          if (keys) {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const nodes = id[key];
              if (nodes) {
                Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
              }
            }
          }
        }
        return ids;
      }
      getBindingIdentifiers.keys = {
        DeclareClass: ["id"],
        DeclareFunction: ["id"],
        DeclareModule: ["id"],
        DeclareVariable: ["id"],
        DeclareInterface: ["id"],
        DeclareTypeAlias: ["id"],
        DeclareOpaqueType: ["id"],
        InterfaceDeclaration: ["id"],
        TypeAlias: ["id"],
        OpaqueType: ["id"],
        CatchClause: ["param"],
        LabeledStatement: ["label"],
        UnaryExpression: ["argument"],
        AssignmentExpression: ["left"],
        ImportSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportDefaultSpecifier: ["local"],
        ImportDeclaration: ["specifiers"],
        ExportSpecifier: ["exported"],
        ExportNamespaceSpecifier: ["exported"],
        ExportDefaultSpecifier: ["exported"],
        FunctionDeclaration: ["id", "params"],
        FunctionExpression: ["id", "params"],
        ArrowFunctionExpression: ["params"],
        ObjectMethod: ["params"],
        ClassMethod: ["params"],
        ClassPrivateMethod: ["params"],
        ForInStatement: ["left"],
        ForOfStatement: ["left"],
        ClassDeclaration: ["id"],
        ClassExpression: ["id"],
        RestElement: ["argument"],
        UpdateExpression: ["argument"],
        ObjectProperty: ["value"],
        AssignmentPattern: ["left"],
        ArrayPattern: ["elements"],
        ObjectPattern: ["properties"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id"]
      };
    }
  });

  // ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
  var require_gatherSequenceExpressions = __commonJS({
    "../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = gatherSequenceExpressions;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _generated = require_generated();
      var _generated2 = require_generated2();
      var _cloneNode = require_cloneNode();
      function gatherSequenceExpressions(nodes, scope, declars) {
        const exprs = [];
        let ensureLastUndefined = true;
        for (const node of nodes) {
          if (!(0, _generated.isEmptyStatement)(node)) {
            ensureLastUndefined = false;
          }
          if ((0, _generated.isExpression)(node)) {
            exprs.push(node);
          } else if ((0, _generated.isExpressionStatement)(node)) {
            exprs.push(node.expression);
          } else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var")
              return;
            for (const declar of node.declarations) {
              const bindings = (0, _getBindingIdentifiers.default)(declar);
              for (const key of Object.keys(bindings)) {
                declars.push({
                  kind: node.kind,
                  id: (0, _cloneNode.default)(bindings[key])
                });
              }
              if (declar.init) {
                exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
              }
            }
            ensureLastUndefined = true;
          } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate)
              return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
          } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body)
              return;
            exprs.push(body);
          } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) {
              ensureLastUndefined = true;
            }
          } else {
            return;
          }
        }
        if (ensureLastUndefined) {
          exprs.push(scope.buildUndefinedNode());
        }
        if (exprs.length === 1) {
          return exprs[0];
        } else {
          return (0, _generated2.sequenceExpression)(exprs);
        }
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
  var require_toSequenceExpression = __commonJS({
    "../node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toSequenceExpression;
      var _gatherSequenceExpressions = require_gatherSequenceExpressions();
      function toSequenceExpression(nodes, scope) {
        if (!(nodes != null && nodes.length))
          return;
        const declars = [];
        const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
        if (!result)
          return;
        for (const declar of declars) {
          scope.push(declar);
        }
        return result;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/toStatement.js
  var require_toStatement = __commonJS({
    "../node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _generated = require_generated();
      var _generated2 = require_generated2();
      var _default = toStatement;
      exports.default = _default;
      function toStatement(node, ignore) {
        if ((0, _generated.isStatement)(node)) {
          return node;
        }
        let mustHaveId = false;
        let newType;
        if ((0, _generated.isClass)(node)) {
          mustHaveId = true;
          newType = "ClassDeclaration";
        } else if ((0, _generated.isFunction)(node)) {
          mustHaveId = true;
          newType = "FunctionDeclaration";
        } else if ((0, _generated.isAssignmentExpression)(node)) {
          return (0, _generated2.expressionStatement)(node);
        }
        if (mustHaveId && !node.id) {
          newType = false;
        }
        if (!newType) {
          if (ignore) {
            return false;
          } else {
            throw new Error(`cannot turn ${node.type} to a statement`);
          }
        }
        node.type = newType;
        return node;
      }
    }
  });

  // ../node_modules/@babel/types/lib/converters/valueToNode.js
  var require_valueToNode = __commonJS({
    "../node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _isValidIdentifier = require_isValidIdentifier();
      var _generated = require_generated2();
      var _default = valueToNode;
      exports.default = _default;
      var objectToString = Function.call.bind(Object.prototype.toString);
      function isRegExp(value) {
        return objectToString(value) === "[object RegExp]";
      }
      function isPlainObject(value) {
        if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
          return false;
        }
        const proto = Object.getPrototypeOf(value);
        return proto === null || Object.getPrototypeOf(proto) === null;
      }
      function valueToNode(value) {
        if (value === void 0) {
          return (0, _generated.identifier)("undefined");
        }
        if (value === true || value === false) {
          return (0, _generated.booleanLiteral)(value);
        }
        if (value === null) {
          return (0, _generated.nullLiteral)();
        }
        if (typeof value === "string") {
          return (0, _generated.stringLiteral)(value);
        }
        if (typeof value === "number") {
          let result;
          if (Number.isFinite(value)) {
            result = (0, _generated.numericLiteral)(Math.abs(value));
          } else {
            let numerator;
            if (Number.isNaN(value)) {
              numerator = (0, _generated.numericLiteral)(0);
            } else {
              numerator = (0, _generated.numericLiteral)(1);
            }
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
          }
          if (value < 0 || Object.is(value, -0)) {
            result = (0, _generated.unaryExpression)("-", result);
          }
          return result;
        }
        if (isRegExp(value)) {
          const pattern = value.source;
          const flags = value.toString().match(/\/([a-z]+|)$/)[1];
          return (0, _generated.regExpLiteral)(pattern, flags);
        }
        if (Array.isArray(value)) {
          return (0, _generated.arrayExpression)(value.map(valueToNode));
        }
        if (isPlainObject(value)) {
          const props = [];
          for (const key of Object.keys(value)) {
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) {
              nodeKey = (0, _generated.identifier)(key);
            } else {
              nodeKey = (0, _generated.stringLiteral)(key);
            }
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
          }
          return (0, _generated.objectExpression)(props);
        }
        throw new Error("don't know how to turn this value into a node");
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
  var require_appendToMemberExpression = __commonJS({
    "../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = appendToMemberExpression;
      var _generated = require_generated2();
      function appendToMemberExpression(member, append, computed = false) {
        member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
        member.property = append;
        member.computed = !!computed;
        return member;
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/inherits.js
  var require_inherits = __commonJS({
    "../node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = inherits;
      var _constants = require_constants();
      var _inheritsComments = require_inheritsComments();
      function inherits(child, parent) {
        if (!child || !parent)
          return child;
        for (const key of _constants.INHERIT_KEYS.optional) {
          if (child[key] == null) {
            child[key] = parent[key];
          }
        }
        for (const key of Object.keys(parent)) {
          if (key[0] === "_" && key !== "__clone") {
            child[key] = parent[key];
          }
        }
        for (const key of _constants.INHERIT_KEYS.force) {
          child[key] = parent[key];
        }
        (0, _inheritsComments.default)(child, parent);
        return child;
      }
    }
  });

  // ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
  var require_prependToMemberExpression = __commonJS({
    "../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = prependToMemberExpression;
      var _generated = require_generated2();
      var _ = require_lib3();
      function prependToMemberExpression(member, prepend) {
        if ((0, _.isSuper)(member.object)) {
          throw new Error("Cannot prepend node to super property access (`super.foo`).");
        }
        member.object = (0, _generated.memberExpression)(prepend, member.object);
        return member;
      }
    }
  });

  // ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
  var require_getOuterBindingIdentifiers = __commonJS({
    "../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _default = getOuterBindingIdentifiers;
      exports.default = _default;
      function getOuterBindingIdentifiers(node, duplicates) {
        return (0, _getBindingIdentifiers.default)(node, duplicates, true);
      }
    }
  });

  // ../node_modules/@babel/types/lib/traverse/traverse.js
  var require_traverse = __commonJS({
    "../node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = traverse2;
      var _definitions = require_definitions();
      function traverse2(node, handlers, state) {
        if (typeof handlers === "function") {
          handlers = {
            enter: handlers
          };
        }
        const {
          enter,
          exit
        } = handlers;
        traverseSimpleImpl(node, enter, exit, state, []);
      }
      function traverseSimpleImpl(node, enter, exit, state, ancestors) {
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (!keys)
          return;
        if (enter)
          enter(node, ancestors, state);
        for (const key of keys) {
          const subNode = node[key];
          if (Array.isArray(subNode)) {
            for (let i = 0; i < subNode.length; i++) {
              const child = subNode[i];
              if (!child)
                continue;
              ancestors.push({
                node,
                key,
                index: i
              });
              traverseSimpleImpl(child, enter, exit, state, ancestors);
              ancestors.pop();
            }
          } else if (subNode) {
            ancestors.push({
              node,
              key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
          }
        }
        if (exit)
          exit(node, ancestors, state);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isBinding.js
  var require_isBinding = __commonJS({
    "../node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBinding;
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      function isBinding(node, parent, grandparent) {
        if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
          return false;
        }
        const keys = _getBindingIdentifiers.default.keys[parent.type];
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const val = parent[key];
            if (Array.isArray(val)) {
              if (val.indexOf(node) >= 0)
                return true;
            } else {
              if (val === node)
                return true;
            }
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isLet.js
  var require_isLet = __commonJS({
    "../node_modules/@babel/types/lib/validators/isLet.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLet;
      var _generated = require_generated();
      var _constants = require_constants();
      function isLet(node) {
        return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isBlockScoped.js
  var require_isBlockScoped = __commonJS({
    "../node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBlockScoped;
      var _generated = require_generated();
      var _isLet = require_isLet();
      function isBlockScoped(node) {
        return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isImmutable.js
  var require_isImmutable = __commonJS({
    "../node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isImmutable;
      var _isType = require_isType();
      var _generated = require_generated();
      function isImmutable(node) {
        if ((0, _isType.default)(node.type, "Immutable"))
          return true;
        if ((0, _generated.isIdentifier)(node)) {
          if (node.name === "undefined") {
            return true;
          } else {
            return false;
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
  var require_isNodesEquivalent = __commonJS({
    "../node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isNodesEquivalent;
      var _definitions = require_definitions();
      function isNodesEquivalent(a, b) {
        if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
          return a === b;
        }
        if (a.type !== b.type) {
          return false;
        }
        const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
        const visitorKeys = _definitions.VISITOR_KEYS[a.type];
        for (const field of fields) {
          const val_a = a[field];
          const val_b = b[field];
          if (typeof val_a !== typeof val_b) {
            return false;
          }
          if (val_a == null && val_b == null) {
            continue;
          } else if (val_a == null || val_b == null) {
            return false;
          }
          if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) {
              return false;
            }
            if (val_a.length !== val_b.length) {
              return false;
            }
            for (let i = 0; i < val_a.length; i++) {
              if (!isNodesEquivalent(val_a[i], val_b[i])) {
                return false;
              }
            }
            continue;
          }
          if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(val_a)) {
              if (val_a[key] !== val_b[key]) {
                return false;
              }
            }
            continue;
          }
          if (!isNodesEquivalent(val_a, val_b)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isReferenced.js
  var require_isReferenced = __commonJS({
    "../node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isReferenced;
      function isReferenced(node, parent, grandparent) {
        switch (parent.type) {
          case "MemberExpression":
          case "OptionalMemberExpression":
            if (parent.property === node) {
              return !!parent.computed;
            }
            return parent.object === node;
          case "JSXMemberExpression":
            return parent.object === node;
          case "VariableDeclarator":
            return parent.init === node;
          case "ArrowFunctionExpression":
            return parent.body === node;
          case "PrivateName":
            return false;
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "ObjectMethod":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return false;
          case "ObjectProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return !grandparent || grandparent.type !== "ObjectPattern";
          case "ClassProperty":
          case "ClassAccessorProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
          case "ClassPrivateProperty":
            return parent.key !== node;
          case "ClassDeclaration":
          case "ClassExpression":
            return parent.superClass === node;
          case "AssignmentExpression":
            return parent.right === node;
          case "AssignmentPattern":
            return parent.right === node;
          case "LabeledStatement":
            return false;
          case "CatchClause":
            return false;
          case "RestElement":
            return false;
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          case "FunctionDeclaration":
          case "FunctionExpression":
            return false;
          case "ExportNamespaceSpecifier":
          case "ExportDefaultSpecifier":
            return false;
          case "ExportSpecifier":
            if (grandparent != null && grandparent.source) {
              return false;
            }
            return parent.local === node;
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ImportSpecifier":
            return false;
          case "ImportAttribute":
            return false;
          case "JSXAttribute":
            return false;
          case "ObjectPattern":
          case "ArrayPattern":
            return false;
          case "MetaProperty":
            return false;
          case "ObjectTypeProperty":
            return parent.key !== node;
          case "TSEnumMember":
            return parent.id !== node;
          case "TSPropertySignature":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
        }
        return true;
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isScope.js
  var require_isScope = __commonJS({
    "../node_modules/@babel/types/lib/validators/isScope.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isScope;
      var _generated = require_generated();
      function isScope(node, parent) {
        if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
          return false;
        }
        if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
          return true;
        }
        return (0, _generated.isScopable)(node);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
  var require_isSpecifierDefault = __commonJS({
    "../node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isSpecifierDefault;
      var _generated = require_generated();
      function isSpecifierDefault(specifier) {
        return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
          name: "default"
        });
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
  var require_isValidES3Identifier = __commonJS({
    "../node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isValidES3Identifier;
      var _isValidIdentifier = require_isValidIdentifier();
      var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      function isValidES3Identifier(name) {
        return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
      }
    }
  });

  // ../node_modules/@babel/types/lib/validators/isVar.js
  var require_isVar = __commonJS({
    "../node_modules/@babel/types/lib/validators/isVar.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isVar;
      var _generated = require_generated();
      var _constants = require_constants();
      function isVar(node) {
        return (0, _generated.isVariableDeclaration)(node, {
          kind: "var"
        }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
      }
    }
  });

  // ../node_modules/@babel/types/lib/ast-types/generated/index.js
  var require_generated5 = __commonJS({
    "../node_modules/@babel/types/lib/ast-types/generated/index.js"() {
      init_inject();
    }
  });

  // ../node_modules/@babel/types/lib/index.js
  var require_lib3 = __commonJS({
    "../node_modules/@babel/types/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _exportNames = {
        react: true,
        assertNode: true,
        createTypeAnnotationBasedOnTypeof: true,
        createUnionTypeAnnotation: true,
        createFlowUnionType: true,
        createTSUnionType: true,
        cloneNode: true,
        clone: true,
        cloneDeep: true,
        cloneDeepWithoutLoc: true,
        cloneWithoutLoc: true,
        addComment: true,
        addComments: true,
        inheritInnerComments: true,
        inheritLeadingComments: true,
        inheritsComments: true,
        inheritTrailingComments: true,
        removeComments: true,
        ensureBlock: true,
        toBindingIdentifierName: true,
        toBlock: true,
        toComputedKey: true,
        toExpression: true,
        toIdentifier: true,
        toKeyAlias: true,
        toSequenceExpression: true,
        toStatement: true,
        valueToNode: true,
        appendToMemberExpression: true,
        inherits: true,
        prependToMemberExpression: true,
        removeProperties: true,
        removePropertiesDeep: true,
        removeTypeDuplicates: true,
        getBindingIdentifiers: true,
        getOuterBindingIdentifiers: true,
        traverse: true,
        traverseFast: true,
        shallowEqual: true,
        is: true,
        isBinding: true,
        isBlockScoped: true,
        isImmutable: true,
        isLet: true,
        isNode: true,
        isNodesEquivalent: true,
        isPlaceholderType: true,
        isReferenced: true,
        isScope: true,
        isSpecifierDefault: true,
        isType: true,
        isValidES3Identifier: true,
        isValidIdentifier: true,
        isVar: true,
        matchesPattern: true,
        validate: true,
        buildMatchMemberExpression: true
      };
      Object.defineProperty(exports, "addComment", {
        enumerable: true,
        get: function() {
          return _addComment.default;
        }
      });
      Object.defineProperty(exports, "addComments", {
        enumerable: true,
        get: function() {
          return _addComments.default;
        }
      });
      Object.defineProperty(exports, "appendToMemberExpression", {
        enumerable: true,
        get: function() {
          return _appendToMemberExpression.default;
        }
      });
      Object.defineProperty(exports, "assertNode", {
        enumerable: true,
        get: function() {
          return _assertNode.default;
        }
      });
      Object.defineProperty(exports, "buildMatchMemberExpression", {
        enumerable: true,
        get: function() {
          return _buildMatchMemberExpression.default;
        }
      });
      Object.defineProperty(exports, "clone", {
        enumerable: true,
        get: function() {
          return _clone.default;
        }
      });
      Object.defineProperty(exports, "cloneDeep", {
        enumerable: true,
        get: function() {
          return _cloneDeep.default;
        }
      });
      Object.defineProperty(exports, "cloneDeepWithoutLoc", {
        enumerable: true,
        get: function() {
          return _cloneDeepWithoutLoc.default;
        }
      });
      Object.defineProperty(exports, "cloneNode", {
        enumerable: true,
        get: function() {
          return _cloneNode.default;
        }
      });
      Object.defineProperty(exports, "cloneWithoutLoc", {
        enumerable: true,
        get: function() {
          return _cloneWithoutLoc.default;
        }
      });
      Object.defineProperty(exports, "createFlowUnionType", {
        enumerable: true,
        get: function() {
          return _createFlowUnionType.default;
        }
      });
      Object.defineProperty(exports, "createTSUnionType", {
        enumerable: true,
        get: function() {
          return _createTSUnionType.default;
        }
      });
      Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
        enumerable: true,
        get: function() {
          return _createTypeAnnotationBasedOnTypeof.default;
        }
      });
      Object.defineProperty(exports, "createUnionTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _createFlowUnionType.default;
        }
      });
      Object.defineProperty(exports, "ensureBlock", {
        enumerable: true,
        get: function() {
          return _ensureBlock.default;
        }
      });
      Object.defineProperty(exports, "getBindingIdentifiers", {
        enumerable: true,
        get: function() {
          return _getBindingIdentifiers.default;
        }
      });
      Object.defineProperty(exports, "getOuterBindingIdentifiers", {
        enumerable: true,
        get: function() {
          return _getOuterBindingIdentifiers.default;
        }
      });
      Object.defineProperty(exports, "inheritInnerComments", {
        enumerable: true,
        get: function() {
          return _inheritInnerComments.default;
        }
      });
      Object.defineProperty(exports, "inheritLeadingComments", {
        enumerable: true,
        get: function() {
          return _inheritLeadingComments.default;
        }
      });
      Object.defineProperty(exports, "inheritTrailingComments", {
        enumerable: true,
        get: function() {
          return _inheritTrailingComments.default;
        }
      });
      Object.defineProperty(exports, "inherits", {
        enumerable: true,
        get: function() {
          return _inherits.default;
        }
      });
      Object.defineProperty(exports, "inheritsComments", {
        enumerable: true,
        get: function() {
          return _inheritsComments.default;
        }
      });
      Object.defineProperty(exports, "is", {
        enumerable: true,
        get: function() {
          return _is.default;
        }
      });
      Object.defineProperty(exports, "isBinding", {
        enumerable: true,
        get: function() {
          return _isBinding.default;
        }
      });
      Object.defineProperty(exports, "isBlockScoped", {
        enumerable: true,
        get: function() {
          return _isBlockScoped.default;
        }
      });
      Object.defineProperty(exports, "isImmutable", {
        enumerable: true,
        get: function() {
          return _isImmutable.default;
        }
      });
      Object.defineProperty(exports, "isLet", {
        enumerable: true,
        get: function() {
          return _isLet.default;
        }
      });
      Object.defineProperty(exports, "isNode", {
        enumerable: true,
        get: function() {
          return _isNode.default;
        }
      });
      Object.defineProperty(exports, "isNodesEquivalent", {
        enumerable: true,
        get: function() {
          return _isNodesEquivalent.default;
        }
      });
      Object.defineProperty(exports, "isPlaceholderType", {
        enumerable: true,
        get: function() {
          return _isPlaceholderType.default;
        }
      });
      Object.defineProperty(exports, "isReferenced", {
        enumerable: true,
        get: function() {
          return _isReferenced.default;
        }
      });
      Object.defineProperty(exports, "isScope", {
        enumerable: true,
        get: function() {
          return _isScope.default;
        }
      });
      Object.defineProperty(exports, "isSpecifierDefault", {
        enumerable: true,
        get: function() {
          return _isSpecifierDefault.default;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _isType.default;
        }
      });
      Object.defineProperty(exports, "isValidES3Identifier", {
        enumerable: true,
        get: function() {
          return _isValidES3Identifier.default;
        }
      });
      Object.defineProperty(exports, "isValidIdentifier", {
        enumerable: true,
        get: function() {
          return _isValidIdentifier.default;
        }
      });
      Object.defineProperty(exports, "isVar", {
        enumerable: true,
        get: function() {
          return _isVar.default;
        }
      });
      Object.defineProperty(exports, "matchesPattern", {
        enumerable: true,
        get: function() {
          return _matchesPattern.default;
        }
      });
      Object.defineProperty(exports, "prependToMemberExpression", {
        enumerable: true,
        get: function() {
          return _prependToMemberExpression.default;
        }
      });
      exports.react = void 0;
      Object.defineProperty(exports, "removeComments", {
        enumerable: true,
        get: function() {
          return _removeComments.default;
        }
      });
      Object.defineProperty(exports, "removeProperties", {
        enumerable: true,
        get: function() {
          return _removeProperties.default;
        }
      });
      Object.defineProperty(exports, "removePropertiesDeep", {
        enumerable: true,
        get: function() {
          return _removePropertiesDeep.default;
        }
      });
      Object.defineProperty(exports, "removeTypeDuplicates", {
        enumerable: true,
        get: function() {
          return _removeTypeDuplicates.default;
        }
      });
      Object.defineProperty(exports, "shallowEqual", {
        enumerable: true,
        get: function() {
          return _shallowEqual.default;
        }
      });
      Object.defineProperty(exports, "toBindingIdentifierName", {
        enumerable: true,
        get: function() {
          return _toBindingIdentifierName.default;
        }
      });
      Object.defineProperty(exports, "toBlock", {
        enumerable: true,
        get: function() {
          return _toBlock.default;
        }
      });
      Object.defineProperty(exports, "toComputedKey", {
        enumerable: true,
        get: function() {
          return _toComputedKey.default;
        }
      });
      Object.defineProperty(exports, "toExpression", {
        enumerable: true,
        get: function() {
          return _toExpression.default;
        }
      });
      Object.defineProperty(exports, "toIdentifier", {
        enumerable: true,
        get: function() {
          return _toIdentifier.default;
        }
      });
      Object.defineProperty(exports, "toKeyAlias", {
        enumerable: true,
        get: function() {
          return _toKeyAlias.default;
        }
      });
      Object.defineProperty(exports, "toSequenceExpression", {
        enumerable: true,
        get: function() {
          return _toSequenceExpression.default;
        }
      });
      Object.defineProperty(exports, "toStatement", {
        enumerable: true,
        get: function() {
          return _toStatement.default;
        }
      });
      Object.defineProperty(exports, "traverse", {
        enumerable: true,
        get: function() {
          return _traverse2.default;
        }
      });
      Object.defineProperty(exports, "traverseFast", {
        enumerable: true,
        get: function() {
          return _traverseFast.default;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.default;
        }
      });
      Object.defineProperty(exports, "valueToNode", {
        enumerable: true,
        get: function() {
          return _valueToNode.default;
        }
      });
      var _isReactComponent = require_isReactComponent();
      var _isCompatTag = require_isCompatTag();
      var _buildChildren = require_buildChildren();
      var _assertNode = require_assertNode();
      var _generated = require_generated3();
      Object.keys(_generated).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated[key];
          }
        });
      });
      var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
      var _createFlowUnionType = require_createFlowUnionType();
      var _createTSUnionType = require_createTSUnionType();
      var _generated2 = require_generated2();
      Object.keys(_generated2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated2[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated2[key];
          }
        });
      });
      var _uppercase = require_uppercase();
      Object.keys(_uppercase).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _uppercase[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _uppercase[key];
          }
        });
      });
      var _cloneNode = require_cloneNode();
      var _clone = require_clone();
      var _cloneDeep = require_cloneDeep();
      var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
      var _cloneWithoutLoc = require_cloneWithoutLoc();
      var _addComment = require_addComment();
      var _addComments = require_addComments();
      var _inheritInnerComments = require_inheritInnerComments();
      var _inheritLeadingComments = require_inheritLeadingComments();
      var _inheritsComments = require_inheritsComments();
      var _inheritTrailingComments = require_inheritTrailingComments();
      var _removeComments = require_removeComments();
      var _generated3 = require_generated4();
      Object.keys(_generated3).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated3[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated3[key];
          }
        });
      });
      var _constants = require_constants();
      Object.keys(_constants).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _constants[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _constants[key];
          }
        });
      });
      var _ensureBlock = require_ensureBlock();
      var _toBindingIdentifierName = require_toBindingIdentifierName();
      var _toBlock = require_toBlock();
      var _toComputedKey = require_toComputedKey();
      var _toExpression = require_toExpression();
      var _toIdentifier = require_toIdentifier();
      var _toKeyAlias = require_toKeyAlias();
      var _toSequenceExpression = require_toSequenceExpression();
      var _toStatement = require_toStatement();
      var _valueToNode = require_valueToNode();
      var _definitions = require_definitions();
      Object.keys(_definitions).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _definitions[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _definitions[key];
          }
        });
      });
      var _appendToMemberExpression = require_appendToMemberExpression();
      var _inherits = require_inherits();
      var _prependToMemberExpression = require_prependToMemberExpression();
      var _removeProperties = require_removeProperties();
      var _removePropertiesDeep = require_removePropertiesDeep();
      var _removeTypeDuplicates = require_removeTypeDuplicates();
      var _getBindingIdentifiers = require_getBindingIdentifiers();
      var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
      var _traverse2 = require_traverse();
      Object.keys(_traverse2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _traverse2[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _traverse2[key];
          }
        });
      });
      var _traverseFast = require_traverseFast();
      var _shallowEqual = require_shallowEqual();
      var _is = require_is();
      var _isBinding = require_isBinding();
      var _isBlockScoped = require_isBlockScoped();
      var _isImmutable = require_isImmutable();
      var _isLet = require_isLet();
      var _isNode = require_isNode();
      var _isNodesEquivalent = require_isNodesEquivalent();
      var _isPlaceholderType = require_isPlaceholderType();
      var _isReferenced = require_isReferenced();
      var _isScope = require_isScope();
      var _isSpecifierDefault = require_isSpecifierDefault();
      var _isType = require_isType();
      var _isValidES3Identifier = require_isValidES3Identifier();
      var _isValidIdentifier = require_isValidIdentifier();
      var _isVar = require_isVar();
      var _matchesPattern = require_matchesPattern();
      var _validate = require_validate();
      var _buildMatchMemberExpression = require_buildMatchMemberExpression();
      var _generated4 = require_generated();
      Object.keys(_generated4).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated4[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated4[key];
          }
        });
      });
      var _generated5 = require_generated5();
      Object.keys(_generated5).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        if (key in exports && exports[key] === _generated5[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _generated5[key];
          }
        });
      });
      var react = {
        isReactComponent: _isReactComponent.default,
        isCompatTag: _isCompatTag.default,
        buildChildren: _buildChildren.default
      };
      exports.react = react;
    }
  });

  // ../node_modules/@babel/generator/lib/node/whitespace.js
  var require_whitespace = __commonJS({
    "../node_modules/@babel/generator/lib/node/whitespace.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nodes = void 0;
      var _t = require_lib3();
      var {
        FLIPPED_ALIAS_KEYS,
        isArrayExpression,
        isAssignmentExpression,
        isBinary,
        isBlockStatement,
        isCallExpression,
        isFunction,
        isIdentifier,
        isLiteral,
        isMemberExpression,
        isObjectExpression,
        isOptionalCallExpression,
        isOptionalMemberExpression,
        isStringLiteral
      } = _t;
      function crawlInternal(node, state) {
        if (!node)
          return state;
        if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
          crawlInternal(node.object, state);
          if (node.computed)
            crawlInternal(node.property, state);
        } else if (isBinary(node) || isAssignmentExpression(node)) {
          crawlInternal(node.left, state);
          crawlInternal(node.right, state);
        } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
          state.hasCall = true;
          crawlInternal(node.callee, state);
        } else if (isFunction(node)) {
          state.hasFunction = true;
        } else if (isIdentifier(node)) {
          state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
        }
        return state;
      }
      function crawl(node) {
        return crawlInternal(node, {
          hasCall: false,
          hasFunction: false,
          hasHelper: false
        });
      }
      function isHelper(node) {
        if (!node)
          return false;
        if (isMemberExpression(node)) {
          return isHelper(node.object) || isHelper(node.property);
        } else if (isIdentifier(node)) {
          return node.name === "require" || node.name.charCodeAt(0) === 95;
        } else if (isCallExpression(node)) {
          return isHelper(node.callee);
        } else if (isBinary(node) || isAssignmentExpression(node)) {
          return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
        } else {
          return false;
        }
      }
      function isType(node) {
        return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
      }
      var nodes = {
        AssignmentExpression(node) {
          const state = crawl(node.right);
          if (state.hasCall && state.hasHelper || state.hasFunction) {
            return state.hasFunction ? 1 | 2 : 2;
          }
        },
        SwitchCase(node, parent) {
          return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
        },
        LogicalExpression(node) {
          if (isFunction(node.left) || isFunction(node.right)) {
            return 2;
          }
        },
        Literal(node) {
          if (isStringLiteral(node) && node.value === "use strict") {
            return 2;
          }
        },
        CallExpression(node) {
          if (isFunction(node.callee) || isHelper(node)) {
            return 1 | 2;
          }
        },
        OptionalCallExpression(node) {
          if (isFunction(node.callee)) {
            return 1 | 2;
          }
        },
        VariableDeclaration(node) {
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType(declar.init);
            if (!enabled && declar.init) {
              const state = crawl(declar.init);
              enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            if (enabled) {
              return 1 | 2;
            }
          }
        },
        IfStatement(node) {
          if (isBlockStatement(node.consequent)) {
            return 1 | 2;
          }
        }
      };
      exports.nodes = nodes;
      nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
        if (parent.properties[0] === node) {
          return 1;
        }
      };
      nodes.ObjectTypeCallProperty = function(node, parent) {
        var _parent$properties;
        if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
          return 1;
        }
      };
      nodes.ObjectTypeIndexer = function(node, parent) {
        var _parent$properties2, _parent$callPropertie;
        if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
          return 1;
        }
      };
      nodes.ObjectTypeInternalSlot = function(node, parent) {
        var _parent$properties3, _parent$callPropertie2, _parent$indexers;
        if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
          return 1;
        }
      };
      [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
        [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
          const ret = amounts ? 1 | 2 : 0;
          nodes[type2] = () => ret;
        });
      });
    }
  });

  // ../node_modules/@babel/generator/lib/node/parentheses.js
  var require_parentheses = __commonJS({
    "../node_modules/@babel/generator/lib/node/parentheses.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrowFunctionExpression = ArrowFunctionExpression;
      exports.AssignmentExpression = AssignmentExpression;
      exports.Binary = Binary;
      exports.BinaryExpression = BinaryExpression;
      exports.ClassExpression = ClassExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.DoExpression = DoExpression;
      exports.FunctionExpression = FunctionExpression;
      exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
      exports.Identifier = Identifier;
      exports.LogicalExpression = LogicalExpression;
      exports.NullableTypeAnnotation = NullableTypeAnnotation;
      exports.ObjectExpression = ObjectExpression;
      exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
      exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
      exports.SequenceExpression = SequenceExpression;
      exports.TSAsExpression = TSAsExpression;
      exports.TSInferType = TSInferType;
      exports.TSInstantiationExpression = TSInstantiationExpression;
      exports.TSTypeAssertion = TSTypeAssertion;
      exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
      exports.UnaryLike = UnaryLike;
      exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
      exports.UpdateExpression = UpdateExpression;
      exports.AwaitExpression = exports.YieldExpression = YieldExpression;
      var _t = require_lib3();
      var {
        isArrayTypeAnnotation,
        isArrowFunctionExpression,
        isAssignmentExpression,
        isAwaitExpression,
        isBinary,
        isBinaryExpression,
        isUpdateExpression,
        isCallExpression,
        isClass,
        isClassExpression,
        isConditional,
        isConditionalExpression,
        isExportDeclaration,
        isExportDefaultDeclaration,
        isExpressionStatement,
        isFor,
        isForInStatement,
        isForOfStatement,
        isForStatement,
        isFunctionExpression,
        isIfStatement,
        isIndexedAccessType,
        isIntersectionTypeAnnotation,
        isLogicalExpression,
        isMemberExpression,
        isNewExpression,
        isNullableTypeAnnotation,
        isObjectPattern,
        isOptionalCallExpression,
        isOptionalMemberExpression,
        isReturnStatement,
        isSequenceExpression,
        isSwitchStatement,
        isTSArrayType,
        isTSAsExpression,
        isTSInstantiationExpression,
        isTSIntersectionType,
        isTSNonNullExpression,
        isTSOptionalType,
        isTSRestType,
        isTSTypeAssertion,
        isTSUnionType,
        isTaggedTemplateExpression,
        isThrowStatement,
        isTypeAnnotation,
        isUnaryLike,
        isUnionTypeAnnotation,
        isVariableDeclarator,
        isWhileStatement,
        isYieldExpression
      } = _t;
      var PRECEDENCE = {
        "||": 0,
        "??": 0,
        "|>": 0,
        "&&": 1,
        "|": 2,
        "^": 3,
        "&": 4,
        "==": 5,
        "===": 5,
        "!=": 5,
        "!==": 5,
        "<": 6,
        ">": 6,
        "<=": 6,
        ">=": 6,
        in: 6,
        instanceof: 6,
        ">>": 7,
        "<<": 7,
        ">>>": 7,
        "+": 8,
        "-": 8,
        "*": 9,
        "/": 9,
        "%": 9,
        "**": 10
      };
      var isClassExtendsClause = (node, parent) => isClass(parent, {
        superClass: node
      });
      var hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
      function NullableTypeAnnotation(node, parent) {
        return isArrayTypeAnnotation(parent);
      }
      function FunctionTypeAnnotation(node, parent, printStack) {
        if (printStack.length < 3)
          return;
        return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
      }
      function UpdateExpression(node, parent) {
        return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
      }
      function ObjectExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 2);
      }
      function DoExpression(node, parent, printStack) {
        return !node.async && isFirstInContext(printStack, 1);
      }
      function Binary(node, parent) {
        if (node.operator === "**" && isBinaryExpression(parent, {
          operator: "**"
        })) {
          return parent.left === node;
        }
        if (isClassExtendsClause(node, parent)) {
          return true;
        }
        if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
          return true;
        }
        if (isBinary(parent)) {
          const parentOp = parent.operator;
          const parentPos = PRECEDENCE[parentOp];
          const nodeOp = node.operator;
          const nodePos = PRECEDENCE[nodeOp];
          if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
            return true;
          }
        }
      }
      function UnionTypeAnnotation(node, parent) {
        return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
      }
      function OptionalIndexedAccessType(node, parent) {
        return isIndexedAccessType(parent, {
          objectType: node
        });
      }
      function TSAsExpression() {
        return true;
      }
      function TSTypeAssertion() {
        return true;
      }
      function TSUnionType(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
      }
      function TSInferType(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent);
      }
      function TSInstantiationExpression(node, parent) {
        return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;
      }
      function BinaryExpression(node, parent) {
        return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
      }
      function SequenceExpression(node, parent) {
        if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
          return false;
        }
        return true;
      }
      function YieldExpression(node, parent) {
        return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
      }
      function ClassExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 4);
      }
      function UnaryLike(node, parent) {
        return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
          operator: "**",
          left: node
        }) || isClassExtendsClause(node, parent);
      }
      function FunctionExpression(node, parent, printStack) {
        return isFirstInContext(printStack, 1 | 4);
      }
      function ArrowFunctionExpression(node, parent) {
        return isExportDeclaration(parent) || ConditionalExpression(node, parent);
      }
      function ConditionalExpression(node, parent) {
        if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
          test: node
        }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
          return true;
        }
        return UnaryLike(node, parent);
      }
      function OptionalMemberExpression(node, parent) {
        return isCallExpression(parent, {
          callee: node
        }) || isMemberExpression(parent, {
          object: node
        });
      }
      function AssignmentExpression(node, parent) {
        if (isObjectPattern(node.left)) {
          return true;
        } else {
          return ConditionalExpression(node, parent);
        }
      }
      function LogicalExpression(node, parent) {
        switch (node.operator) {
          case "||":
            if (!isLogicalExpression(parent))
              return false;
            return parent.operator === "??" || parent.operator === "&&";
          case "&&":
            return isLogicalExpression(parent, {
              operator: "??"
            });
          case "??":
            return isLogicalExpression(parent) && parent.operator !== "??";
        }
      }
      function Identifier(node, parent, printStack) {
        var _node$extra;
        if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {
          left: node
        }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {
          return true;
        }
        if (node.name === "let") {
          const isFollowedByBracket = isMemberExpression(parent, {
            object: node,
            computed: true
          }) || isOptionalMemberExpression(parent, {
            object: node,
            computed: true,
            optional: false
          });
          return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
        }
        return node.name === "async" && isForOfStatement(parent) && node === parent.left;
      }
      function isFirstInContext(printStack, checkParam) {
        const expressionStatement = checkParam & 1;
        const arrowBody = checkParam & 2;
        const exportDefault = checkParam & 4;
        const forHead = checkParam & 8;
        const forInHead = checkParam & 16;
        const forOfHead = checkParam & 32;
        let i = printStack.length - 1;
        if (i <= 0)
          return;
        let node = printStack[i];
        i--;
        let parent = printStack[i];
        while (i >= 0) {
          if (expressionStatement && isExpressionStatement(parent, {
            expression: node
          }) || exportDefault && isExportDefaultDeclaration(parent, {
            declaration: node
          }) || arrowBody && isArrowFunctionExpression(parent, {
            body: node
          }) || forHead && isForStatement(parent, {
            init: node
          }) || forInHead && isForInStatement(parent, {
            left: node
          }) || forOfHead && isForOfStatement(parent, {
            left: node
          })) {
            return true;
          }
          if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {
            test: node
          }) || isBinary(parent, {
            left: node
          }) || isAssignmentExpression(parent, {
            left: node
          }))) {
            node = parent;
            i--;
            parent = printStack[i];
          } else {
            return false;
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/generator/lib/node/index.js
  var require_node = __commonJS({
    "../node_modules/@babel/generator/lib/node/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.needsParens = needsParens;
      exports.needsWhitespace = needsWhitespace;
      exports.needsWhitespaceAfter = needsWhitespaceAfter;
      exports.needsWhitespaceBefore = needsWhitespaceBefore;
      var whitespace = require_whitespace();
      var parens = require_parentheses();
      var _t = require_lib3();
      var {
        FLIPPED_ALIAS_KEYS,
        isCallExpression,
        isExpressionStatement,
        isMemberExpression,
        isNewExpression
      } = _t;
      function expandAliases(obj) {
        const newObj = {};
        function add(type, func) {
          const fn = newObj[type];
          newObj[type] = fn ? function(node, parent, stack) {
            const result = fn(node, parent, stack);
            return result == null ? func(node, parent, stack) : result;
          } : func;
        }
        for (const type of Object.keys(obj)) {
          const aliases = FLIPPED_ALIAS_KEYS[type];
          if (aliases) {
            for (const alias of aliases) {
              add(alias, obj[type]);
            }
          } else {
            add(type, obj[type]);
          }
        }
        return newObj;
      }
      var expandedParens = expandAliases(parens);
      var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
      function find(obj, node, parent, printStack) {
        const fn = obj[node.type];
        return fn ? fn(node, parent, printStack) : null;
      }
      function isOrHasCallExpression(node) {
        if (isCallExpression(node)) {
          return true;
        }
        return isMemberExpression(node) && isOrHasCallExpression(node.object);
      }
      function needsWhitespace(node, parent, type) {
        if (!node)
          return false;
        if (isExpressionStatement(node)) {
          node = node.expression;
        }
        const flag = find(expandedWhitespaceNodes, node, parent);
        if (typeof flag === "number") {
          return (flag & type) !== 0;
        }
        return false;
      }
      function needsWhitespaceBefore(node, parent) {
        return needsWhitespace(node, parent, 1);
      }
      function needsWhitespaceAfter(node, parent) {
        return needsWhitespace(node, parent, 2);
      }
      function needsParens(node, parent, printStack) {
        if (!parent)
          return false;
        if (isNewExpression(parent) && parent.callee === node) {
          if (isOrHasCallExpression(node))
            return true;
        }
        return find(expandedParens, node, parent, printStack);
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/template-literals.js
  var require_template_literals = __commonJS({
    "../node_modules/@babel/generator/lib/generators/template-literals.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TaggedTemplateExpression = TaggedTemplateExpression;
      exports.TemplateElement = TemplateElement;
      exports.TemplateLiteral = TemplateLiteral;
      function TaggedTemplateExpression(node) {
        this.print(node.tag, node);
        this.print(node.typeParameters, node);
        this.print(node.quasi, node);
      }
      function TemplateElement(node, parent) {
        const isFirst = parent.quasis[0] === node;
        const isLast = parent.quasis[parent.quasis.length - 1] === node;
        const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
        this.token(value, true);
      }
      function TemplateLiteral(node) {
        const quasis = node.quasis;
        for (let i = 0; i < quasis.length; i++) {
          this.print(quasis[i], node);
          if (i + 1 < quasis.length) {
            this.print(node.expressions[i], node);
          }
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/expressions.js
  var require_expressions = __commonJS({
    "../node_modules/@babel/generator/lib/generators/expressions.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
      exports.AssignmentPattern = AssignmentPattern;
      exports.AwaitExpression = AwaitExpression;
      exports.BindExpression = BindExpression;
      exports.CallExpression = CallExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.Decorator = Decorator;
      exports.DoExpression = DoExpression;
      exports.EmptyStatement = EmptyStatement;
      exports.ExpressionStatement = ExpressionStatement;
      exports.Import = Import;
      exports.MemberExpression = MemberExpression;
      exports.MetaProperty = MetaProperty;
      exports.ModuleExpression = ModuleExpression;
      exports.NewExpression = NewExpression;
      exports.OptionalCallExpression = OptionalCallExpression;
      exports.OptionalMemberExpression = OptionalMemberExpression;
      exports.ParenthesizedExpression = ParenthesizedExpression;
      exports.PrivateName = PrivateName;
      exports.SequenceExpression = SequenceExpression;
      exports.Super = Super;
      exports.ThisExpression = ThisExpression;
      exports.UnaryExpression = UnaryExpression;
      exports.UpdateExpression = UpdateExpression;
      exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
      exports.YieldExpression = YieldExpression;
      var _t = require_lib3();
      var n = require_node();
      var {
        isCallExpression,
        isLiteral,
        isMemberExpression,
        isNewExpression
      } = _t;
      function UnaryExpression(node) {
        if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
          this.word(node.operator);
          this.space();
        } else {
          this.token(node.operator);
        }
        this.print(node.argument, node);
      }
      function DoExpression(node) {
        if (node.async) {
          this.word("async");
          this.space();
        }
        this.word("do");
        this.space();
        this.print(node.body, node);
      }
      function ParenthesizedExpression(node) {
        this.tokenChar(40);
        this.print(node.expression, node);
        this.tokenChar(41);
      }
      function UpdateExpression(node) {
        if (node.prefix) {
          this.token(node.operator);
          this.print(node.argument, node);
        } else {
          this.printTerminatorless(node.argument, node, true);
          this.token(node.operator);
        }
      }
      function ConditionalExpression(node) {
        this.print(node.test, node);
        this.space();
        this.tokenChar(63);
        this.space();
        this.print(node.consequent, node);
        this.space();
        this.tokenChar(58);
        this.space();
        this.print(node.alternate, node);
      }
      function NewExpression(node, parent) {
        this.word("new");
        this.space();
        this.print(node.callee, node);
        if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
          callee: node
        }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
          return;
        }
        this.print(node.typeArguments, node);
        this.print(node.typeParameters, node);
        if (node.optional) {
          this.token("?.");
        }
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function SequenceExpression(node) {
        this.printList(node.expressions, node);
      }
      function ThisExpression() {
        this.word("this");
      }
      function Super() {
        this.word("super");
      }
      function isDecoratorMemberExpression(node) {
        switch (node.type) {
          case "Identifier":
            return true;
          case "MemberExpression":
            return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
          default:
            return false;
        }
      }
      function shouldParenthesizeDecoratorExpression(node) {
        if (node.type === "CallExpression") {
          node = node.callee;
        }
        if (node.type === "ParenthesizedExpression") {
          return false;
        }
        return !isDecoratorMemberExpression(node);
      }
      function Decorator(node) {
        this.tokenChar(64);
        const {
          expression
        } = node;
        if (shouldParenthesizeDecoratorExpression(expression)) {
          this.tokenChar(40);
          this.print(expression, node);
          this.tokenChar(41);
        } else {
          this.print(expression, node);
        }
        this.newline();
      }
      function OptionalMemberExpression(node) {
        this.print(node.object, node);
        if (!node.computed && isMemberExpression(node.property)) {
          throw new TypeError("Got a MemberExpression for MemberExpression property");
        }
        let computed = node.computed;
        if (isLiteral(node.property) && typeof node.property.value === "number") {
          computed = true;
        }
        if (node.optional) {
          this.token("?.");
        }
        if (computed) {
          this.tokenChar(91);
          this.print(node.property, node);
          this.tokenChar(93);
        } else {
          if (!node.optional) {
            this.tokenChar(46);
          }
          this.print(node.property, node);
        }
      }
      function OptionalCallExpression(node) {
        this.print(node.callee, node);
        this.print(node.typeArguments, node);
        this.print(node.typeParameters, node);
        if (node.optional) {
          this.token("?.");
        }
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function CallExpression(node) {
        this.print(node.callee, node);
        this.print(node.typeArguments, node);
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        this.printList(node.arguments, node);
        this.tokenChar(41);
      }
      function Import() {
        this.word("import");
      }
      function AwaitExpression(node) {
        this.word("await");
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument, node, false);
        }
      }
      function YieldExpression(node) {
        this.word("yield");
        if (node.delegate) {
          this.tokenChar(42);
        }
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument, node, false);
        }
      }
      function EmptyStatement() {
        this.semicolon(true);
      }
      function ExpressionStatement(node) {
        this.print(node.expression, node);
        this.semicolon();
      }
      function AssignmentPattern(node) {
        this.print(node.left, node);
        if (node.left.optional)
          this.tokenChar(63);
        this.print(node.left.typeAnnotation, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.right, node);
      }
      function AssignmentExpression(node, parent) {
        const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);
        if (parens) {
          this.tokenChar(40);
        }
        this.print(node.left, node);
        this.space();
        if (node.operator === "in" || node.operator === "instanceof") {
          this.word(node.operator);
        } else {
          this.token(node.operator);
        }
        this.space();
        this.print(node.right, node);
        if (parens) {
          this.tokenChar(41);
        }
      }
      function BindExpression(node) {
        this.print(node.object, node);
        this.token("::");
        this.print(node.callee, node);
      }
      function MemberExpression(node) {
        this.print(node.object, node);
        if (!node.computed && isMemberExpression(node.property)) {
          throw new TypeError("Got a MemberExpression for MemberExpression property");
        }
        let computed = node.computed;
        if (isLiteral(node.property) && typeof node.property.value === "number") {
          computed = true;
        }
        if (computed) {
          this.tokenChar(91);
          this.print(node.property, node);
          this.tokenChar(93);
        } else {
          this.tokenChar(46);
          this.print(node.property, node);
        }
      }
      function MetaProperty(node) {
        this.print(node.meta, node);
        this.tokenChar(46);
        this.print(node.property, node);
      }
      function PrivateName(node) {
        this.tokenChar(35);
        this.print(node.id, node);
      }
      function V8IntrinsicIdentifier(node) {
        this.tokenChar(37);
        this.word(node.name);
      }
      function ModuleExpression(node) {
        this.word("module");
        this.space();
        this.tokenChar(123);
        if (node.body.body.length === 0) {
          this.tokenChar(125);
        } else {
          this.newline();
          this.printSequence(node.body.body, node, {
            indent: true
          });
          this.rightBrace();
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/statements.js
  var require_statements = __commonJS({
    "../node_modules/@babel/generator/lib/generators/statements.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BreakStatement = BreakStatement;
      exports.CatchClause = CatchClause;
      exports.ContinueStatement = ContinueStatement;
      exports.DebuggerStatement = DebuggerStatement;
      exports.DoWhileStatement = DoWhileStatement;
      exports.ForOfStatement = exports.ForInStatement = void 0;
      exports.ForStatement = ForStatement;
      exports.IfStatement = IfStatement;
      exports.LabeledStatement = LabeledStatement;
      exports.ReturnStatement = ReturnStatement;
      exports.SwitchCase = SwitchCase;
      exports.SwitchStatement = SwitchStatement;
      exports.ThrowStatement = ThrowStatement;
      exports.TryStatement = TryStatement;
      exports.VariableDeclaration = VariableDeclaration;
      exports.VariableDeclarator = VariableDeclarator;
      exports.WhileStatement = WhileStatement;
      exports.WithStatement = WithStatement;
      var _t = require_lib3();
      var {
        isFor,
        isForStatement,
        isIfStatement,
        isStatement
      } = _t;
      function WithStatement(node) {
        this.word("with");
        this.space();
        this.tokenChar(40);
        this.print(node.object, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      function IfStatement(node) {
        this.word("if");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.space();
        const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
        if (needsBlock) {
          this.tokenChar(123);
          this.newline();
          this.indent();
        }
        this.printAndIndentOnComments(node.consequent, node);
        if (needsBlock) {
          this.dedent();
          this.newline();
          this.tokenChar(125);
        }
        if (node.alternate) {
          if (this.endsWith(125))
            this.space();
          this.word("else");
          this.space();
          this.printAndIndentOnComments(node.alternate, node);
        }
      }
      function getLastStatement(statement) {
        const {
          body
        } = statement;
        if (isStatement(body) === false) {
          return statement;
        }
        return getLastStatement(body);
      }
      function ForStatement(node) {
        this.word("for");
        this.space();
        this.tokenChar(40);
        this.inForStatementInitCounter++;
        this.print(node.init, node);
        this.inForStatementInitCounter--;
        this.tokenChar(59);
        if (node.test) {
          this.space();
          this.print(node.test, node);
        }
        this.tokenChar(59);
        if (node.update) {
          this.space();
          this.print(node.update, node);
        }
        this.tokenChar(41);
        this.printBlock(node);
      }
      function WhileStatement(node) {
        this.word("while");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      function ForXStatement(node) {
        this.word("for");
        this.space();
        const isForOf = node.type === "ForOfStatement";
        if (isForOf && node.await) {
          this.word("await");
          this.space();
        }
        this.tokenChar(40);
        this.print(node.left, node);
        this.space();
        this.word(isForOf ? "of" : "in");
        this.space();
        this.print(node.right, node);
        this.tokenChar(41);
        this.printBlock(node);
      }
      var ForInStatement = ForXStatement;
      exports.ForInStatement = ForInStatement;
      var ForOfStatement = ForXStatement;
      exports.ForOfStatement = ForOfStatement;
      function DoWhileStatement(node) {
        this.word("do");
        this.space();
        this.print(node.body, node);
        this.space();
        this.word("while");
        this.space();
        this.tokenChar(40);
        this.print(node.test, node);
        this.tokenChar(41);
        this.semicolon();
      }
      function printStatementAfterKeyword(printer, node, parent, isLabel) {
        if (node) {
          printer.space();
          printer.printTerminatorless(node, parent, isLabel);
        }
        printer.semicolon();
      }
      function BreakStatement(node) {
        this.word("break");
        printStatementAfterKeyword(this, node.label, node, true);
      }
      function ContinueStatement(node) {
        this.word("continue");
        printStatementAfterKeyword(this, node.label, node, true);
      }
      function ReturnStatement(node) {
        this.word("return");
        printStatementAfterKeyword(this, node.argument, node, false);
      }
      function ThrowStatement(node) {
        this.word("throw");
        printStatementAfterKeyword(this, node.argument, node, false);
      }
      function LabeledStatement(node) {
        this.print(node.label, node);
        this.tokenChar(58);
        this.space();
        this.print(node.body, node);
      }
      function TryStatement(node) {
        this.word("try");
        this.space();
        this.print(node.block, node);
        this.space();
        if (node.handlers) {
          this.print(node.handlers[0], node);
        } else {
          this.print(node.handler, node);
        }
        if (node.finalizer) {
          this.space();
          this.word("finally");
          this.space();
          this.print(node.finalizer, node);
        }
      }
      function CatchClause(node) {
        this.word("catch");
        this.space();
        if (node.param) {
          this.tokenChar(40);
          this.print(node.param, node);
          this.print(node.param.typeAnnotation, node);
          this.tokenChar(41);
          this.space();
        }
        this.print(node.body, node);
      }
      function SwitchStatement(node) {
        this.word("switch");
        this.space();
        this.tokenChar(40);
        this.print(node.discriminant, node);
        this.tokenChar(41);
        this.space();
        this.tokenChar(123);
        this.printSequence(node.cases, node, {
          indent: true,
          addNewlines(leading, cas) {
            if (!leading && node.cases[node.cases.length - 1] === cas)
              return -1;
          }
        });
        this.tokenChar(125);
      }
      function SwitchCase(node) {
        if (node.test) {
          this.word("case");
          this.space();
          this.print(node.test, node);
          this.tokenChar(58);
        } else {
          this.word("default");
          this.tokenChar(58);
        }
        if (node.consequent.length) {
          this.newline();
          this.printSequence(node.consequent, node, {
            indent: true
          });
        }
      }
      function DebuggerStatement() {
        this.word("debugger");
        this.semicolon();
      }
      function variableDeclarationIndent() {
        this.tokenChar(44);
        this.newline();
        if (this.endsWith(10)) {
          for (let i = 0; i < 4; i++)
            this.space(true);
        }
      }
      function constDeclarationIndent() {
        this.tokenChar(44);
        this.newline();
        if (this.endsWith(10)) {
          for (let i = 0; i < 6; i++)
            this.space(true);
        }
      }
      function VariableDeclaration(node, parent) {
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        this.word(node.kind);
        this.space();
        let hasInits = false;
        if (!isFor(parent)) {
          for (const declar of node.declarations) {
            if (declar.init) {
              hasInits = true;
            }
          }
        }
        let separator;
        if (hasInits) {
          separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
        }
        this.printList(node.declarations, node, {
          separator
        });
        if (isFor(parent)) {
          if (isForStatement(parent)) {
            if (parent.init === node)
              return;
          } else {
            if (parent.left === node)
              return;
          }
        }
        this.semicolon();
      }
      function VariableDeclarator(node) {
        this.print(node.id, node);
        if (node.definite)
          this.tokenChar(33);
        this.print(node.id.typeAnnotation, node);
        if (node.init) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.init, node);
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/classes.js
  var require_classes = __commonJS({
    "../node_modules/@babel/generator/lib/generators/classes.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ClassAccessorProperty = ClassAccessorProperty;
      exports.ClassBody = ClassBody;
      exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
      exports.ClassMethod = ClassMethod;
      exports.ClassPrivateMethod = ClassPrivateMethod;
      exports.ClassPrivateProperty = ClassPrivateProperty;
      exports.ClassProperty = ClassProperty;
      exports.StaticBlock = StaticBlock;
      exports._classMethodHead = _classMethodHead;
      var _t = require_lib3();
      var {
        isExportDefaultDeclaration,
        isExportNamedDeclaration
      } = _t;
      function ClassDeclaration(node, parent) {
        {
          if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
            this.printJoin(node.decorators, node);
          }
        }
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        this.word("class");
        this.printInnerComments(node);
        if (node.id) {
          this.space();
          this.print(node.id, node);
        }
        this.print(node.typeParameters, node);
        if (node.superClass) {
          this.space();
          this.word("extends");
          this.space();
          this.print(node.superClass, node);
          this.print(node.superTypeParameters, node);
        }
        if (node.implements) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function ClassBody(node) {
        this.tokenChar(123);
        this.printInnerComments(node);
        if (node.body.length === 0) {
          this.tokenChar(125);
        } else {
          this.newline();
          this.indent();
          this.printSequence(node.body, node);
          this.dedent();
          if (!this.endsWith(10))
            this.newline();
          this.rightBrace();
        }
      }
      function ClassProperty(node) {
        this.printJoin(node.decorators, node);
        this.source("end", node.key.loc);
        this.tsPrintClassMemberModifiers(node);
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          this._variance(node);
          this.print(node.key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        if (node.definite) {
          this.tokenChar(33);
        }
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassAccessorProperty(node) {
        this.printJoin(node.decorators, node);
        this.source("end", node.key.loc);
        this.tsPrintClassMemberModifiers(node);
        this.word("accessor");
        this.printInnerComments(node);
        this.space();
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          this._variance(node);
          this.print(node.key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        if (node.definite) {
          this.tokenChar(33);
        }
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassPrivateProperty(node) {
        this.printJoin(node.decorators, node);
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.print(node.key, node);
        this.print(node.typeAnnotation, node);
        if (node.value) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.value, node);
        }
        this.semicolon();
      }
      function ClassMethod(node) {
        this._classMethodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ClassPrivateMethod(node) {
        this._classMethodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function _classMethodHead(node) {
        this.printJoin(node.decorators, node);
        this.source("end", node.key.loc);
        this.tsPrintClassMemberModifiers(node);
        this._methodHead(node);
      }
      function StaticBlock(node) {
        this.word("static");
        this.space();
        this.tokenChar(123);
        if (node.body.length === 0) {
          this.tokenChar(125);
        } else {
          this.newline();
          this.printSequence(node.body, node, {
            indent: true
          });
          this.rightBrace();
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/methods.js
  var require_methods = __commonJS({
    "../node_modules/@babel/generator/lib/generators/methods.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrowFunctionExpression = ArrowFunctionExpression;
      exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
      exports._functionHead = _functionHead;
      exports._methodHead = _methodHead;
      exports._param = _param;
      exports._parameters = _parameters;
      exports._params = _params;
      exports._predicate = _predicate;
      var _t = require_lib3();
      var {
        isIdentifier
      } = _t;
      function _params(node) {
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        this._parameters(node.params, node);
        this.tokenChar(41);
        this.print(node.returnType, node, node.type === "ArrowFunctionExpression");
      }
      function _parameters(parameters, parent) {
        for (let i = 0; i < parameters.length; i++) {
          this._param(parameters[i], parent);
          if (i < parameters.length - 1) {
            this.tokenChar(44);
            this.space();
          }
        }
      }
      function _param(parameter, parent) {
        this.printJoin(parameter.decorators, parameter);
        this.print(parameter, parent);
        if (parameter.optional) {
          this.tokenChar(63);
        }
        this.print(parameter.typeAnnotation, parameter);
      }
      function _methodHead(node) {
        const kind = node.kind;
        const key = node.key;
        if (kind === "get" || kind === "set") {
          this.word(kind);
          this.space();
        }
        if (node.async) {
          this._catchUp("start", key.loc);
          this.word("async");
          this.space();
        }
        if (kind === "method" || kind === "init") {
          if (node.generator) {
            this.tokenChar(42);
          }
        }
        if (node.computed) {
          this.tokenChar(91);
          this.print(key, node);
          this.tokenChar(93);
        } else {
          this.print(key, node);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
        this._params(node);
      }
      function _predicate(node) {
        if (node.predicate) {
          if (!node.returnType) {
            this.tokenChar(58);
          }
          this.space();
          this.print(node.predicate, node);
        }
      }
      function _functionHead(node) {
        if (node.async) {
          this.word("async");
          this.space();
        }
        this.word("function");
        if (node.generator)
          this.tokenChar(42);
        this.printInnerComments(node);
        this.space();
        if (node.id) {
          this.print(node.id, node);
        }
        this._params(node);
        if (node.type !== "TSDeclareFunction") {
          this._predicate(node);
        }
      }
      function FunctionExpression(node) {
        this._functionHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ArrowFunctionExpression(node) {
        if (node.async) {
          this.word("async");
          this.space();
        }
        const firstParam = node.params[0];
        if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && isIdentifier(firstParam) && !hasTypesOrComments(node, firstParam)) {
          this.print(firstParam, node);
        } else {
          this._params(node);
        }
        this._predicate(node);
        this.space();
        this.token("=>");
        this.space();
        this.print(node.body, node);
      }
      function hasTypesOrComments(node, param) {
        var _param$leadingComment, _param$trailingCommen;
        return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/modules.js
  var require_modules = __commonJS({
    "../node_modules/@babel/generator/lib/generators/modules.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExportAllDeclaration = ExportAllDeclaration;
      exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
      exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
      exports.ExportNamedDeclaration = ExportNamedDeclaration;
      exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
      exports.ExportSpecifier = ExportSpecifier;
      exports.ImportAttribute = ImportAttribute;
      exports.ImportDeclaration = ImportDeclaration;
      exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
      exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
      exports.ImportSpecifier = ImportSpecifier;
      var _t = require_lib3();
      var {
        isClassDeclaration,
        isExportDefaultSpecifier,
        isExportNamespaceSpecifier,
        isImportDefaultSpecifier,
        isImportNamespaceSpecifier,
        isStatement
      } = _t;
      function ImportSpecifier(node) {
        if (node.importKind === "type" || node.importKind === "typeof") {
          this.word(node.importKind);
          this.space();
        }
        this.print(node.imported, node);
        if (node.local && node.local.name !== node.imported.name) {
          this.space();
          this.word("as");
          this.space();
          this.print(node.local, node);
        }
      }
      function ImportDefaultSpecifier(node) {
        this.print(node.local, node);
      }
      function ExportDefaultSpecifier(node) {
        this.print(node.exported, node);
      }
      function ExportSpecifier(node) {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        this.print(node.local, node);
        if (node.exported && node.local.name !== node.exported.name) {
          this.space();
          this.word("as");
          this.space();
          this.print(node.exported, node);
        }
      }
      function ExportNamespaceSpecifier(node) {
        this.tokenChar(42);
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported, node);
      }
      function ExportAllDeclaration(node) {
        this.word("export");
        this.space();
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        this.tokenChar(42);
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
        this.printAssertions(node);
        this.semicolon();
      }
      function ExportNamedDeclaration(node) {
        {
          if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
            this.printJoin(node.declaration.decorators, node);
          }
        }
        this.word("export");
        this.space();
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node);
          if (!isStatement(declar))
            this.semicolon();
        } else {
          if (node.exportKind === "type") {
            this.word("type");
            this.space();
          }
          const specifiers = node.specifiers.slice(0);
          let hasSpecial = false;
          for (; ; ) {
            const first = specifiers[0];
            if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
              hasSpecial = true;
              this.print(specifiers.shift(), node);
              if (specifiers.length) {
                this.tokenChar(44);
                this.space();
              }
            } else {
              break;
            }
          }
          if (specifiers.length || !specifiers.length && !hasSpecial) {
            this.tokenChar(123);
            if (specifiers.length) {
              this.space();
              this.printList(specifiers, node);
              this.space();
            }
            this.tokenChar(125);
          }
          if (node.source) {
            this.space();
            this.word("from");
            this.space();
            this.print(node.source, node);
            this.printAssertions(node);
          }
          this.semicolon();
        }
      }
      function ExportDefaultDeclaration(node) {
        {
          if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
            this.printJoin(node.declaration.decorators, node);
          }
        }
        this.word("export");
        this.space();
        this.word("default");
        this.space();
        const declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar))
          this.semicolon();
      }
      function ImportDeclaration(node) {
        this.word("import");
        this.space();
        const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
        if (isTypeKind) {
          this.word(node.importKind);
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        const hasSpecifiers = !!specifiers.length;
        while (hasSpecifiers) {
          const first = specifiers[0];
          if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length) {
          this.tokenChar(123);
          this.space();
          this.printList(specifiers, node);
          this.space();
          this.tokenChar(125);
        } else if (isTypeKind && !hasSpecifiers) {
          this.tokenChar(123);
          this.tokenChar(125);
        }
        if (hasSpecifiers || isTypeKind) {
          this.space();
          this.word("from");
          this.space();
        }
        this.print(node.source, node);
        this.printAssertions(node);
        {
          var _node$attributes;
          if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
            this.space();
            this.word("with");
            this.space();
            this.printList(node.attributes, node);
          }
        }
        this.semicolon();
      }
      function ImportAttribute(node) {
        this.print(node.key);
        this.tokenChar(58);
        this.space();
        this.print(node.value);
      }
      function ImportNamespaceSpecifier(node) {
        this.tokenChar(42);
        this.space();
        this.word("as");
        this.space();
        this.print(node.local, node);
      }
    }
  });

  // ../node_modules/jsesc/jsesc.js
  var require_jsesc = __commonJS({
    "../node_modules/jsesc/jsesc.js"(exports, module) {
      "use strict";
      init_inject();
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var forOwn = (object2, callback) => {
        for (const key in object2) {
          if (hasOwnProperty.call(object2, key)) {
            callback(key, object2[key]);
          }
        }
      };
      var extend = (destination, source) => {
        if (!source) {
          return destination;
        }
        forOwn(source, (key, value) => {
          destination[key] = value;
        });
        return destination;
      };
      var forEach = (array, callback) => {
        const length = array.length;
        let index = -1;
        while (++index < length) {
          callback(array[index]);
        }
      };
      var toString = object.toString;
      var isArray = Array.isArray;
      var isBuffer = Function;
      var isObject = (value) => {
        return toString.call(value) == "[object Object]";
      };
      var isString = (value) => {
        return typeof value == "string" || toString.call(value) == "[object String]";
      };
      var isNumber2 = (value) => {
        return typeof value == "number" || toString.call(value) == "[object Number]";
      };
      var isFunction = (value) => {
        return typeof value == "function";
      };
      var isMap = (value) => {
        return toString.call(value) == "[object Map]";
      };
      var isSet = (value) => {
        return toString.call(value) == "[object Set]";
      };
      var singleEscapes = {
        '"': '\\"',
        "'": "\\'",
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t"
      };
      var regexSingleEscape = /["'\\\b\f\n\r\t]/;
      var regexDigit = /[0-9]/;
      var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
      var jsesc = (argument, options) => {
        const increaseIndentation = () => {
          oldIndent = indent;
          ++options.indentLevel;
          indent = options.indent.repeat(options.indentLevel);
        };
        const defaults = {
          "escapeEverything": false,
          "minimal": false,
          "isScriptContext": false,
          "quotes": "single",
          "wrap": false,
          "es6": false,
          "json": false,
          "compact": true,
          "lowercaseHex": false,
          "numbers": "decimal",
          "indent": "	",
          "indentLevel": 0,
          "__inline1__": false,
          "__inline2__": false
        };
        const json = options && options.json;
        if (json) {
          defaults.quotes = "double";
          defaults.wrap = true;
        }
        options = extend(defaults, options);
        if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
          options.quotes = "single";
        }
        const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
        const compact = options.compact;
        const lowercaseHex = options.lowercaseHex;
        let indent = options.indent.repeat(options.indentLevel);
        let oldIndent = "";
        const inline1 = options.__inline1__;
        const inline2 = options.__inline2__;
        const newLine = compact ? "" : "\n";
        let result;
        let isEmpty = true;
        const useBinNumbers = options.numbers == "binary";
        const useOctNumbers = options.numbers == "octal";
        const useDecNumbers = options.numbers == "decimal";
        const useHexNumbers = options.numbers == "hexadecimal";
        if (json && argument && isFunction(argument.toJSON)) {
          argument = argument.toJSON();
        }
        if (!isString(argument)) {
          if (isMap(argument)) {
            if (argument.size == 0) {
              return "new Map()";
            }
            if (!compact) {
              options.__inline1__ = true;
              options.__inline2__ = false;
            }
            return "new Map(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isSet(argument)) {
            if (argument.size == 0) {
              return "new Set()";
            }
            return "new Set(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isBuffer(argument)) {
            if (argument.length == 0) {
              return "Buffer.from([])";
            }
            return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
          }
          if (isArray(argument)) {
            result = [];
            options.wrap = true;
            if (inline1) {
              options.__inline1__ = false;
              options.__inline2__ = true;
            }
            if (!inline2) {
              increaseIndentation();
            }
            forEach(argument, (value) => {
              isEmpty = false;
              if (inline2) {
                options.__inline2__ = false;
              }
              result.push(
                (compact || inline2 ? "" : indent) + jsesc(value, options)
              );
            });
            if (isEmpty) {
              return "[]";
            }
            if (inline2) {
              return "[" + result.join(", ") + "]";
            }
            return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
          } else if (isNumber2(argument)) {
            if (json) {
              return JSON.stringify(argument);
            }
            if (useDecNumbers) {
              return String(argument);
            }
            if (useHexNumbers) {
              let hexadecimal = argument.toString(16);
              if (!lowercaseHex) {
                hexadecimal = hexadecimal.toUpperCase();
              }
              return "0x" + hexadecimal;
            }
            if (useBinNumbers) {
              return "0b" + argument.toString(2);
            }
            if (useOctNumbers) {
              return "0o" + argument.toString(8);
            }
          } else if (!isObject(argument)) {
            if (json) {
              return JSON.stringify(argument) || "null";
            }
            return String(argument);
          } else {
            result = [];
            options.wrap = true;
            increaseIndentation();
            forOwn(argument, (key, value) => {
              isEmpty = false;
              result.push(
                (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
              );
            });
            if (isEmpty) {
              return "{}";
            }
            return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
          }
        }
        const string = argument;
        let index = -1;
        const length = string.length;
        result = "";
        while (++index < length) {
          const character = string.charAt(index);
          if (options.es6) {
            const first = string.charCodeAt(index);
            if (first >= 55296 && first <= 56319 && length > index + 1) {
              const second = string.charCodeAt(index + 1);
              if (second >= 56320 && second <= 57343) {
                const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                let hexadecimal2 = codePoint.toString(16);
                if (!lowercaseHex) {
                  hexadecimal2 = hexadecimal2.toUpperCase();
                }
                result += "\\u{" + hexadecimal2 + "}";
                ++index;
                continue;
              }
            }
          }
          if (!options.escapeEverything) {
            if (regexWhitelist.test(character)) {
              result += character;
              continue;
            }
            if (character == '"') {
              result += quote == character ? '\\"' : character;
              continue;
            }
            if (character == "`") {
              result += quote == character ? "\\`" : character;
              continue;
            }
            if (character == "'") {
              result += quote == character ? "\\'" : character;
              continue;
            }
          }
          if (character == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
            result += "\\0";
            continue;
          }
          if (regexSingleEscape.test(character)) {
            result += singleEscapes[character];
            continue;
          }
          const charCode = character.charCodeAt(0);
          if (options.minimal && charCode != 8232 && charCode != 8233) {
            result += character;
            continue;
          }
          let hexadecimal = charCode.toString(16);
          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }
          const longhand = hexadecimal.length > 2 || json;
          const escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
          result += escaped;
          continue;
        }
        if (options.wrap) {
          result = quote + result + quote;
        }
        if (quote == "`") {
          result = result.replace(/\$\{/g, "\\${");
        }
        if (options.isScriptContext) {
          return result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
        }
        return result;
      };
      jsesc.version = "2.5.2";
      module.exports = jsesc;
    }
  });

  // ../node_modules/@babel/generator/lib/generators/types.js
  var require_types = __commonJS({
    "../node_modules/@babel/generator/lib/generators/types.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArgumentPlaceholder = ArgumentPlaceholder;
      exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
      exports.BigIntLiteral = BigIntLiteral;
      exports.BooleanLiteral = BooleanLiteral;
      exports.DecimalLiteral = DecimalLiteral;
      exports.Identifier = Identifier;
      exports.NullLiteral = NullLiteral;
      exports.NumericLiteral = NumericLiteral;
      exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
      exports.ObjectMethod = ObjectMethod;
      exports.ObjectProperty = ObjectProperty;
      exports.PipelineBareFunction = PipelineBareFunction;
      exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
      exports.PipelineTopicExpression = PipelineTopicExpression;
      exports.RecordExpression = RecordExpression;
      exports.RegExpLiteral = RegExpLiteral;
      exports.SpreadElement = exports.RestElement = RestElement;
      exports.StringLiteral = StringLiteral;
      exports.TopicReference = TopicReference;
      exports.TupleExpression = TupleExpression;
      var _t = require_lib3();
      var _jsesc = require_jsesc();
      var {
        isAssignmentPattern,
        isIdentifier
      } = _t;
      function Identifier(node) {
        this.exactSource(node.loc, () => {
          this.word(node.name);
        });
      }
      function ArgumentPlaceholder() {
        this.tokenChar(63);
      }
      function RestElement(node) {
        this.token("...");
        this.print(node.argument, node);
      }
      function ObjectExpression(node) {
        const props = node.properties;
        this.tokenChar(123);
        this.printInnerComments(node);
        if (props.length) {
          this.space();
          this.printList(props, node, {
            indent: true,
            statement: true
          });
          this.space();
        }
        this.tokenChar(125);
      }
      function ObjectMethod(node) {
        this.printJoin(node.decorators, node);
        this._methodHead(node);
        this.space();
        this.print(node.body, node);
      }
      function ObjectProperty(node) {
        this.printJoin(node.decorators, node);
        if (node.computed) {
          this.tokenChar(91);
          this.print(node.key, node);
          this.tokenChar(93);
        } else {
          if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
            this.print(node.value, node);
            return;
          }
          this.print(node.key, node);
          if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
            return;
          }
        }
        this.tokenChar(58);
        this.space();
        this.print(node.value, node);
      }
      function ArrayExpression(node) {
        const elems = node.elements;
        const len = elems.length;
        this.tokenChar(91);
        this.printInnerComments(node);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          if (elem) {
            if (i > 0)
              this.space();
            this.print(elem, node);
            if (i < len - 1)
              this.tokenChar(44);
          } else {
            this.tokenChar(44);
          }
        }
        this.tokenChar(93);
      }
      function RecordExpression(node) {
        const props = node.properties;
        let startToken;
        let endToken;
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#{";
          endToken = "}";
        } else {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        }
        this.token(startToken);
        this.printInnerComments(node);
        if (props.length) {
          this.space();
          this.printList(props, node, {
            indent: true,
            statement: true
          });
          this.space();
        }
        this.token(endToken);
      }
      function TupleExpression(node) {
        const elems = node.elements;
        const len = elems.length;
        let startToken;
        let endToken;
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
        this.token(startToken);
        this.printInnerComments(node);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          if (elem) {
            if (i > 0)
              this.space();
            this.print(elem, node);
            if (i < len - 1)
              this.tokenChar(44);
          }
        }
        this.token(endToken);
      }
      function RegExpLiteral(node) {
        this.word(`/${node.pattern}/${node.flags}`);
      }
      function BooleanLiteral(node) {
        this.word(node.value ? "true" : "false");
      }
      function NullLiteral() {
        this.word("null");
      }
      function NumericLiteral(node) {
        const raw = this.getPossibleRaw(node);
        const opts = this.format.jsescOption;
        const value = node.value + "";
        if (opts.numbers) {
          this.number(_jsesc(node.value, opts));
        } else if (raw == null) {
          this.number(value);
        } else if (this.format.minified) {
          this.number(raw.length < value.length ? raw : value);
        } else {
          this.number(raw);
        }
      }
      function StringLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.token(raw);
          return;
        }
        const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
          json: true
        }));
        return this.token(val);
      }
      function BigIntLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.word(raw);
          return;
        }
        this.word(node.value + "n");
      }
      function DecimalLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.word(raw);
          return;
        }
        this.word(node.value + "m");
      }
      var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      function TopicReference() {
        const {
          topicToken
        } = this.format;
        if (validTopicTokenSet.has(topicToken)) {
          this.token(topicToken);
        } else {
          const givenTopicTokenJSON = JSON.stringify(topicToken);
          const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
          throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
        }
      }
      function PipelineTopicExpression(node) {
        this.print(node.expression, node);
      }
      function PipelineBareFunction(node) {
        this.print(node.callee, node);
      }
      function PipelinePrimaryTopicReference() {
        this.tokenChar(35);
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/flow.js
  var require_flow2 = __commonJS({
    "../node_modules/@babel/generator/lib/generators/flow.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnyTypeAnnotation = AnyTypeAnnotation;
      exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
      exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
      exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
      exports.DeclareClass = DeclareClass;
      exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
      exports.DeclareExportDeclaration = DeclareExportDeclaration;
      exports.DeclareFunction = DeclareFunction;
      exports.DeclareInterface = DeclareInterface;
      exports.DeclareModule = DeclareModule;
      exports.DeclareModuleExports = DeclareModuleExports;
      exports.DeclareOpaqueType = DeclareOpaqueType;
      exports.DeclareTypeAlias = DeclareTypeAlias;
      exports.DeclareVariable = DeclareVariable;
      exports.DeclaredPredicate = DeclaredPredicate;
      exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
      exports.EnumBooleanBody = EnumBooleanBody;
      exports.EnumBooleanMember = EnumBooleanMember;
      exports.EnumDeclaration = EnumDeclaration;
      exports.EnumDefaultedMember = EnumDefaultedMember;
      exports.EnumNumberBody = EnumNumberBody;
      exports.EnumNumberMember = EnumNumberMember;
      exports.EnumStringBody = EnumStringBody;
      exports.EnumStringMember = EnumStringMember;
      exports.EnumSymbolBody = EnumSymbolBody;
      exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
      exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
      exports.FunctionTypeParam = FunctionTypeParam;
      exports.IndexedAccessType = IndexedAccessType;
      exports.InferredPredicate = InferredPredicate;
      exports.InterfaceDeclaration = InterfaceDeclaration;
      exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
      exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
      exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
      exports.MixedTypeAnnotation = MixedTypeAnnotation;
      exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
      exports.NullableTypeAnnotation = NullableTypeAnnotation;
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _types2.NumericLiteral;
        }
      });
      exports.NumberTypeAnnotation = NumberTypeAnnotation;
      exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
      exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
      exports.ObjectTypeIndexer = ObjectTypeIndexer;
      exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
      exports.ObjectTypeProperty = ObjectTypeProperty;
      exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
      exports.OpaqueType = OpaqueType;
      exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
      exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function() {
          return _types2.StringLiteral;
        }
      });
      exports.StringTypeAnnotation = StringTypeAnnotation;
      exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
      exports.ThisTypeAnnotation = ThisTypeAnnotation;
      exports.TupleTypeAnnotation = TupleTypeAnnotation;
      exports.TypeAlias = TypeAlias;
      exports.TypeAnnotation = TypeAnnotation;
      exports.TypeCastExpression = TypeCastExpression;
      exports.TypeParameter = TypeParameter;
      exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
      exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
      exports.UnionTypeAnnotation = UnionTypeAnnotation;
      exports.Variance = Variance;
      exports.VoidTypeAnnotation = VoidTypeAnnotation;
      exports._interfaceish = _interfaceish;
      exports._variance = _variance;
      var _t = require_lib3();
      var _modules = require_modules();
      var _types2 = require_types();
      var {
        isDeclareExportDeclaration,
        isStatement
      } = _t;
      function AnyTypeAnnotation() {
        this.word("any");
      }
      function ArrayTypeAnnotation(node) {
        this.print(node.elementType, node, true);
        this.tokenChar(91);
        this.tokenChar(93);
      }
      function BooleanTypeAnnotation() {
        this.word("boolean");
      }
      function BooleanLiteralTypeAnnotation(node) {
        this.word(node.value ? "true" : "false");
      }
      function NullLiteralTypeAnnotation() {
        this.word("null");
      }
      function DeclareClass(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("class");
        this.space();
        this._interfaceish(node);
      }
      function DeclareFunction(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("function");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation.typeAnnotation, node);
        if (node.predicate) {
          this.space();
          this.print(node.predicate, node);
        }
        this.semicolon();
      }
      function InferredPredicate() {
        this.tokenChar(37);
        this.word("checks");
      }
      function DeclaredPredicate(node) {
        this.tokenChar(37);
        this.word("checks");
        this.tokenChar(40);
        this.print(node.value, node);
        this.tokenChar(41);
      }
      function DeclareInterface(node) {
        this.word("declare");
        this.space();
        this.InterfaceDeclaration(node);
      }
      function DeclareModule(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.space();
        this.print(node.id, node);
        this.space();
        this.print(node.body, node);
      }
      function DeclareModuleExports(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.tokenChar(46);
        this.word("exports");
        this.print(node.typeAnnotation, node);
      }
      function DeclareTypeAlias(node) {
        this.word("declare");
        this.space();
        this.TypeAlias(node);
      }
      function DeclareOpaqueType(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.OpaqueType(node);
      }
      function DeclareVariable(node, parent) {
        if (!isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("var");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation, node);
        this.semicolon();
      }
      function DeclareExportDeclaration(node) {
        this.word("declare");
        this.space();
        this.word("export");
        this.space();
        if (node.default) {
          this.word("default");
          this.space();
        }
        FlowExportDeclaration.call(this, node);
      }
      function DeclareExportAllDeclaration(node) {
        this.word("declare");
        this.space();
        _modules.ExportAllDeclaration.call(this, node);
      }
      function EnumDeclaration(node) {
        const {
          id,
          body
        } = node;
        this.word("enum");
        this.space();
        this.print(id, node);
        this.print(body, node);
      }
      function enumExplicitType(context, name, hasExplicitType) {
        if (hasExplicitType) {
          context.space();
          context.word("of");
          context.space();
          context.word(name);
        }
        context.space();
      }
      function enumBody(context, node) {
        const {
          members
        } = node;
        context.token("{");
        context.indent();
        context.newline();
        for (const member of members) {
          context.print(member, node);
          context.newline();
        }
        if (node.hasUnknownMembers) {
          context.token("...");
          context.newline();
        }
        context.dedent();
        context.token("}");
      }
      function EnumBooleanBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "boolean", explicitType);
        enumBody(this, node);
      }
      function EnumNumberBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "number", explicitType);
        enumBody(this, node);
      }
      function EnumStringBody(node) {
        const {
          explicitType
        } = node;
        enumExplicitType(this, "string", explicitType);
        enumBody(this, node);
      }
      function EnumSymbolBody(node) {
        enumExplicitType(this, "symbol", true);
        enumBody(this, node);
      }
      function EnumDefaultedMember(node) {
        const {
          id
        } = node;
        this.print(id, node);
        this.tokenChar(44);
      }
      function enumInitializedMember(context, node) {
        const {
          id,
          init
        } = node;
        context.print(id, node);
        context.space();
        context.token("=");
        context.space();
        context.print(init, node);
        context.token(",");
      }
      function EnumBooleanMember(node) {
        enumInitializedMember(this, node);
      }
      function EnumNumberMember(node) {
        enumInitializedMember(this, node);
      }
      function EnumStringMember(node) {
        enumInitializedMember(this, node);
      }
      function FlowExportDeclaration(node) {
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node);
          if (!isStatement(declar))
            this.semicolon();
        } else {
          this.tokenChar(123);
          if (node.specifiers.length) {
            this.space();
            this.printList(node.specifiers, node);
            this.space();
          }
          this.tokenChar(125);
          if (node.source) {
            this.space();
            this.word("from");
            this.space();
            this.print(node.source, node);
          }
          this.semicolon();
        }
      }
      function ExistsTypeAnnotation() {
        this.tokenChar(42);
      }
      function FunctionTypeAnnotation(node, parent) {
        this.print(node.typeParameters, node);
        this.tokenChar(40);
        if (node.this) {
          this.word("this");
          this.tokenChar(58);
          this.space();
          this.print(node.this.typeAnnotation, node);
          if (node.params.length || node.rest) {
            this.tokenChar(44);
            this.space();
          }
        }
        this.printList(node.params, node);
        if (node.rest) {
          if (node.params.length) {
            this.tokenChar(44);
            this.space();
          }
          this.token("...");
          this.print(node.rest, node);
        }
        this.tokenChar(41);
        if (parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method)) {
          this.tokenChar(58);
        } else {
          this.space();
          this.token("=>");
        }
        this.space();
        this.print(node.returnType, node);
      }
      function FunctionTypeParam(node) {
        this.print(node.name, node);
        if (node.optional)
          this.tokenChar(63);
        if (node.name) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.typeAnnotation, node);
      }
      function InterfaceExtends(node) {
        this.print(node.id, node);
        this.print(node.typeParameters, node, true);
      }
      function _interfaceish(node) {
        var _node$extends;
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if ((_node$extends = node.extends) != null && _node$extends.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node.extends, node);
        }
        if (node.mixins && node.mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins, node);
        }
        if (node.implements && node.implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function _variance(node) {
        if (node.variance) {
          if (node.variance.kind === "plus") {
            this.tokenChar(43);
          } else if (node.variance.kind === "minus") {
            this.tokenChar(45);
          }
        }
      }
      function InterfaceDeclaration(node) {
        this.word("interface");
        this.space();
        this._interfaceish(node);
      }
      function andSeparator() {
        this.space();
        this.tokenChar(38);
        this.space();
      }
      function InterfaceTypeAnnotation(node) {
        this.word("interface");
        if (node.extends && node.extends.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node.extends, node);
        }
        this.space();
        this.print(node.body, node);
      }
      function IntersectionTypeAnnotation(node) {
        this.printJoin(node.types, node, {
          separator: andSeparator
        });
      }
      function MixedTypeAnnotation() {
        this.word("mixed");
      }
      function EmptyTypeAnnotation() {
        this.word("empty");
      }
      function NullableTypeAnnotation(node) {
        this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function NumberTypeAnnotation() {
        this.word("number");
      }
      function StringTypeAnnotation() {
        this.word("string");
      }
      function ThisTypeAnnotation() {
        this.word("this");
      }
      function TupleTypeAnnotation(node) {
        this.tokenChar(91);
        this.printList(node.types, node);
        this.tokenChar(93);
      }
      function TypeofTypeAnnotation(node) {
        this.word("typeof");
        this.space();
        this.print(node.argument, node);
      }
      function TypeAlias(node) {
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.right, node);
        this.semicolon();
      }
      function TypeAnnotation(node) {
        this.tokenChar(58);
        this.space();
        if (node.optional)
          this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function TypeParameterInstantiation(node) {
        this.tokenChar(60);
        this.printList(node.params, node, {});
        this.tokenChar(62);
      }
      function TypeParameter(node) {
        this._variance(node);
        this.word(node.name);
        if (node.bound) {
          this.print(node.bound, node);
        }
        if (node.default) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.default, node);
        }
      }
      function OpaqueType(node) {
        this.word("opaque");
        this.space();
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if (node.supertype) {
          this.tokenChar(58);
          this.space();
          this.print(node.supertype, node);
        }
        if (node.impltype) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.impltype, node);
        }
        this.semicolon();
      }
      function ObjectTypeAnnotation(node) {
        if (node.exact) {
          this.token("{|");
        } else {
          this.tokenChar(123);
        }
        const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
        if (props.length) {
          this.space();
          this.printJoin(props, node, {
            addNewlines(leading) {
              if (leading && !props[0])
                return 1;
            },
            indent: true,
            statement: true,
            iterator: () => {
              if (props.length !== 1 || node.inexact) {
                this.tokenChar(44);
                this.space();
              }
            }
          });
          this.space();
        }
        if (node.inexact) {
          this.indent();
          this.token("...");
          if (props.length) {
            this.newline();
          }
          this.dedent();
        }
        if (node.exact) {
          this.token("|}");
        } else {
          this.tokenChar(125);
        }
      }
      function ObjectTypeInternalSlot(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.tokenChar(91);
        this.tokenChar(91);
        this.print(node.id, node);
        this.tokenChar(93);
        this.tokenChar(93);
        if (node.optional)
          this.tokenChar(63);
        if (!node.method) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeCallProperty(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeIndexer(node) {
        if (node.static) {
          this.word("static");
          this.space();
        }
        this._variance(node);
        this.tokenChar(91);
        if (node.id) {
          this.print(node.id, node);
          this.tokenChar(58);
          this.space();
        }
        this.print(node.key, node);
        this.tokenChar(93);
        this.tokenChar(58);
        this.space();
        this.print(node.value, node);
      }
      function ObjectTypeProperty(node) {
        if (node.proto) {
          this.word("proto");
          this.space();
        }
        if (node.static) {
          this.word("static");
          this.space();
        }
        if (node.kind === "get" || node.kind === "set") {
          this.word(node.kind);
          this.space();
        }
        this._variance(node);
        this.print(node.key, node);
        if (node.optional)
          this.tokenChar(63);
        if (!node.method) {
          this.tokenChar(58);
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeSpreadProperty(node) {
        this.token("...");
        this.print(node.argument, node);
      }
      function QualifiedTypeIdentifier(node) {
        this.print(node.qualification, node);
        this.tokenChar(46);
        this.print(node.id, node);
      }
      function SymbolTypeAnnotation() {
        this.word("symbol");
      }
      function orSeparator() {
        this.space();
        this.tokenChar(124);
        this.space();
      }
      function UnionTypeAnnotation(node) {
        this.printJoin(node.types, node, {
          separator: orSeparator
        });
      }
      function TypeCastExpression(node) {
        this.tokenChar(40);
        this.print(node.expression, node);
        this.print(node.typeAnnotation, node);
        this.tokenChar(41);
      }
      function Variance(node) {
        if (node.kind === "plus") {
          this.tokenChar(43);
        } else {
          this.tokenChar(45);
        }
      }
      function VoidTypeAnnotation() {
        this.word("void");
      }
      function IndexedAccessType(node) {
        this.print(node.objectType, node, true);
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
      function OptionalIndexedAccessType(node) {
        this.print(node.objectType, node);
        if (node.optional) {
          this.token("?.");
        }
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/base.js
  var require_base = __commonJS({
    "../node_modules/@babel/generator/lib/generators/base.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BlockStatement = BlockStatement;
      exports.Directive = Directive2;
      exports.DirectiveLiteral = DirectiveLiteral;
      exports.File = File;
      exports.InterpreterDirective = InterpreterDirective;
      exports.Placeholder = Placeholder;
      exports.Program = Program;
      function File(node) {
        if (node.program) {
          this.print(node.program.interpreter, node);
        }
        this.print(node.program, node);
      }
      function Program(node) {
        this.printInnerComments(node, false);
        this.printSequence(node.directives, node);
        if (node.directives && node.directives.length)
          this.newline();
        this.printSequence(node.body, node);
      }
      function BlockStatement(node) {
        var _node$directives;
        this.tokenChar(123);
        this.printInnerComments(node);
        const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
        if (node.body.length || hasDirectives) {
          this.newline();
          this.printSequence(node.directives, node, {
            indent: true
          });
          if (hasDirectives)
            this.newline();
          this.printSequence(node.body, node, {
            indent: true
          });
          this.removeTrailingNewline();
          this.source("end", node.loc);
          if (!this.endsWith(10))
            this.newline();
          this.rightBrace();
        } else {
          this.source("end", node.loc);
          this.tokenChar(125);
        }
      }
      function Directive2(node) {
        this.print(node.value, node);
        this.semicolon();
      }
      var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
      var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
      function DirectiveLiteral(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && raw !== void 0) {
          this.token(raw);
          return;
        }
        const {
          value
        } = node;
        if (!unescapedDoubleQuoteRE.test(value)) {
          this.token(`"${value}"`);
        } else if (!unescapedSingleQuoteRE.test(value)) {
          this.token(`'${value}'`);
        } else {
          throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
        }
      }
      function InterpreterDirective(node) {
        this.token(`#!${node.value}
`, true);
      }
      function Placeholder(node) {
        this.token("%%");
        this.print(node.name);
        this.token("%%");
        if (node.expectedNode === "Statement") {
          this.semicolon();
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/jsx.js
  var require_jsx2 = __commonJS({
    "../node_modules/@babel/generator/lib/generators/jsx.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.JSXAttribute = JSXAttribute;
      exports.JSXClosingElement = JSXClosingElement;
      exports.JSXClosingFragment = JSXClosingFragment;
      exports.JSXElement = JSXElement;
      exports.JSXEmptyExpression = JSXEmptyExpression;
      exports.JSXExpressionContainer = JSXExpressionContainer;
      exports.JSXFragment = JSXFragment;
      exports.JSXIdentifier = JSXIdentifier;
      exports.JSXMemberExpression = JSXMemberExpression;
      exports.JSXNamespacedName = JSXNamespacedName;
      exports.JSXOpeningElement = JSXOpeningElement;
      exports.JSXOpeningFragment = JSXOpeningFragment;
      exports.JSXSpreadAttribute = JSXSpreadAttribute;
      exports.JSXSpreadChild = JSXSpreadChild;
      exports.JSXText = JSXText;
      function JSXAttribute(node) {
        this.print(node.name, node);
        if (node.value) {
          this.tokenChar(61);
          this.print(node.value, node);
        }
      }
      function JSXIdentifier(node) {
        this.word(node.name);
      }
      function JSXNamespacedName(node) {
        this.print(node.namespace, node);
        this.tokenChar(58);
        this.print(node.name, node);
      }
      function JSXMemberExpression(node) {
        this.print(node.object, node);
        this.tokenChar(46);
        this.print(node.property, node);
      }
      function JSXSpreadAttribute(node) {
        this.tokenChar(123);
        this.token("...");
        this.print(node.argument, node);
        this.tokenChar(125);
      }
      function JSXExpressionContainer(node) {
        this.tokenChar(123);
        this.print(node.expression, node);
        this.tokenChar(125);
      }
      function JSXSpreadChild(node) {
        this.tokenChar(123);
        this.token("...");
        this.print(node.expression, node);
        this.tokenChar(125);
      }
      function JSXText(node) {
        const raw = this.getPossibleRaw(node);
        if (raw !== void 0) {
          this.token(raw, true);
        } else {
          this.token(node.value, true);
        }
      }
      function JSXElement(node) {
        const open = node.openingElement;
        this.print(open, node);
        if (open.selfClosing)
          return;
        this.indent();
        for (const child of node.children) {
          this.print(child, node);
        }
        this.dedent();
        this.print(node.closingElement, node);
      }
      function spaceSeparator() {
        this.space();
      }
      function JSXOpeningElement(node) {
        this.tokenChar(60);
        this.print(node.name, node);
        this.print(node.typeParameters, node);
        if (node.attributes.length > 0) {
          this.space();
          this.printJoin(node.attributes, node, {
            separator: spaceSeparator
          });
        }
        if (node.selfClosing) {
          this.space();
          this.token("/>");
        } else {
          this.tokenChar(62);
        }
      }
      function JSXClosingElement(node) {
        this.token("</");
        this.print(node.name, node);
        this.tokenChar(62);
      }
      function JSXEmptyExpression(node) {
        this.printInnerComments(node);
      }
      function JSXFragment(node) {
        this.print(node.openingFragment, node);
        this.indent();
        for (const child of node.children) {
          this.print(child, node);
        }
        this.dedent();
        this.print(node.closingFragment, node);
      }
      function JSXOpeningFragment() {
        this.tokenChar(60);
        this.tokenChar(62);
      }
      function JSXClosingFragment() {
        this.token("</");
        this.tokenChar(62);
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/typescript.js
  var require_typescript2 = __commonJS({
    "../node_modules/@babel/generator/lib/generators/typescript.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TSAnyKeyword = TSAnyKeyword;
      exports.TSArrayType = TSArrayType;
      exports.TSAsExpression = TSAsExpression;
      exports.TSBigIntKeyword = TSBigIntKeyword;
      exports.TSBooleanKeyword = TSBooleanKeyword;
      exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
      exports.TSConditionalType = TSConditionalType;
      exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
      exports.TSConstructorType = TSConstructorType;
      exports.TSDeclareFunction = TSDeclareFunction;
      exports.TSDeclareMethod = TSDeclareMethod;
      exports.TSEnumDeclaration = TSEnumDeclaration;
      exports.TSEnumMember = TSEnumMember;
      exports.TSExportAssignment = TSExportAssignment;
      exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
      exports.TSExternalModuleReference = TSExternalModuleReference;
      exports.TSFunctionType = TSFunctionType;
      exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
      exports.TSImportType = TSImportType;
      exports.TSIndexSignature = TSIndexSignature;
      exports.TSIndexedAccessType = TSIndexedAccessType;
      exports.TSInferType = TSInferType;
      exports.TSInstantiationExpression = TSInstantiationExpression;
      exports.TSInterfaceBody = TSInterfaceBody;
      exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
      exports.TSIntersectionType = TSIntersectionType;
      exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
      exports.TSLiteralType = TSLiteralType;
      exports.TSMappedType = TSMappedType;
      exports.TSMethodSignature = TSMethodSignature;
      exports.TSModuleBlock = TSModuleBlock;
      exports.TSModuleDeclaration = TSModuleDeclaration;
      exports.TSNamedTupleMember = TSNamedTupleMember;
      exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
      exports.TSNeverKeyword = TSNeverKeyword;
      exports.TSNonNullExpression = TSNonNullExpression;
      exports.TSNullKeyword = TSNullKeyword;
      exports.TSNumberKeyword = TSNumberKeyword;
      exports.TSObjectKeyword = TSObjectKeyword;
      exports.TSOptionalType = TSOptionalType;
      exports.TSParameterProperty = TSParameterProperty;
      exports.TSParenthesizedType = TSParenthesizedType;
      exports.TSPropertySignature = TSPropertySignature;
      exports.TSQualifiedName = TSQualifiedName;
      exports.TSRestType = TSRestType;
      exports.TSStringKeyword = TSStringKeyword;
      exports.TSSymbolKeyword = TSSymbolKeyword;
      exports.TSThisType = TSThisType;
      exports.TSTupleType = TSTupleType;
      exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
      exports.TSTypeAnnotation = TSTypeAnnotation;
      exports.TSTypeAssertion = TSTypeAssertion;
      exports.TSTypeLiteral = TSTypeLiteral;
      exports.TSTypeOperator = TSTypeOperator;
      exports.TSTypeParameter = TSTypeParameter;
      exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
      exports.TSTypePredicate = TSTypePredicate;
      exports.TSTypeQuery = TSTypeQuery;
      exports.TSTypeReference = TSTypeReference;
      exports.TSUndefinedKeyword = TSUndefinedKeyword;
      exports.TSUnionType = TSUnionType;
      exports.TSUnknownKeyword = TSUnknownKeyword;
      exports.TSVoidKeyword = TSVoidKeyword;
      exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
      exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
      exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
      exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
      exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
      function TSTypeAnnotation(node) {
        this.tokenChar(58);
        this.space();
        if (node.optional)
          this.tokenChar(63);
        this.print(node.typeAnnotation, node);
      }
      function TSTypeParameterInstantiation(node, parent) {
        this.tokenChar(60);
        this.printList(node.params, node, {});
        if (parent.type === "ArrowFunctionExpression" && node.params.length === 1) {
          this.tokenChar(44);
        }
        this.tokenChar(62);
      }
      function TSTypeParameter(node) {
        if (node.in) {
          this.word("in");
          this.space();
        }
        if (node.out) {
          this.word("out");
          this.space();
        }
        this.word(node.name);
        if (node.constraint) {
          this.space();
          this.word("extends");
          this.space();
          this.print(node.constraint, node);
        }
        if (node.default) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(node.default, node);
        }
      }
      function TSParameterProperty(node) {
        if (node.accessibility) {
          this.word(node.accessibility);
          this.space();
        }
        if (node.readonly) {
          this.word("readonly");
          this.space();
        }
        this._param(node.parameter);
      }
      function TSDeclareFunction(node) {
        if (node.declare) {
          this.word("declare");
          this.space();
        }
        this._functionHead(node);
        this.tokenChar(59);
      }
      function TSDeclareMethod(node) {
        this._classMethodHead(node);
        this.tokenChar(59);
      }
      function TSQualifiedName(node) {
        this.print(node.left, node);
        this.tokenChar(46);
        this.print(node.right, node);
      }
      function TSCallSignatureDeclaration(node) {
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSConstructSignatureDeclaration(node) {
        this.word("new");
        this.space();
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSPropertySignature(node) {
        const {
          readonly,
          initializer
        } = node;
        if (readonly) {
          this.word("readonly");
          this.space();
        }
        this.tsPrintPropertyOrMethodName(node);
        this.print(node.typeAnnotation, node);
        if (initializer) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(initializer, node);
        }
        this.tokenChar(59);
      }
      function tsPrintPropertyOrMethodName(node) {
        if (node.computed) {
          this.tokenChar(91);
        }
        this.print(node.key, node);
        if (node.computed) {
          this.tokenChar(93);
        }
        if (node.optional) {
          this.tokenChar(63);
        }
      }
      function TSMethodSignature(node) {
        const {
          kind
        } = node;
        if (kind === "set" || kind === "get") {
          this.word(kind);
          this.space();
        }
        this.tsPrintPropertyOrMethodName(node);
        this.tsPrintSignatureDeclarationBase(node);
        this.tokenChar(59);
      }
      function TSIndexSignature(node) {
        const {
          readonly,
          static: isStatic
        } = node;
        if (isStatic) {
          this.word("static");
          this.space();
        }
        if (readonly) {
          this.word("readonly");
          this.space();
        }
        this.tokenChar(91);
        this._parameters(node.parameters, node);
        this.tokenChar(93);
        this.print(node.typeAnnotation, node);
        this.tokenChar(59);
      }
      function TSAnyKeyword() {
        this.word("any");
      }
      function TSBigIntKeyword() {
        this.word("bigint");
      }
      function TSUnknownKeyword() {
        this.word("unknown");
      }
      function TSNumberKeyword() {
        this.word("number");
      }
      function TSObjectKeyword() {
        this.word("object");
      }
      function TSBooleanKeyword() {
        this.word("boolean");
      }
      function TSStringKeyword() {
        this.word("string");
      }
      function TSSymbolKeyword() {
        this.word("symbol");
      }
      function TSVoidKeyword() {
        this.word("void");
      }
      function TSUndefinedKeyword() {
        this.word("undefined");
      }
      function TSNullKeyword() {
        this.word("null");
      }
      function TSNeverKeyword() {
        this.word("never");
      }
      function TSIntrinsicKeyword() {
        this.word("intrinsic");
      }
      function TSThisType() {
        this.word("this");
      }
      function TSFunctionType(node) {
        this.tsPrintFunctionOrConstructorType(node);
      }
      function TSConstructorType(node) {
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        this.word("new");
        this.space();
        this.tsPrintFunctionOrConstructorType(node);
      }
      function tsPrintFunctionOrConstructorType(node) {
        const {
          typeParameters
        } = node;
        const parameters = node.parameters;
        this.print(typeParameters, node);
        this.tokenChar(40);
        this._parameters(parameters, node);
        this.tokenChar(41);
        this.space();
        this.token("=>");
        this.space();
        const returnType = node.typeAnnotation;
        this.print(returnType.typeAnnotation, node);
      }
      function TSTypeReference(node) {
        this.print(node.typeName, node, true);
        this.print(node.typeParameters, node, true);
      }
      function TSTypePredicate(node) {
        if (node.asserts) {
          this.word("asserts");
          this.space();
        }
        this.print(node.parameterName);
        if (node.typeAnnotation) {
          this.space();
          this.word("is");
          this.space();
          this.print(node.typeAnnotation.typeAnnotation);
        }
      }
      function TSTypeQuery(node) {
        this.word("typeof");
        this.space();
        this.print(node.exprName);
        if (node.typeParameters) {
          this.print(node.typeParameters, node);
        }
      }
      function TSTypeLiteral(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
      }
      function tsPrintTypeLiteralOrInterfaceBody(members, node) {
        tsPrintBraced(this, members, node);
      }
      function tsPrintBraced(printer, members, node) {
        printer.token("{");
        if (members.length) {
          printer.indent();
          printer.newline();
          for (const member of members) {
            printer.print(member, node);
            printer.newline();
          }
          printer.dedent();
          printer.rightBrace();
        } else {
          printer.token("}");
        }
      }
      function TSArrayType(node) {
        this.print(node.elementType, node, true);
        this.token("[]");
      }
      function TSTupleType(node) {
        this.tokenChar(91);
        this.printList(node.elementTypes, node);
        this.tokenChar(93);
      }
      function TSOptionalType(node) {
        this.print(node.typeAnnotation, node);
        this.tokenChar(63);
      }
      function TSRestType(node) {
        this.token("...");
        this.print(node.typeAnnotation, node);
      }
      function TSNamedTupleMember(node) {
        this.print(node.label, node);
        if (node.optional)
          this.tokenChar(63);
        this.tokenChar(58);
        this.space();
        this.print(node.elementType, node);
      }
      function TSUnionType(node) {
        tsPrintUnionOrIntersectionType(this, node, "|");
      }
      function TSIntersectionType(node) {
        tsPrintUnionOrIntersectionType(this, node, "&");
      }
      function tsPrintUnionOrIntersectionType(printer, node, sep) {
        printer.printJoin(node.types, node, {
          separator() {
            this.space();
            this.token(sep);
            this.space();
          }
        });
      }
      function TSConditionalType(node) {
        this.print(node.checkType);
        this.space();
        this.word("extends");
        this.space();
        this.print(node.extendsType);
        this.space();
        this.tokenChar(63);
        this.space();
        this.print(node.trueType);
        this.space();
        this.tokenChar(58);
        this.space();
        this.print(node.falseType);
      }
      function TSInferType(node) {
        this.token("infer");
        this.space();
        this.print(node.typeParameter);
      }
      function TSParenthesizedType(node) {
        this.tokenChar(40);
        this.print(node.typeAnnotation, node);
        this.tokenChar(41);
      }
      function TSTypeOperator(node) {
        this.word(node.operator);
        this.space();
        this.print(node.typeAnnotation, node);
      }
      function TSIndexedAccessType(node) {
        this.print(node.objectType, node, true);
        this.tokenChar(91);
        this.print(node.indexType, node);
        this.tokenChar(93);
      }
      function TSMappedType(node) {
        const {
          nameType,
          optional,
          readonly,
          typeParameter
        } = node;
        this.tokenChar(123);
        this.space();
        if (readonly) {
          tokenIfPlusMinus(this, readonly);
          this.word("readonly");
          this.space();
        }
        this.tokenChar(91);
        this.word(typeParameter.name);
        this.space();
        this.word("in");
        this.space();
        this.print(typeParameter.constraint, typeParameter);
        if (nameType) {
          this.space();
          this.word("as");
          this.space();
          this.print(nameType, node);
        }
        this.tokenChar(93);
        if (optional) {
          tokenIfPlusMinus(this, optional);
          this.tokenChar(63);
        }
        this.tokenChar(58);
        this.space();
        this.print(node.typeAnnotation, node);
        this.space();
        this.tokenChar(125);
      }
      function tokenIfPlusMinus(self2, tok) {
        if (tok !== true) {
          self2.token(tok);
        }
      }
      function TSLiteralType(node) {
        this.print(node.literal, node);
      }
      function TSExpressionWithTypeArguments(node) {
        this.print(node.expression, node);
        this.print(node.typeParameters, node);
      }
      function TSInterfaceDeclaration(node) {
        const {
          declare,
          id,
          typeParameters,
          extends: extendz,
          body
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        this.word("interface");
        this.space();
        this.print(id, node);
        this.print(typeParameters, node);
        if (extendz != null && extendz.length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(extendz, node);
        }
        this.space();
        this.print(body, node);
      }
      function TSInterfaceBody(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
      }
      function TSTypeAliasDeclaration(node) {
        const {
          declare,
          id,
          typeParameters,
          typeAnnotation
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        this.word("type");
        this.space();
        this.print(id, node);
        this.print(typeParameters, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(typeAnnotation, node);
        this.tokenChar(59);
      }
      function TSAsExpression(node) {
        const {
          expression,
          typeAnnotation
        } = node;
        this.print(expression, node);
        this.space();
        this.word("as");
        this.space();
        this.print(typeAnnotation, node);
      }
      function TSTypeAssertion(node) {
        const {
          typeAnnotation,
          expression
        } = node;
        this.tokenChar(60);
        this.print(typeAnnotation, node);
        this.tokenChar(62);
        this.space();
        this.print(expression, node);
      }
      function TSInstantiationExpression(node) {
        this.print(node.expression, node);
        this.print(node.typeParameters, node);
      }
      function TSEnumDeclaration(node) {
        const {
          declare,
          const: isConst,
          id,
          members
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        if (isConst) {
          this.word("const");
          this.space();
        }
        this.word("enum");
        this.space();
        this.print(id, node);
        this.space();
        tsPrintBraced(this, members, node);
      }
      function TSEnumMember(node) {
        const {
          id,
          initializer
        } = node;
        this.print(id, node);
        if (initializer) {
          this.space();
          this.tokenChar(61);
          this.space();
          this.print(initializer, node);
        }
        this.tokenChar(44);
      }
      function TSModuleDeclaration(node) {
        const {
          declare,
          id
        } = node;
        if (declare) {
          this.word("declare");
          this.space();
        }
        if (!node.global) {
          this.word(id.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id, node);
        if (!node.body) {
          this.tokenChar(59);
          return;
        }
        let body = node.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id, body);
          body = body.body;
        }
        this.space();
        this.print(body, node);
      }
      function TSModuleBlock(node) {
        tsPrintBraced(this, node.body, node);
      }
      function TSImportType(node) {
        const {
          argument,
          qualifier,
          typeParameters
        } = node;
        this.word("import");
        this.tokenChar(40);
        this.print(argument, node);
        this.tokenChar(41);
        if (qualifier) {
          this.tokenChar(46);
          this.print(qualifier, node);
        }
        if (typeParameters) {
          this.print(typeParameters, node);
        }
      }
      function TSImportEqualsDeclaration(node) {
        const {
          isExport,
          id,
          moduleReference
        } = node;
        if (isExport) {
          this.word("export");
          this.space();
        }
        this.word("import");
        this.space();
        this.print(id, node);
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(moduleReference, node);
        this.tokenChar(59);
      }
      function TSExternalModuleReference(node) {
        this.token("require(");
        this.print(node.expression, node);
        this.tokenChar(41);
      }
      function TSNonNullExpression(node) {
        this.print(node.expression, node);
        this.tokenChar(33);
      }
      function TSExportAssignment(node) {
        this.word("export");
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.expression, node);
        this.tokenChar(59);
      }
      function TSNamespaceExportDeclaration(node) {
        this.word("export");
        this.space();
        this.word("as");
        this.space();
        this.word("namespace");
        this.space();
        this.print(node.id, node);
      }
      function tsPrintSignatureDeclarationBase(node) {
        const {
          typeParameters
        } = node;
        const parameters = node.parameters;
        this.print(typeParameters, node);
        this.tokenChar(40);
        this._parameters(parameters, node);
        this.tokenChar(41);
        const returnType = node.typeAnnotation;
        this.print(returnType, node);
      }
      function tsPrintClassMemberModifiers(node) {
        const isField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
        if (isField && node.declare) {
          this.word("declare");
          this.space();
        }
        if (node.accessibility) {
          this.word(node.accessibility);
          this.space();
        }
        if (node.static) {
          this.word("static");
          this.space();
        }
        if (node.override) {
          this.word("override");
          this.space();
        }
        if (node.abstract) {
          this.word("abstract");
          this.space();
        }
        if (isField && node.readonly) {
          this.word("readonly");
          this.space();
        }
      }
    }
  });

  // ../node_modules/@babel/generator/lib/generators/index.js
  var require_generators = __commonJS({
    "../node_modules/@babel/generator/lib/generators/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _templateLiterals = require_template_literals();
      Object.keys(_templateLiterals).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _templateLiterals[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _templateLiterals[key];
          }
        });
      });
      var _expressions = require_expressions();
      Object.keys(_expressions).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _expressions[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _expressions[key];
          }
        });
      });
      var _statements = require_statements();
      Object.keys(_statements).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _statements[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _statements[key];
          }
        });
      });
      var _classes = require_classes();
      Object.keys(_classes).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _classes[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _classes[key];
          }
        });
      });
      var _methods = require_methods();
      Object.keys(_methods).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _methods[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _methods[key];
          }
        });
      });
      var _modules = require_modules();
      Object.keys(_modules).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _modules[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _modules[key];
          }
        });
      });
      var _types = require_types();
      Object.keys(_types).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _types[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _types[key];
          }
        });
      });
      var _flow = require_flow2();
      Object.keys(_flow).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _flow[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _flow[key];
          }
        });
      });
      var _base = require_base();
      Object.keys(_base).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _base[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _base[key];
          }
        });
      });
      var _jsx = require_jsx2();
      Object.keys(_jsx).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _jsx[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _jsx[key];
          }
        });
      });
      var _typescript = require_typescript2();
      Object.keys(_typescript).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _typescript[key])
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return _typescript[key];
          }
        });
      });
    }
  });

  // ../node_modules/@babel/generator/lib/printer.js
  var require_printer = __commonJS({
    "../node_modules/@babel/generator/lib/printer.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _buffer = require_buffer();
      var n = require_node();
      var generatorFunctions = require_generators();
      var SCIENTIFIC_NOTATION = /e/i;
      var ZERO_DECIMAL_INTEGER = /\.0+$/;
      var NON_DECIMAL_LITERAL = /^0[box]/;
      var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
      var {
        needsParens,
        needsWhitespaceAfter,
        needsWhitespaceBefore
      } = n;
      var Printer = class {
        constructor(format, map) {
          this.inForStatementInitCounter = 0;
          this._printStack = [];
          this._indent = 0;
          this._indentChar = 0;
          this._indentRepeat = 0;
          this._insideAux = false;
          this._parenPushNewlineState = null;
          this._noLineTerminator = false;
          this._printAuxAfterOnNextUserNode = false;
          this._printedComments = /* @__PURE__ */ new Set();
          this._endsWithInteger = false;
          this._endsWithWord = false;
          this.format = format;
          this._buf = new _buffer.default(map);
          this._indentChar = format.indent.style.charCodeAt(0);
          this._indentRepeat = format.indent.style.length;
        }
        generate(ast) {
          this.print(ast);
          this._maybeAddAuxComment();
          return this._buf.get();
        }
        indent() {
          if (this.format.compact || this.format.concise)
            return;
          this._indent++;
        }
        dedent() {
          if (this.format.compact || this.format.concise)
            return;
          this._indent--;
        }
        semicolon(force = false) {
          this._maybeAddAuxComment();
          if (force) {
            this._appendChar(59);
          } else {
            this._queue(59);
          }
        }
        rightBrace() {
          if (this.format.minified) {
            this._buf.removeLastSemicolon();
          }
          this.tokenChar(125);
        }
        space(force = false) {
          if (this.format.compact)
            return;
          if (force) {
            this._space();
          } else if (this._buf.hasContent()) {
            const lastCp = this.getLastChar();
            if (lastCp !== 32 && lastCp !== 10) {
              this._space();
            }
          }
        }
        word(str) {
          if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._append(str, false);
          this._endsWithWord = true;
        }
        number(str) {
          this.word(str);
          this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
        }
        token(str, maybeNewline = false) {
          const lastChar = this.getLastChar();
          const strFirst = str.charCodeAt(0);
          if (lastChar === 33 && str === "--" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._append(str, maybeNewline);
        }
        tokenChar(char) {
          const lastChar = this.getLastChar();
          if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
            this._space();
          }
          this._maybeAddAuxComment();
          this._appendChar(char);
        }
        newline(i = 1) {
          if (this.format.retainLines || this.format.compact)
            return;
          if (this.format.concise) {
            this.space();
            return;
          }
          const charBeforeNewline = this.endsWithCharAndNewline();
          if (charBeforeNewline === 10)
            return;
          if (charBeforeNewline === 123 || charBeforeNewline === 58) {
            i--;
          }
          if (i <= 0)
            return;
          for (let j = 0; j < i; j++) {
            this._newline();
          }
        }
        endsWith(char) {
          return this.getLastChar() === char;
        }
        getLastChar() {
          return this._buf.getLastChar();
        }
        endsWithCharAndNewline() {
          return this._buf.endsWithCharAndNewline();
        }
        removeTrailingNewline() {
          this._buf.removeTrailingNewline();
        }
        exactSource(loc, cb) {
          this._catchUp("start", loc);
          this._buf.exactSource(loc, cb);
        }
        source(prop, loc) {
          this._catchUp(prop, loc);
          this._buf.source(prop, loc);
        }
        withSource(prop, loc, cb) {
          this._catchUp(prop, loc);
          this._buf.withSource(prop, loc, cb);
        }
        _space() {
          this._queue(32);
        }
        _newline() {
          this._queue(10);
        }
        _append(str, maybeNewline) {
          this._maybeAddParen(str);
          this._maybeIndent(str.charCodeAt(0));
          this._buf.append(str, maybeNewline);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _appendChar(char) {
          this._maybeAddParenChar(char);
          this._maybeIndent(char);
          this._buf.appendChar(char);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _queue(char) {
          this._maybeAddParenChar(char);
          this._maybeIndent(char);
          this._buf.queue(char);
          this._endsWithWord = false;
          this._endsWithInteger = false;
        }
        _maybeIndent(firstChar) {
          if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            this._buf.queueIndentation(this._indentChar, this._getIndent());
          }
        }
        _maybeAddParenChar(char) {
          const parenPushNewlineState = this._parenPushNewlineState;
          if (!parenPushNewlineState)
            return;
          if (char === 32) {
            return;
          }
          if (char !== 10) {
            this._parenPushNewlineState = null;
            return;
          }
          this.tokenChar(40);
          this.indent();
          parenPushNewlineState.printed = true;
        }
        _maybeAddParen(str) {
          const parenPushNewlineState = this._parenPushNewlineState;
          if (!parenPushNewlineState)
            return;
          const len = str.length;
          let i;
          for (i = 0; i < len && str.charCodeAt(i) === 32; i++)
            continue;
          if (i === len) {
            return;
          }
          const cha = str.charCodeAt(i);
          if (cha !== 10) {
            if (cha !== 47 || i + 1 === len) {
              this._parenPushNewlineState = null;
              return;
            }
            const chaPost = str.charCodeAt(i + 1);
            if (chaPost === 42) {
              if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {
                return;
              }
            } else if (chaPost !== 47) {
              this._parenPushNewlineState = null;
              return;
            }
          }
          this.tokenChar(40);
          this.indent();
          parenPushNewlineState.printed = true;
        }
        _catchUp(prop, loc) {
          if (!this.format.retainLines)
            return;
          const pos = loc ? loc[prop] : null;
          if ((pos == null ? void 0 : pos.line) != null) {
            const count = pos.line - this._buf.getCurrentLine();
            for (let i = 0; i < count; i++) {
              this._newline();
            }
          }
        }
        _getIndent() {
          return this._indentRepeat * this._indent;
        }
        printTerminatorless(node, parent, isLabel) {
          if (isLabel) {
            this._noLineTerminator = true;
            this.print(node, parent);
            this._noLineTerminator = false;
          } else {
            const terminatorState = {
              printed: false
            };
            this._parenPushNewlineState = terminatorState;
            this.print(node, parent);
            if (terminatorState.printed) {
              this.dedent();
              this.newline();
              this.tokenChar(41);
            }
          }
        }
        print(node, parent, noLineTerminator) {
          if (!node)
            return;
          const nodeType = node.type;
          const format = this.format;
          const oldConcise = format.concise;
          if (node._compact) {
            format.concise = true;
          }
          const printMethod = this[nodeType];
          if (printMethod === void 0) {
            throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
          }
          this._printStack.push(node);
          const oldInAux = this._insideAux;
          this._insideAux = node.loc == void 0;
          this._maybeAddAuxComment(this._insideAux && !oldInAux);
          let shouldPrintParens;
          if (format.retainFunctionParens && nodeType === "FunctionExpression" && node.extra && node.extra.parenthesized) {
            shouldPrintParens = true;
          } else {
            shouldPrintParens = needsParens(node, parent, this._printStack);
          }
          if (shouldPrintParens)
            this.tokenChar(40);
          this._printLeadingComments(node);
          const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
          this.withSource("start", loc, printMethod.bind(this, node, parent));
          if (noLineTerminator && !this._noLineTerminator) {
            this._noLineTerminator = true;
            this._printTrailingComments(node);
            this._noLineTerminator = false;
          } else {
            this._printTrailingComments(node);
          }
          if (shouldPrintParens)
            this.tokenChar(41);
          this._printStack.pop();
          format.concise = oldConcise;
          this._insideAux = oldInAux;
        }
        _maybeAddAuxComment(enteredPositionlessNode) {
          if (enteredPositionlessNode)
            this._printAuxBeforeComment();
          if (!this._insideAux)
            this._printAuxAfterComment();
        }
        _printAuxBeforeComment() {
          if (this._printAuxAfterOnNextUserNode)
            return;
          this._printAuxAfterOnNextUserNode = true;
          const comment = this.format.auxiliaryCommentBefore;
          if (comment) {
            this._printComment({
              type: "CommentBlock",
              value: comment
            });
          }
        }
        _printAuxAfterComment() {
          if (!this._printAuxAfterOnNextUserNode)
            return;
          this._printAuxAfterOnNextUserNode = false;
          const comment = this.format.auxiliaryCommentAfter;
          if (comment) {
            this._printComment({
              type: "CommentBlock",
              value: comment
            });
          }
        }
        getPossibleRaw(node) {
          const extra = node.extra;
          if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
            return extra.raw;
          }
        }
        printJoin(nodes, parent, opts = {}) {
          if (!(nodes != null && nodes.length))
            return;
          if (opts.indent)
            this.indent();
          const newlineOpts = {
            addNewlines: opts.addNewlines
          };
          const len = nodes.length;
          for (let i = 0; i < len; i++) {
            const node = nodes[i];
            if (!node)
              continue;
            if (opts.statement)
              this._printNewline(true, node, parent, newlineOpts);
            this.print(node, parent);
            if (opts.iterator) {
              opts.iterator(node, i);
            }
            if (opts.separator && i < len - 1) {
              opts.separator.call(this);
            }
            if (opts.statement)
              this._printNewline(false, node, parent, newlineOpts);
          }
          if (opts.indent)
            this.dedent();
        }
        printAndIndentOnComments(node, parent) {
          const indent = node.leadingComments && node.leadingComments.length > 0;
          if (indent)
            this.indent();
          this.print(node, parent);
          if (indent)
            this.dedent();
        }
        printBlock(parent) {
          const node = parent.body;
          if (node.type !== "EmptyStatement") {
            this.space();
          }
          this.print(node, parent);
        }
        _printTrailingComments(node) {
          this._printComments(this._getComments(false, node));
        }
        _printLeadingComments(node) {
          this._printComments(this._getComments(true, node), true);
        }
        printInnerComments(node, indent = true) {
          var _node$innerComments;
          if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length))
            return;
          if (indent)
            this.indent();
          this._printComments(node.innerComments);
          if (indent)
            this.dedent();
        }
        printSequence(nodes, parent, opts = {}) {
          opts.statement = true;
          return this.printJoin(nodes, parent, opts);
        }
        printList(items, parent, opts = {}) {
          if (opts.separator == null) {
            opts.separator = commaSeparator;
          }
          return this.printJoin(items, parent, opts);
        }
        _printNewline(leading, node, parent, opts) {
          if (this.format.retainLines || this.format.compact)
            return;
          if (this.format.concise) {
            this.space();
            return;
          }
          let lines = 0;
          if (this._buf.hasContent()) {
            if (!leading)
              lines++;
            if (opts.addNewlines)
              lines += opts.addNewlines(leading, node) || 0;
            const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
            if (needs(node, parent))
              lines++;
          }
          this.newline(Math.min(2, lines));
        }
        _getComments(leading, node) {
          return node && (leading ? node.leadingComments : node.trailingComments) || null;
        }
        _printComment(comment, skipNewLines) {
          if (comment.ignore)
            return;
          if (this._printedComments.has(comment))
            return;
          if (!this.format.shouldPrintComment(comment.value))
            return;
          this._printedComments.add(comment);
          const isBlockComment = comment.type === "CommentBlock";
          const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
          if (printNewLines && this._buf.hasContent())
            this.newline(1);
          const lastCharCode = this.getLastChar();
          if (lastCharCode !== 91 && lastCharCode !== 123) {
            this.space();
          }
          let val;
          let maybeNewline = false;
          if (isBlockComment) {
            val = `/*${comment.value}*/`;
            if (this.format.indent.adjustMultilineComment) {
              var _comment$loc;
              const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
              if (offset) {
                const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
                val = val.replace(newlineRegex, "\n");
              }
              const indentSize = Math.max(this._getIndent(), this.format.retainLines ? 0 : this._buf.getCurrentColumn());
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
              maybeNewline = true;
            }
          } else if (!this._noLineTerminator) {
            val = `//${comment.value}
`;
            maybeNewline = true;
          } else {
            val = `/*${comment.value}*/`;
          }
          if (this.endsWith(47))
            this._space();
          this.withSource("start", comment.loc, this._append.bind(this, val, maybeNewline));
          if (printNewLines)
            this.newline(1);
        }
        _printComments(comments, inlinePureAnnotation) {
          if (!(comments != null && comments.length))
            return;
          if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
            this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));
          } else {
            for (const comment of comments) {
              this._printComment(comment);
            }
          }
        }
        printAssertions(node) {
          var _node$assertions;
          if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
            this.space();
            this.word("assert");
            this.space();
            this.tokenChar(123);
            this.space();
            this.printList(node.assertions, node);
            this.space();
            this.tokenChar(125);
          }
        }
      };
      Object.assign(Printer.prototype, generatorFunctions);
      {
        Printer.prototype.Noop = function Noop() {
        };
      }
      var _default = Printer;
      exports.default = _default;
      function commaSeparator() {
        this.tokenChar(44);
        this.space();
      }
    }
  });

  // ../node_modules/@babel/generator/lib/index.js
  var require_lib4 = __commonJS({
    "../node_modules/@babel/generator/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CodeGenerator = void 0;
      exports.default = generate2;
      var _sourceMap = require_source_map();
      var _printer = require_printer();
      var Generator = class extends _printer.default {
        constructor(ast, opts = {}, code) {
          const format = normalizeOptions(code, opts);
          const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
          super(format, map);
          this.ast = void 0;
          this.ast = ast;
        }
        generate() {
          return super.generate(this.ast);
        }
      };
      function normalizeOptions(code, opts) {
        const format = {
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          shouldPrintComment: opts.shouldPrintComment,
          retainLines: opts.retainLines,
          retainFunctionParens: opts.retainFunctionParens,
          comments: opts.comments == null || opts.comments,
          compact: opts.compact,
          minified: opts.minified,
          concise: opts.concise,
          indent: {
            adjustMultilineComment: true,
            style: "  ",
            base: 0
          },
          jsescOption: Object.assign({
            quotes: "double",
            wrap: true,
            minimal: false
          }, opts.jsescOption),
          recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
          topicToken: opts.topicToken
        };
        {
          format.decoratorsBeforeExport = !!opts.decoratorsBeforeExport;
          format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
        }
        if (format.minified) {
          format.compact = true;
          format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
        } else {
          format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
        }
        if (format.compact === "auto") {
          format.compact = code.length > 5e5;
          if (format.compact) {
            console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
          }
        }
        if (format.compact) {
          format.indent.adjustMultilineComment = false;
        }
        return format;
      }
      var CodeGenerator = class {
        constructor(ast, opts, code) {
          this._generator = void 0;
          this._generator = new Generator(ast, opts, code);
        }
        generate() {
          return this._generator.generate();
        }
      };
      exports.CodeGenerator = CodeGenerator;
      function generate2(ast, opts, code) {
        const gen = new Generator(ast, opts, code);
        return gen.generate();
      }
    }
  });

  // ../node_modules/@babel/parser/lib/index.js
  var require_lib5 = __commonJS({
    "../node_modules/@babel/parser/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", { value: true });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var Position = class {
        constructor(line, col, index) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index;
        }
      };
      var SourceLocation = class {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      };
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index
        } = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      var ParseErrorCode = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      };
      var reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce((object, key) => object[key], this);
        },
        set(value) {
          keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);
        }
      });
      var instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties));
      var ModuleErrors = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        }
      };
      var NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      var toNodeDescription = ({
        type,
        prefix: prefix2
      }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
      var StandardErrors = {
        AccessorIsGenerator: ({
          kind
        }) => `A ${kind}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accesor must not have any formal parameters.",
        BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({
          kind
        }) => `Missing initializer in ${kind} declaration.`,
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({
          type
        }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({
          type
        }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: ({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({
          radix
        }) => `Expected number in radix ${radix}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`,
        InvalidIdentifier: ({
          identifierName
        }) => `Invalid identifier ${identifierName}.`,
        InvalidLhs: ({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidLhsBinding: ({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({
          unexpected
        }) => `Unexpected character '${unexpected}'.`,
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({
          identifierName
        }) => `Private name #${identifierName} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({
          labelName
        }) => `Label '${labelName}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingOneOfPlugins: ({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
        ModuleExportUndefined: ({
          localName
        }) => `Export '${localName}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
        PrivateNameRedeclaration: ({
          identifierName
        }) => `Duplicate private name #${identifierName}.`,
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({
          keyword
        }) => `Unexpected keyword '${keyword}'.`,
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        VarRedeclaration: ({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      };
      var StrictModeErrors = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`,
        StrictEvalArgumentsBinding: ({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`,
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode."
      };
      var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = {
        PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
        PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({
          type
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
      };
      var _excluded$1 = ["toMessage"];
      var _excluded2$1 = ["message"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
        }
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(argument)) {
          const template2 = argument[reasonCode];
          const _ref2 = typeof template2 === "string" ? {
            message: () => template2
          } : typeof template2 === "function" ? {
            message: template2
          } : template2, {
            message
          } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          const toMessage = typeof message === "string" ? () => message : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        }
        return ParseErrorConstructors;
      }
      var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      var {
        defineProperty
      } = Object;
      var toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
      function toESTreeLocation(node) {
        node.loc.start && toUnenumerable(node.loc.start, "index");
        node.loc.end && toUnenumerable(node.loc.end, "index");
        return node;
      }
      var estree = (superClass) => class ESTreeParserMixin extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex = null;
          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {
          }
          const node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern,
            flags
          };
          return node;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const directiveLiteral = directive.value;
          const stmt = this.startNodeAt(directive.start, directive.loc.start);
          const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.extra.expressionValue;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
        }
        initFunction(node, isAsync) {
          super.initFunction(node, isAsync);
          node.expression = false;
        }
        checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            super.checkDeclaration(node);
          }
        }
        getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
          const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(method);
        }
        parsePrivateName() {
          const node = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
          const name = super.getPrivateNameSV(node);
          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
        isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node);
            }
          }
          return node.name;
        }
        parseLiteral(value, type) {
          const node = super.parseLiteral(value, type);
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          super.parseFunctionBody(node, allowExpression, isMethod);
          node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }
          return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node) {
            node.type = "Property";
            if (node.kind === "method") {
              node.kind = "init";
            }
            node.shorthand = false;
          }
          return node;
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }
          return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
          if (node != null && this.isObjectProperty(node)) {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
        }
        finishCallExpression(unfinished, optional) {
          const node = super.finishCallExpression(unfinished, optional);
          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node.arguments;
            delete node.callee;
          }
          return node;
        }
        toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node);
        }
        parseExport(unfinished) {
          const node = super.parseExport(unfinished);
          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }
              break;
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }
          return node;
        }
        hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }
          return super.hasPropertyAsPrivateName(node);
        }
        isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
        isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, start, startLoc) {
          super.resetStartLocation(node, start, startLoc);
          toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node, endLoc);
          toESTreeLocation(node);
        }
      };
      var TokContext = class {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      };
      var types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types.template = new TokContext("`", true);
      }
      var beforeExpr = true;
      var startsExpr = true;
      var isLoop = true;
      var isAssign = true;
      var prefix = true;
      var postfix = true;
      var ExportedTokenType = class {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      };
      var keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name, options = {}) {
        options.keyword = name;
        const token = createToken(name, options);
        keywords$1.set(name, token);
        return token;
      }
      function createBinop(name, binop) {
        return createToken(name, {
          beforeExpr,
          binop
        });
      }
      var tokenTypeCounter = -1;
      var tokenTypes = [];
      var tokenLabels = [];
      var tokenBinops = [];
      var tokenBeforeExprs = [];
      var tokenStartsExprs = [];
      var tokenPrefixes = [];
      function createToken(name, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name);
        tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
        tokenTypes.push(new ExportedTokenType(name, options));
        return tokenTypeCounter;
      }
      function createKeywordLike(name, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name, tokenTypeCounter);
        tokenLabels.push(name);
        tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
        tokenTypes.push(new ExportedTokenType("name", options));
        return tokenTypeCounter;
      }
      var tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 128;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 128;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 132;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 125 && token <= 127;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 117 && token <= 119;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 120 && token <= 126;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      {
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        };
        tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types.brace);
        };
        tokenTypes[22].updateContext = (context) => {
          if (context[context.length - 1] === types.template) {
            context.pop();
          } else {
            context.push(types.template);
          }
        };
        tokenTypes[138].updateContext = (context) => {
          context.push(types.j_expr, types.j_oTag);
        };
      }
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code)
            return false;
          pos += set[i + 1];
          if (pos >= code)
            return true;
        }
        return false;
      }
      function isIdentifierStart(code) {
        if (code < 65)
          return code === 36;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code) {
        if (code < 48)
          return code === 36;
        if (code < 58)
          return true;
        if (code < 65)
          return false;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword(word) {
        return keywords.has(word);
      }
      function isIteratorStart(current, next, next2) {
        return current === 64 && next === 64 && isIdentifierStart(next2);
      }
      var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word) {
        return reservedWordLikeSet.has(word);
      }
      var SCOPE_OTHER = 0;
      var SCOPE_PROGRAM = 1;
      var SCOPE_FUNCTION = 2;
      var SCOPE_ARROW = 4;
      var SCOPE_SIMPLE_CATCH = 8;
      var SCOPE_SUPER = 16;
      var SCOPE_DIRECT_SUPER = 32;
      var SCOPE_CLASS = 64;
      var SCOPE_STATIC_BLOCK = 128;
      var SCOPE_TS_MODULE = 256;
      var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
      var BIND_KIND_VALUE = 1;
      var BIND_KIND_TYPE = 2;
      var BIND_SCOPE_VAR = 4;
      var BIND_SCOPE_LEXICAL = 8;
      var BIND_SCOPE_FUNCTION = 16;
      var BIND_FLAGS_NONE = 64;
      var BIND_FLAGS_CLASS = 128;
      var BIND_FLAGS_TS_ENUM = 256;
      var BIND_FLAGS_TS_CONST_ENUM = 512;
      var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
      var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
      var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
      var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
      var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
      var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
      var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
      var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
      var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
      var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      var CLASS_ELEMENT_FLAG_STATIC = 4;
      var CLASS_ELEMENT_KIND_GETTER = 2;
      var CLASS_ELEMENT_KIND_SETTER = 1;
      var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
      var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_OTHER = 0;
      var BaseParser = class {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin, name) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
        }
      };
      function setTrailingComments(node, comments) {
        if (node.trailingComments === void 0) {
          node.trailingComments = comments;
        } else {
          node.trailingComments.unshift(...comments);
        }
      }
      function setLeadingComments(node, comments) {
        if (node.leadingComments === void 0) {
          node.leadingComments = comments;
        } else {
          node.leadingComments.unshift(...comments);
        }
      }
      function setInnerComments(node, comments) {
        if (node.innerComments === void 0) {
          node.innerComments = comments;
        } else {
          node.innerComments.unshift(...comments);
        }
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null;
        let i = elements.length;
        while (lastElement === null && i > 0) {
          lastElement = elements[--i];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      var CommentsParser = class extends BaseParser {
        addComment(comment) {
          if (this.filename)
            comment.loc.filename = this.filename;
          this.state.comments.push(comment);
        }
        processComment(node) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          const lastCommentWS = commentStack[i];
          if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
          }
          const {
            start: nodeStart
          } = node;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
              commentWS.containingNode = node;
              this.finalizeComment(commentWS);
              commentStack.splice(i, 1);
            } else {
              if (commentEnd === nodeStart) {
                commentWS.trailingNode = node;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments);
            }
          } else {
            const {
              containingNode: node,
              start: commentStart
            } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) {
              switch (node.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node, node.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node, node.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node, node.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node, comments);
                }
              }
            } else {
              setInnerComments(node, comments);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
          }
        }
        takeSurroundingComments(node, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) {
              commentWS.leadingNode = node;
            } else if (commentEnd === start) {
              commentWS.trailingNode = node;
            } else if (commentEnd < start) {
              break;
            }
          }
        }
      };
      var lineBreak = /\r\n?|[\n\u2028\u2029]/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        switch (code) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
      var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace2(code) {
        switch (code) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      var State2 = class {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.decoratorStack = [[]];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 135;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State2();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      };
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let containsInvalid = false;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            let escaped;
            ({
              ch: escaped,
              pos,
              lineStart,
              curLine
            } = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors));
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          containsInvalid,
          lineStart,
          curLine
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code;
            ({
              code,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            let code;
            ({
              code,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCodePoint(code));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = input.charCodeAt(pos);
          let val;
          if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code;
        if (ch === 123) {
          ++pos;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code,
          pos
        };
      }
      var _excluded = ["at"];
      var _excluded2 = ["at"];
      function buildPosition(pos, lineStart, curLine) {
        return new Position(curLine, pos - lineStart, pos);
      }
      var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      var Token = class {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      };
      var Tokenizer2 = class extends CommentsParser {
        constructor(options, input) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix) => {
              if (!this.options.errorRecovery)
                return false;
              this.raise(Errors.InvalidDigit, {
                at: buildPosition(pos, lineStart, curLine),
                radix
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
          };
          this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
          });
          this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: buildPosition(pos, lineStart, curLine)
              });
            },
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, {
                at: buildPosition(pos - 1, lineStart, curLine)
              });
            }
          });
          this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: buildPosition(pos, lineStart, curLine)
              });
            }
          });
          this.state = new State2();
          this.state.init(options);
          this.input = input;
          this.length = input.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type) {
          if (this.match(type)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
              at
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(135);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf("*/", start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + 2;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead)
            return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead)
            return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments = [];
          loop:
            while (this.state.pos < this.length) {
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const comment = this.skipBlockComment();
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    case 47: {
                      const comment = this.skipLineComment(2);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (isWhitespace2(ch)) {
                    ++this.state.pos;
                  } else if (ch === 45 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                      const comment = this.skipLineComment(3);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else if (ch === 60 && !this.inModule) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                      const comment = this.skipLineComment(4);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else {
                    break loop;
                  }
              }
            }
          if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
              start: spaceStart,
              end,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type) {
          this.state.type = type;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
              throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1(next));
          } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
          }
          if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2)
            return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33)
            return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code) {
          let type = code === 42 ? 55 : 54;
          let width = 1;
          let next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
          }
          if (next === 61 && !this.state.inType) {
            width++;
            type = code === 37 ? 33 : 30;
          }
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code === 124) {
            if (next === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              throw this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            this.finishOp(34, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          const next2 = this.input.charCodeAt(this.state.pos + 2);
          if (next === 63) {
            if (next2 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code) {
          switch (code) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(code)) {
                this.readWord(code);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                this.expectPlugin("regexpUnicodeSets", nextPos());
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(133, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen = false, allowNumSeparator = true) {
          const {
            n,
            pos
          } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt);
          this.state.pos = pos;
          return n;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next = this.input.charCodeAt(this.state.pos);
          if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(131, str);
            return;
          }
          this.finishToken(130, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if (next === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(131, str);
            return;
          }
          if (isDecimal) {
            this.finishToken(132, str);
            return;
          }
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(130, val);
        }
        readCodePoint(throwOnInvalid) {
          const {
            code,
            pos
          } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
          this.state.pos = pos;
          return code;
        }
        readString(quote) {
          const {
            str,
            pos,
            curLine,
            lineStart
          } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          this.finishToken(129, str);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const opening = this.input[this.state.pos];
          const {
            str,
            containsInvalid,
            pos,
            curLine,
            lineStart
          } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, containsInvalid ? null : opening + str + "`");
          } else {
            this.state.pos++;
            this.finishToken(25, containsInvalid ? null : opening + str + "${");
          }
        }
        recordStrictModeErrors(toParseError, {
          at
        }) {
          const index = at.index;
          if (this.state.strict && !this.state.strictErrors.has(index)) {
            this.raise(toParseError, {
              at
            });
          } else {
            this.state.strictErrors.set(index, [toParseError, at]);
          }
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode);
          const type = keywords$1.get(word);
          if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
          } else {
            this.finishToken(128, word);
          }
        }
        checkKeywordEscapes() {
          const {
            type
          } = this.state;
          if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at instanceof Position ? at : at.loc.start;
          const error = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery)
            throw error;
          if (!this.isLookahead)
            this.state.errors.push(error);
          return error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at instanceof Position ? at : at.loc.start;
          const pos = loc.index;
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.loc.index === pos) {
              return errors[i] = toParseError({
                loc,
                details
              });
            }
            if (error.loc.index < pos)
              break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
        errorBuilder(error) {
          return (pos, lineStart, curLine) => {
            this.raise(error, {
              at: buildPosition(pos, lineStart, curLine)
            });
          };
        }
      };
      var Scope = class {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      };
      var ScopeHandler = class {
        constructor(parser, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser;
          this.inModule = inModule;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
        }
        declareName(name, bindingType, loc) {
          let scope = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope.functions.add(name);
            } else {
              scope.lexical.add(name);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope, name);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
              scope = this.scopeStack[i];
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              scope.var.add(name);
              this.maybeExportDefined(scope, name);
              if (scope.flags & SCOPE_VAR)
                break;
            }
          }
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        maybeExportDefined(scope, name) {
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        checkRedeclarationInScope(scope, name, bindingType, loc) {
          if (this.isRedeclaredInScope(scope, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE))
            return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
          }
          return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
        }
        checkLocalExport(id) {
          const {
            name
          } = id;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      };
      var FlowScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      };
      var FlowScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
            scope.declareFunctions.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (super.isRedeclaredInScope(scope, name, bindingType))
            return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
          }
          return false;
        }
        checkLocalExport(id) {
          if (!this.scopeStack[0].declareFunctions.has(id.name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var ClassScope = class {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      };
      var ClassScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name)) {
                current.undefinedPrivateNames.set(name, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name
              });
            }
          }
        }
        declarePrivateName(name, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined)
                loneAccessors.delete(name);
            } else if (!redefined) {
              loneAccessors.set(name, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
          privateNames.add(name);
          undefinedPrivateNames.delete(name);
        }
        usePrivateName(name, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name))
              return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name
            });
          }
        }
      };
      var kExpression = 0;
      var kMaybeArrowParameterDeclaration = 1;
      var kMaybeAsyncArrowParameterDeclaration = 2;
      var kParameterDeclaration = 3;
      var ExpressionScope = class {
        constructor(type = kExpression) {
          this.type = void 0;
          this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      };
      var ArrowHeadParsingScope = class extends ExpressionScope {
        constructor(type) {
          super(type);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at
        }) {
          const index = at.index;
          this.declarationErrors.set(index, [ParsingErrorClass, at]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      };
      var ExpressionScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node
        }) {
          const origin = {
            at: node.loc.start
          };
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (!scope.isCertainlyParameterDeclaration()) {
            if (scope.canBeArrowParameterDeclaration()) {
              scope.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope = stack[--i];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParemeterBindingError(error, {
          at: node
        }) {
          const {
            stack
          } = this;
          const scope = stack[stack.length - 1];
          const origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
          } else if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(error, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at
        }) {
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
              scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
              });
            }
            scope = stack[--i];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration())
            return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i = stack.length - 2;
            let scope = stack[i];
            while (scope.canBeArrowParameterDeclaration()) {
              scope.clearDeclarationError(loc.index);
              scope = stack[--i];
            }
          });
        }
      };
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      var PARAM = 0;
      var PARAM_YIELD = 1;
      var PARAM_AWAIT = 2;
      var PARAM_RETURN = 4;
      var PARAM_IN = 8;
      var ProductionParameterHandler = class {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      };
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      var UtilParser = class extends Tokenizer2 {
        addExtra(node, key, value, enumerable = true) {
          if (!node)
            return;
          const extra = node.extra = node.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name) {
          const nameEnd = nameStart + name.length;
          if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn((node2 = null) => {
              abortSignal.node = node2;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) {
              return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors)
            return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return node.type === "PrivateName";
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
        }
        isOptionalChain(node) {
          return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
        }
        isObjectProperty(node) {
          return node.type === "ObjectProperty";
        }
        isObjectMethod(node) {
          return node.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      };
      var ExpressionErrors = class {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      };
      var Node2 = class {
        constructor(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser != null && parser.options.ranges)
            this.range = [pos, 0];
          if (parser != null && parser.filename)
            this.loc.filename = parser.filename;
        }
      };
      var NodePrototype = Node2.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node2();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node) {
        return cloneIdentifier(node);
      }
      function cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra,
          name
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.name = name;
        if (type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        if (type === "Placeholder") {
          return clonePlaceholder(node);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        if (node.raw !== void 0) {
          cloned.raw = node.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node.value;
        return cloned;
      }
      var NodeUtils = class extends UtilParser {
        startNode() {
          return new Node2(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(pos, loc) {
          return new Node2(this, pos, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.start, type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          node.type = type;
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
          if (this.options.attachComment)
            this.processComment(node);
          return node;
        }
        resetStartLocation(node, start, startLoc) {
          node.start = start;
          node.loc.start = startLoc;
          if (this.options.ranges)
            node.range[0] = start;
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
        }
      };
      var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      var FlowErrors = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`,
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
        EnumDuplicateMemberName: ({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
        EnumInconsistentMemberValues: ({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
        EnumInvalidMemberName: ({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
        EnumNumberMemberNotInitialized: ({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign({
          message: "A binding pattern parameter cannot be optional in an implementation signature."
        }, {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`,
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      });
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node) {
        return node.importKind === "type" || node.importKind === "typeof";
      }
      function isMaybeDefaultImport(type) {
        return tokenIsKeywordOrIdentifier(type) && type !== 97;
      }
      var exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list, test) {
        const list1 = [];
        const list2 = [];
        for (let i = 0; i < list.length; i++) {
          (test(list[i], i, list) ? list1 : list2).push(list[i]);
        }
        return [list1, list2];
      }
      var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow = (superClass) => class FlowParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
          if (type !== 129 && type !== 13 && type !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          return super.finishToken(type, val);
        }
        addComment(comment) {
          if (this.flowPragma === void 0) {
            const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches)
              ;
            else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          return super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
        flowParsePredicate() {
          const node = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(107);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node.value = super.parseExpression();
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type, predicate];
        }
        flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
          this.next();
          const id = node.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(123)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(126)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(125)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
        flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(129)) {
            node.id = super.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }
          const bodyNode = node.body = this.startNode();
          const body = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(126) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              super.parseImport(bodyNode2);
            } else {
              this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }
            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
              node = this.parseExport(node);
              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }
              node.type = "Declare" + node.type;
              return node;
            }
          }
          throw this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(108);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
          this.next();
          const finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
        flowParseDeclareOpaqueType(node) {
          this.next();
          const finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
        flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass = false) {
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.extends = [];
          node.implements = [];
          node.mixins = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (this.isContextual(114)) {
            this.next();
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.isContextual(110)) {
            this.next();
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word))
            return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
          this.expectContextual(126);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.supertype = null;
          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }
          node.impltype = null;
          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node = this.startNode();
          node.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node = this.startNode();
          this.expectContextual(125);
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(130) || this.match(129) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;
          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }
          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;
            if (this.eat(17)) {
              node.optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node.this = null;
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node.this = this.flowParseFunctionTypeParam(true);
            node.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
          const valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node = this.startNode();
            if (allowProto && this.isContextual(115)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
              if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value.this
                });
              }
            } else {
              if (kind !== "init")
                this.unexpected();
              node.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }
            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property) {
          const paramCount = property.kind === "get" ? 0 : 1;
          const length = property.value.params.length + (property.value.rest ? 1 : 0);
          if (property.value.this) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }
          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          let node = id || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }
          return node;
        }
        flowParseGenericType(startPos, startLoc, id) {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node = this.startNode();
          node.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3))
              break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name = null;
          let optional = false;
          let typeAnnotation = null;
          const node = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }
            name = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
          const node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
        flowParsePrimaryType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.startNode();
          let tmp;
          let type;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;
            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(130)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }
                if (this.match(131)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();
            case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(125)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
              }
          }
          throw this.unexpected();
        }
        flowParsePostfixType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let type = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node = this.startNodeAt(startPos, startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }
          return type;
        }
        flowParsePrefixType() {
          const node = this.startNode();
          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.this = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node = this.startNode();
          this.eat(45);
          const type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];
          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node = this.startNode();
          this.eat(43);
          const type = this.flowParseIntersectionType();
          node.types = [type];
          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 128 && this.state.value === "_") {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            return this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          }
          return super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatement(context, topLevel) {
          if (this.state.strict && this.isContextual(125)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          const stmt = super.parseStatement(context, topLevel);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.match(17))
            return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node = this.startNodeAt(startPos, startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
          const stack = [node];
          const arrows = [];
          while (stack.length !== 0) {
            const node2 = stack.pop();
            if (node2.type === "ArrowFunctionExpression") {
              if (node2.typeParameters || !node2.returnType) {
                this.finishArrowValidation(node2);
              } else {
                arrows.push(node2);
              }
              stack.push(node2.body);
            } else if (node2.type === "ConditionalExpression") {
              stack.push(node2.consequent);
              stack.push(node2.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node2) => this.finishArrowValidation(node2));
            return [arrows, []];
          }
          return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
          var _node$extra;
          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse3) {
          let result;
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse3();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse3();
          }
          return result;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        }
        assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node);
        }
        parseExport(node) {
          const decl = super.parseExport(node);
          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }
          return decl;
        }
        parseExportDeclaration(node) {
          if (this.isContextual(126)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);
              super.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(127)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(125)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            node.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node);
          }
        }
        eatExportStar(node) {
          if (super.eatExportStar(node))
            return true;
          if (this.isContextual(126) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
          super.parseClassId(node, isStatement, optionalId);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(121)) {
            if (super.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
          const word = super.readWord1();
          const fullWord = "@@" + word;
          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(128, fullWord);
        }
        getTokenFromCode(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 123 && next === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(code === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code === 63) {
            if (next === 46) {
              return this.finishOp(18, 2);
            }
            return this.finishOp(17, 1);
          } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return super.getTokenFromCode(code);
          }
        }
        isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
          super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i = 0; i < exprList.length; i++) {
            var _expr$extra;
            const expr = exprList[i];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }
          return node;
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
          return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method.params && isConstructor) {
            const params = method.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            const params = method.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(110)) {
            this.next();
            const implemented = node.implements = [];
            do {
              const node2 = this.startNode();
              node2.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              implemented.push(this.finishNode(node2, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method) {
          super.checkGetterSetterParams(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10))
              this.unexpected();
          }
          const result = super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }
          return result;
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return super.shouldParseDefaultImport(node);
          }
          return isMaybeDefaultImport(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          let kind = null;
          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(126)) {
            kind = "type";
          }
          if (kind) {
            const lh = this.lookahead();
            const {
              type
            } = lh;
            if (kind === "type" && type === 55) {
              this.unexpected(null, lh.type);
            }
            if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
              this.next();
              node.importKind = kind;
            }
          }
          return super.maybeParseDefaultImportSpecifier(node);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node, allowModifiers) {
          const kind = node.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
                abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression")
                abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(19))
                this.unexpected();
              return typeNode;
            });
            if (result.thrown)
              return null;
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            super.setArrowFunctionParameters(node, params);
          }
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }
          for (let i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
            }
          }
          return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = super.parseCallExpressionArguments(11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
            if (result.node && !result.error)
              return result.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result.node) {
              this.state = result.failState;
              return result.node;
            }
            throw arrow.error || result.error;
          }
          return super.parseSubscripts(base, startPos, startLoc, noCalls);
        }
        parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const result = this.tryParse(() => {
              node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node.arguments = super.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember) {
                node.optional = false;
              }
              return this.finishCallExpression(node, subscriptState.optionalChainMember);
            });
            if (result.node) {
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
          super.parseNewCallee(node);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node))
            return;
          return super.parseArrowExpression(node, void 0, true);
        }
        readToken_mult_modulo(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code);
        }
        parseTopLevel(file, program) {
          const fileNode = super.parseTopLevel(file, program);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            const commentSkip = this.skipFlowComment();
            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }
            return;
          }
          if (this.state.hasFlowComment) {
            const end = this.input.indexOf("*-/", this.state.pos + 2);
            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }
            this.state.pos = end + 2 + 3;
            return;
          }
          return super.skipBlockComment();
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 130: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 129: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id = this.parseIdentifier(true);
          const init = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id,
            init
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          const {
            explicitType
          } = context;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id,
              init
            } = this.flowEnumMemberRaw();
            const memberName = id.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id;
            switch (init.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101))
            return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node, id) {
          const enumName = id.name;
          const nameLoc = id.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");
            default: {
              const empty = () => {
                node.members = [];
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node) {
          const id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next = this.nextTokenStart();
          if (this.input.charCodeAt(next) === 60) {
            const afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      };
      var entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
      var JsxErrors = ParseErrorEnum`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      });
      function isFragment(object) {
        return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object) {
        if (object.type === "JSXIdentifier") {
          return object.name;
        }
        if (object.type === "JSXNamespacedName") {
          return object.namespace.name + ":" + object.name.name;
        }
        if (object.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        }
        throw new Error("Node had unexpected type: " + object.type);
      }
      var jsx = (superClass) => class JSXParserMixin extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(138);
                  }
                  return super.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(137, out);
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(129, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(136, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node = this.startNode();
          if (this.match(136)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const name = this.jsxParseIdentifier();
          if (!this.eat(14))
            return name;
          const node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let node = this.jsxParseNamespacedName();
          if (node.type === "JSXNamespacedName") {
            return node;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsxParseAttributeValue() {
          let node;
          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);
              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }
              return node;
            case 138:
            case 129:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node = this.startNode();
          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }
          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
          const attributes = [];
          while (!this.match(56) && !this.match(139)) {
            attributes.push(this.jsxParseAttribute());
          }
          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(139);
          return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXClosingFragment");
          }
          node.name = this.jsxParseElementName();
          this.expect(139);
          return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          const children2 = [];
          const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.state.type) {
                  case 138:
                    startPos = this.state.start;
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children2.push(this.jsxParseElementAt(startPos, startLoc));
                    break;
                  case 137:
                    children2.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const node2 = this.startNode();
                    this.setContext(types.brace);
                    this.next();
                    if (this.match(21)) {
                      children2.push(this.jsxParseSpreadChild(node2));
                    } else {
                      children2.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                    }
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }
          node.children = children2;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
        setContext(newContext) {
          const {
            context
          } = this.state;
          context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(137)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(138)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace)
            super.skipSpace();
        }
        getTokenFromCode(code) {
          const context = this.curContext();
          if (context === types.j_expr) {
            return this.jsxReadToken();
          }
          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }
            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(139);
            }
            if ((code === 34 || code === 39) && context === types.j_oTag) {
              return this.jsxReadString(code);
            }
          }
          if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(138);
          }
          return super.getTokenFromCode(code);
        }
        updateContext(prevType) {
          const {
            context,
            type
          } = this.state;
          if (type === 56 && prevType === 138) {
            context.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 138) {
            context.push(types.j_oTag);
          } else if (type === 139) {
            const out = context[context.length - 1];
            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      };
      var TypeScriptScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      };
      var TypeScriptScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new TypeScriptScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name);
            scope.exportOnlyBindings.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              this.maybeExportDefined(scope, name);
            }
            scope.types.add(name);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM)
            scope.enums.add(name);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
            scope.constEnums.add(name);
          if (bindingType & BIND_FLAGS_CLASS)
            scope.classes.add(name);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (scope.enums.has(name)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope.constEnums.has(name);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
            if (scope.lexical.has(name)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
            return true;
          }
          return super.isRedeclaredInScope(scope, name, bindingType);
        }
        checkLocalExport(id) {
          const topLevelScope = this.scopeStack[0];
          const {
            name
          } = id;
          if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      function nonNull(x) {
        if (x == null) {
          throw new Error(`Unexpected ${x} value.`);
        }
        return x;
      }
      function assert(x) {
        if (!x) {
          throw new Error("Assert fail");
        }
      }
      var TSErrors = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        CannotFindName: ({
          name
        }) => `Cannot find name '${name}'.`,
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({
          modifier
        }) => `Accessibility modifier already seen.`,
        DuplicateModifier: ({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`,
        EmptyHeritageClauseType: ({
          token
        }) => `'${token}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        IncompatibleModifiers: ({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({
          type
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
      });
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          modified,
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier)
              break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(kind, parseElement) {
          const result = [];
          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }
          return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          const result = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement();
            if (element == null) {
              return void 0;
            }
            result.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result;
        }
        tsParseImportType() {
          const node = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(129)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node.argument = super.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node = this.startNode();
          node.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
          const node = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeQuery");
        }
        tsParseInOutModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        tsParseNoneModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
        tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
          const node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node.default = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node = this.startNode();
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75)
            return null;
          this.next();
          const typeReference = this.tsParseTypeReference();
          if (typeReference.typeParameters) {
            this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            });
          }
          return typeReference;
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          return super.parseBindingList(11, 41).map((pattern) => {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }
            return pattern;
          });
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return void 0;
          }
          this.expect(0);
          const id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17))
            node.optional = true;
          const nodeAny = node;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }
            const method = nodeAny;
            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }
            return this.finishNode(method, "TSMethodSignature");
          } else {
            const property = nodeAny;
            if (readonly)
              property.readonly = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type)
              property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }
          if (this.match(77)) {
            const id = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          const idx = this.tsTryParseIndexSignature(node);
          if (idx) {
            return idx;
          }
          super.parsePropertyName(node);
          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
          }
          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
          const node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(118);
          }
          if (this.isContextual(118)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
          } else if (this.eatContextual(118)) {
            node.readonly = true;
          }
          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }
          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
          const node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            const {
              type
            } = elementNode;
            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            let checkType = type;
            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }
            const isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            start: startPos,
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let type = this.tsParseType();
          const optional = this.eat(17);
          const labeled = this.eat(14);
          if (labeled) {
            const labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
            }
            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }
          return type;
        }
        tsParseParenthesizedType() {
          const node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
          const node = this.startNode();
          if (type === "TSConstructorType") {
            node.abstract = !!abstract;
            if (abstract)
              this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
          return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
          const node = this.startNode();
          node.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return super.parseExprAtom();
              default:
                throw this.unexpected();
            }
          })();
          return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType)
            return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 130 && nextToken.type !== 131) {
                  throw this.unexpected();
                }
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type
              } = this.state;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node = this.startNode();
                  this.next();
                  return this.finishNode(node, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type;
              node.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(node, "TSIndexedAccessType");
            }
          }
          return type;
        }
        tsParseTypeOperator() {
          const node = this.startNode();
          const operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }
          return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
        tsParseInferType() {
          const node = this.startNode();
          this.expectContextual(112);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node.types = types2;
          return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              super.parseBindingList(3, 93, true);
              return errors.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t2 = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node);
                thisTypePredicate.asserts = true;
              }
              t2.typeAnnotation = thisTypePredicate;
              return this.finishNode(t2, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t2);
              }
              node.parameterName = this.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
              return this.finishNode(t2, "TSTypeAnnotation");
            }
            const type = this.tsParseTypeAnnotation(false);
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t2, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id = this.parseIdentifier();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
          this.tsInType(() => {
            if (eatColon)
              this.expect(14);
            t2.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t2, "TSTypeAnnotation");
        }
        tsParseType() {
          assert(this.state.inType);
          const type = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }
          const node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node = this.startNode();
            node.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties = {}) {
          if (this.hasFollowingLineBreak())
            return null;
          this.expectContextual(125);
          if (properties.declare)
            node.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause("extends");
          }
          const body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
            this.expect(29);
            if (this.isContextual(111) && this.lookahead().type !== 16) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          return !this.match(token) ? void 0 : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
          return this.tsDoThenParseType(() => this.expect(token));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(cb) {
          return this.tsInType(() => {
            cb();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node = this.startNode();
          node.id = this.match(129) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
          if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties = {}) {
          if (properties.const)
            node.const = true;
          if (properties.declare)
            node.declare = true;
          this.expectContextual(122);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
          node.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(109)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(129)) {
            node.id = super.parseStringLiteral(this.state.value);
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_LEXICAL);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node = this.startNode();
          this.expectContextual(116);
          this.expect(10);
          if (!this.match(129)) {
            throw this.unexpected();
          }
          node.expression = super.parseExprAtom();
          this.expect(11);
          return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
          const state = this.state.clone();
          const res = f();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f) {
          const result = this.tryParse((abort) => f() || abort());
          if (result.aborted || !result.node)
            return void 0;
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        tsTryParse(f) {
          const state = this.state.clone();
          const result = f();
          if (result !== void 0 && result !== false) {
            return result;
          } else {
            this.state = state;
            return void 0;
          }
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let starttype = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            if (starttype === 68) {
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, true);
            }
            if (starttype === 80) {
              nany.declare = true;
              return this.parseClass(nany, true, false);
            }
            if (starttype === 122) {
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }
            if (starttype === 109) {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            }
            if (starttype === 75 || starttype === 74) {
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            }
            if (starttype === 125) {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result)
                return result;
            }
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true);
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
        tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare": {
              const declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
                return declaration;
              }
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
        tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(129)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
          }
        }
        tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak())
              return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          if (!this.match(47)) {
            return void 0;
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startPos, startLoc);
            node.typeParameters = this.tsParseTypeParameters();
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res) {
            return void 0;
          }
          return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return void 0;
          }
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node = this.startNode();
          node.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          }
          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart())
            return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let accessibility;
          let readonly = false;
          let override = false;
          if (allowModifiers !== void 0) {
            const modified = {};
            this.tsParseModifiers({
              modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;
            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startPos, startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility)
              pp.accessibility = accessibility;
            if (readonly)
              pp.readonly = readonly;
            if (override)
              pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });
            if (node.declare) {
              return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(node);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node) => {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments)
                return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result2 = super.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
              if (!noCalls && this.eat(10)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node2.arguments);
                node2.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node2.optional = isOptionalCall;
                }
                return this.finishCallExpression(node2, state.optionalChainMember);
              }
              const tokenType = this.state.type;
              if (tokenType === 48 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node = this.startNodeAt(startPos, startLoc);
              node.expression = base;
              node.typeParameters = typeArguments;
              return this.finishNode(node, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
          var _callee$extra;
          super.parseNewCallee(node);
          const {
            callee
          } = node;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        checkDuplicateExports() {
        }
        parseImport(node) {
          node.importKind = "value";
          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            let ahead = this.lookahead();
            if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }
            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }
          const importNode = super.parseImport(node);
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node) {
          if (this.match(83)) {
            this.next();
            if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(29)) {
            const assign = node;
            assign.expression = super.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(126) && this.lookahead().type === 5) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }
            return super.parseExport(node);
          }
        }
        isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
          }
          if (this.match(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext)
            return declaration;
          for (const {
            id,
            init
          } of declaration.declarations) {
            if (!init)
              continue;
            if (kind !== "const" || !!id.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init
              });
            } else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init
              });
            }
          }
          return declaration;
        }
        parseStatementContent(context, topLevel) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              const: true
            });
          }
          if (this.isContextual(122)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseStatementContent(context, topLevel);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              super.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional)
            methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node, expr) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
          return decl || super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart())
            return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
          }
          const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
          if (!result.node) {
            if (result.error) {
              super.setOptionalParametersError(refExpressionErrors, result.error);
            }
            return expr;
          }
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node;
        }
        parseExportDeclaration(node) {
          if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(121);
          if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier = tokenIsIdentifier(this.state.type);
          const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
          if (!declaration)
            return null;
          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }
          return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(110)) {
            return;
          }
          super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters)
            node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(35)) {
            node.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
        }
        parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node.abstract && this.match(29)) {
            const {
              key
            } = node;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }
          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node);
          return super.parseClassPrivateProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            });
          }
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod")
            return;
          if (node.type === "MethodDefinition" && !node.value.body)
            return;
          super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(110)) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            prop.typeParameters = typeParameters;
          return super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, allowModifiers) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters)
            node.typeParameters = typeParameters;
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          if (!state || state === this.state)
            state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters();
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!typeCast.error)
              return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
            throw typeCast.error;
          throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node) {
          var _node$extra;
          if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return super.parseMaybeUnary(refExpressionErrors, sawUnary);
          }
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19))
                abort();
              return returnType;
            });
            if (result.aborted)
              return;
            if (!result.thrown) {
              if (result.error)
                this.state = result.failState;
              node.returnType = result.node;
            }
          }
          return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }
              this.toAssignable(node.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }
            default:
              super.toAssignable(node, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;
            default:
              super.toAssignable(node, isLHS);
          }
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;
            default:
              super.checkToRestConversion(node, allowPattern);
          }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return super.checkCommaAfterRest(close);
          }
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        getTokenFromCode(code) {
          if (this.state.inType) {
            if (code === 62) {
              return this.finishOp(48, 1);
            }
            if (code === 60) {
              return this.finishOp(47, 1);
            }
          }
          return super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
          const {
            type
          } = this.state;
          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type
          } = this.state;
          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments)
              node.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
          const baseCount = super.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node, isStatement, optionalId) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node.abstract;
          try {
            return super.parseClass(node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node) {
          if (this.match(80)) {
            node.abstract = true;
            return this.parseClass(node, true, false);
          } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
              node.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          if (method.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
            if (hasBody) {
              const {
                key
              } = method;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }
          node.exportKind = "value";
          return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], BIND_LEXICAL);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression")
          return false;
        const {
          computed,
          property
        } = expression;
        if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier")
          return true;
        if (expression.type !== "MemberExpression")
          return false;
        if (expression.computed)
          return false;
        return isUncomputedMemberExpressionChain(expression.object);
      }
      var PlaceholderErrors = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
      });
      var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(140)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(140);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
        finishPlaceholder(node, expectedNode) {
          const isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(140, 2);
          }
          return super.getTokenFromCode(code);
        }
        parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        isLet(context) {
          if (super.isLet(context)) {
            return true;
          }
          if (!this.isContextual(99)) {
            return false;
          }
          if (context)
            return false;
          const nextToken = this.lookahead();
          if (nextToken.type === 140) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder")
            return;
          super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(node, expr);
          }
          if (this.match(14)) {
            const stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = super.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
          const type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(140) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }
          super.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
        parseExport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseExport(node);
          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next = this.nextTokenStart();
            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(node);
        }
        checkExport(node) {
          const {
            specifiers
          } = node;
          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
          }
          super.checkExport(node);
          node.specifiers = specifiers;
        }
        parseImport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseImport(node);
          node.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport)
              this.parseNamedImportSpecifiers(node);
          }
          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name = this.parseIdentifierName(this.state.start);
              const identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p) => {
          if (typeof p === "string") {
            return expectedOptionsIsEmpty && p === expectedName;
          } else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name, option) {
        const plugin = plugins.find((plugin2) => {
          if (Array.isArray(plugin2)) {
            return plugin2[0] === name;
          } else {
            return plugin2 === name;
          }
        });
        if (plugin && Array.isArray(plugin) && plugin.length > 1) {
          return plugin[1][option];
        }
        return null;
      }
      var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport == null) {
            throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
          } else if (typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error.missingPlugins = "doExpressions";
          throw error;
        }
      }
      var mixinPlugins = {
        estree,
        jsx,
        flow,
        typescript,
        v8intrinsic,
        placeholders
      };
      var mixinPluginNames = Object.keys(mixinPlugins);
      var defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true
      };
      function getOptions(opts) {
        const options = {};
        for (const key of Object.keys(defaultOptions)) {
          options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options;
      }
      var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      var unwrapParenthesizedExpression = (node) => {
        return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
      };
      var LValParser = class extends NodeUtils {
        toAssignable(node, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          }
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                var _node$extra2;
                const prop = node.properties[i];
                const isLast = i === last;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node.left.loc.end
                });
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            if (!elt)
              continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last = node.properties.length - 1;
              return node.properties.every((prop, i) => {
                return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node.value);
            case "SpreadElement":
              return this.isAssignable(node.argument);
            case "ArrayExpression":
              return node.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors) {
          const node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
          return this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          this.next();
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(3, 93, true);
              return this.finishNode(node, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type,
            start: startPos,
            startLoc
          } = this.state;
          if (type === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type === 134) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          return this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          var _startLoc, _startPos, _left;
          startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
          startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29))
            return left;
          const node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type);
        }
        checkLVal(expression, {
          in: ancestor,
          binding = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression))
            return;
          if (type === "MemberExpression") {
            if (binding !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (expression.type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
            const {
              name
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name);
              }
            }
            return;
          }
          const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
          if (validity === true)
            return;
          if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor: ancestor.type === "UpdateExpression" ? {
                type: "UpdateExpression",
                prefix: ancestor.prefix
              } : {
                type: ancestor.type
              }
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
          const nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding,
                checkClashes,
                allowingSloppyLetBinding,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
              });
            }
          }
          if (!allowLetBinding && at.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at, bindingType);
          }
        }
        declareNameFromIdentifier(identifier, binding) {
          this.scope.declareName(identifier.name, binding, identifier.loc.start);
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern)
                break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      };
      var ExpressionParser = class extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name = key.type === "Identifier" ? key.name : key.value;
          if (name === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(135)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(12)) {
              node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          if (this.isContextual(105)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startPos, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type
          } = this.state;
          if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startPos, startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node.left = left;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node.left = left;
            }
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startPos, startLoc, -1);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.left = left;
              node.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node.right = this.parseExprOpRightExpr(op, prec);
              const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(finishedNode, leftStartPos, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(105)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
          if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body;
        }
        checkExponentialAfterUnary(node) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startPos, startLoc);
            if (!sawUnary)
              this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node
                });
              }
            }
            if (!update) {
              if (!sawUnary) {
                this.checkExponentialAfterUnary(node);
              }
              return this.finishNode(node, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {
              type
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startPos, startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
              in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node2, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startPos, startLoc);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
          };
          do {
            base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const {
            type
          } = this.state;
          if (!noCalls && type === 15) {
            return this.parseBind(base, startPos, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
          }
          let optional = false;
          if (type === 18) {
            if (noCalls && this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
          } else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) {
              return this.parseMember(base, startPos, startLoc, state, computed, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
        }
        parseMember(base, startPos, startLoc, state, computed, optional) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.computed = computed;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(134)) {
            if (base.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
          } else {
            node.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
          } else {
            return this.finishNode(node, "MemberExpression");
          }
        }
        parseBind(base, startPos, startLoc, noCalls, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          this.next();
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node.optional = optional;
          }
          if (optional) {
            node.arguments = this.parseCallExpressionArguments(11);
          } else {
            node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
          }
          let finishedNode = this.finishCallExpression(node, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), finishedNode);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return finishedNode;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startPos, startLoc, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node, optional) {
          if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node, call.callee.trailingComments);
          }
          return node;
        }
        parseNoCallExpr() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          const {
            type
          } = this.state;
          switch (type) {
            case 79:
              return this.parseSuper();
            case 83:
              node = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node, "Import");
            case 78:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 130:
              return this.parseNumericLiteral(this.state.value);
            case 131:
              return this.parseBigIntLiteral(this.state.value);
            case 132:
              return this.parseDecimalLiteral(this.state.value);
            case 129:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              this.parseDecorators();
            case 80:
              node = this.startNode();
              this.takeDecorators(node);
              return this.parseClass(node, false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node = this.startNode();
              this.next();
              node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 134: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              } else {
                throw this.unexpected();
              }
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else {
                throw this.unexpected();
              }
            }
            default:
              if (tokenIsIdentifier(type)) {
                if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type2
                  } = this.state;
                  if (type2 === 68) {
                    this.resetPreviousNodeTrailingComments(id);
                    this.next();
                    return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                  } else if (tokenIsIdentifier(type2)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                    } else {
                      return id;
                    }
                  } else if (type2 === 90) {
                    this.resetPreviousNodeTrailingComments(id);
                    return this.parseDo(this.startNodeAtNode(id), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              } else {
                throw this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            throw this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType = this.state.type;
          this.next();
          return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType)
              }]);
            }
            case "smart":
              return tokenType === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          return this.parseArrowExpression(node, params, true);
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node
            });
          }
          return this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode();
          const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
          const name = this.state.value;
          this.next();
          node.id = this.createIdentifier(id, name);
          return this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          node.property = this.parseIdentifier(true);
          if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          this.addExtra(node, "rawValue", value);
          this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
          node.value = value;
          this.next();
          return this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          node.value = value;
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartPos = this.state.start;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartPos = this.state.start;
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startPos, startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startPos, startLoc, val);
        }
        wrapParenthesis(startPos, startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startPos);
            this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startPos, startLoc);
          parenExpression.expression = expression;
          return this.finishNode(parenExpression, "ParenthesizedExpression");
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) {
            return node;
          }
        }
        parseParenItem(node, startPos, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          this.parseNewCallee(node);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
          } else {
            node.arguments = [];
          }
          return this.finishNode(node, "NewExpression");
        }
        parseNewCallee(node) {
          node.callee = this.parseNoCallExpr();
          if (node.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node.callee
            });
          } else if (this.isOptionalChain(node.callee)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.lastTokEndLoc
            });
          } else if (this.eat(18)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(startLoc, 2)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          const finishedNode = this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return finishedNode;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node.quasis = [curElt];
          while (!curElt.tail) {
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node = this.startNode();
          node.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          if (isPattern) {
            type = "ObjectPattern";
          } else if (isRecord) {
            type = "RecordExpression";
          }
          return this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startPos;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length)
              this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startPos = this.state.start;
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        }
        getGetterSetterExpectedParamCount(method) {
          return method.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length !== paramCount) {
            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method
            });
          }
          if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern)
              this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (!node)
            this.unexpected();
          return node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type) {
                case 130:
                  key = this.parseNumericLiteral(value);
                  break;
                case 129:
                  key = this.parseStringLiteral(value);
                  break;
                case 131:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 132:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 134: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            prop.key = key;
            if (type !== 134) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null;
          node.generator = false;
          node.async = !!isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          this.initFunction(node, isAsync);
          node.generator = !!isGenerator;
          const allowModifiers = isConstructor;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          this.parseFunctionParams(node, allowModifiers);
          const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
          this.prodParam.exit();
          this.scope.exit();
          return finishedNode;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node.params = params;
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          this.parseFunctionBody(node, false, isMethod);
          return this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return node.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
              return false;
          }
          return true;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode();
          const name = this.parseIdentifierName(node.start, liberal);
          return this.createIdentifier(node, name);
        }
        createIdentifier(node, name) {
          node.name = name;
          node.loc.identifierName = name;
          return this.finishNode(node, "Identifier");
        }
        parseIdentifierName(pos, liberal) {
          let name;
          const {
            startLoc,
            type
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
          } else {
            throw this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(128);
            }
          } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) {
            return;
          }
          if (!canBeReservedWord(word)) {
            return;
          }
          if (word === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
          if (checkKeywords && isKeyword(word)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word
            });
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait)
            return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak())
            return true;
          const {
            type
          } = this.state;
          return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 135:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating)
                  break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node.delegate = delegating;
          node.argument = argument;
          return this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
          if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next();
          this.eat(5);
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          const program = this.startNode();
          try {
            node.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          this.eat(8);
          return this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      };
      var loopLabel = {
        kind: "loop"
      };
      var switchLabel = {
        kind: "switch"
      };
      var FUNC_NO_FLAGS = 0;
      var FUNC_STATEMENT = 1;
      var FUNC_HANGING_STATEMENT = 2;
      var FUNC_NULLABLE_ID = 4;
      var loneSurrogate = /[\uD800-\uDFFF]/u;
      var keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input) {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          const {
            type
          } = token;
          if (typeof type === "number") {
            {
              if (type === 134) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(128),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i++;
                continue;
              }
              if (tokenIsTemplate(type)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i += 2;
                continue;
              }
            }
            token.type = getExportedToken(type);
          }
        }
        return tokens;
      }
      var StatementParser = class extends ExpressionParser {
        parseTopLevel(file, program) {
          file.program = this.parseProgram(program);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program, end = 135, sourceType = this.options.sourceType) {
          program.sourceType = sourceType;
          program.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at,
                localName
              });
            }
          }
          return this.finishNode(program, "Program");
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node = this.startNode();
          node.value = this.state.value;
          this.next();
          return this.finishNode(node, "InterpreterDirective");
        }
        isLet(context) {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.isLetKeyword(context);
        }
        isLetKeyword(context) {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh === 92 || nextCh === 91) {
            return true;
          }
          if (context)
            return false;
          if (nextCh === 123)
            return true;
          if (isIdentifierStart(nextCh)) {
            keywordRelationalOperator.lastIndex = next;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        parseStatement(context, topLevel) {
          if (this.match(26)) {
            this.parseDecorators(true);
          }
          return this.parseStatementContent(context, topLevel);
        }
        parseStatementContent(context, topLevel) {
          let starttype = this.state.type;
          const node = this.startNode();
          let kind;
          if (this.isLet(context)) {
            starttype = 74;
            kind = "let";
          }
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node, true);
            case 63:
              return this.parseBreakContinueStatement(node, false);
            case 64:
              return this.parseDebuggerStatement(node);
            case 90:
              return this.parseDoStatement(node);
            case 91:
              return this.parseForStatement(node);
            case 68:
              if (this.lookaheadCharCode() === 46)
                break;
              if (context) {
                if (this.state.strict) {
                  this.raise(Errors.StrictFunction, {
                    at: this.state.startLoc
                  });
                } else if (context !== "if" && context !== "label") {
                  this.raise(Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
              }
              return this.parseFunctionStatement(node, false, !context);
            case 80:
              if (context)
                this.unexpected();
              return this.parseClass(node, true);
            case 69:
              return this.parseIfStatement(node);
            case 70:
              return this.parseReturnStatement(node);
            case 71:
              return this.parseSwitchStatement(node);
            case 72:
              return this.parseThrowStatement(node);
            case 73:
              return this.parseTryStatement(node);
            case 75:
            case 74:
              kind = kind || this.state.value;
              if (context && kind !== "var") {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node, kind);
            case 92:
              return this.parseWhileStatement(node);
            case 76:
              return this.parseWithStatement(node);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result;
              if (starttype === 83) {
                result = this.parseImport(node);
                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node);
                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(result);
              return result;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (context) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node, true, !context);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
        assertModuleNodeAllowed(node) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node
            });
          }
        }
        takeDecorators(node) {
          const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (decorators.length) {
            node.decorators = decorators;
            this.resetStartLocationFromNode(node, decorators[0]);
            this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
          }
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          while (this.match(26)) {
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
          }
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startPos2 = this.state.start;
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startPos2, startLoc2, expr);
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.object = expr;
                node2.property = this.parseIdentifier(true);
                node2.computed = false;
                expr = this.finishNode(node2, "MemberExpression");
              }
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
            this.state.decoratorStack.pop();
          } else {
            node.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node.label = null;
          } else {
            node.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node, isBreak);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop"))
                break;
              if (node.label && isBreak)
                break;
            }
          }
          if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
          this.state.labels.pop();
          this.expect(92);
          node.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          const startsWithLet = this.isContextual(99);
          const isLet = startsWithLet && this.isLetKeyword();
          if (this.match(74) || this.match(75) || isLet) {
            const initNode = this.startNode();
            const kind = isLet ? "let" : this.state.value;
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            if ((this.match(58) || this.isContextual(101)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init
              });
            }
            if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init, {
              in: {
                type
              }
            });
            return this.parseForIn(node, init, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        }
        parseFunctionStatement(node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
        }
        parseIfStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(66) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next();
          node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur)
                this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatement(null));
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur)
            this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          const simple = param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_LEXICAL,
            allowingSloppyLetBinding: true
          });
          return param;
        }
        parseTryStatement(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node
            });
          }
          return this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
          this.state.labels.pop();
          return this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.object = this.parseHeaderExpression();
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
          return this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, context) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            if (label.statementStart === node.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.state.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node.body = [];
          const directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = this.parseStatement(null, topLevel);
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node, init) {
          node.init = init;
          this.semicolon(false);
          node.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null)
              this.unexpected(awaitAt);
          } else {
            node.await = awaitAt !== null;
          }
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = false) {
          const declarations = node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12))
              break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
        }
        parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
          const isStatement = statement & FUNC_STATEMENT;
          const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
          const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
          this.initFunction(node, isAsync);
          if (this.match(55) && isHangingStatement) {
            this.raise(Errors.GeneratorInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          node.generator = this.eat(55);
          if (isStatement) {
            node.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          if (!isStatement) {
            node.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isStatement && !isHangingStatement) {
            this.registerFunctionStatementId(node);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, allowModifiers) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node.params = this.parseBindingList(11, 41, false, allowModifiers);
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          if (!node.id)
            return;
          this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node, isStatement, optionalId);
          this.parseClassSuper(node);
          node.body = this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(134);
            this.parseClassElementName(method);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(134);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method.kind = "method";
            const isPrivate2 = this.match(134);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type,
            value
          } = this.state;
          if ((type === 128 || type === 129) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type === 134) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
          }
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node);
          const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault)
              this.unexpected();
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
            throw this.unexpected(null, 5);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            this.parseExportFrom(node, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            this.checkExport(node, true, false, !!node.source);
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            node.declaration = this.parseExportDefaultExpression();
            this.checkExport(node, true, true);
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          throw this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            if (!node.specifiers)
              node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            if (!node.specifiers)
              node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node) {
          if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95))
            return false;
          const next = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          const isAsync = this.isAsyncFunction();
          if (this.match(68) || isAsync) {
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            this.parseDecorators(false);
            return this.parseClass(expr, true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) {
              return false;
            }
            if ((type === 126 || type === 125) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next, "from");
          if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node.assertions = assertions;
              this.checkJSONModuleImport(node);
            }
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (type === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                throw this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration = node.declaration;
                if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration
                  });
                }
              }
            } else if (node.specifiers && node.specifiers.length) {
              for (const specifier of node.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node.declaration) {
              if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                const id = node.declaration.id;
                if (!id)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(node, id.name);
              } else if (node.declaration.type === "VariableDeclaration") {
                for (const declaration of node.declaration.declarations) {
                  this.checkDeclaration(declaration.id);
                }
              }
            }
          }
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (currentContextDecorators.length) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
        }
        checkDeclaration(node) {
          if (node.type === "Identifier") {
            this.checkDuplicateExports(node, node.name);
          } else if (node.type === "ObjectPattern") {
            for (const prop of node.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node.type === "ArrayPattern") {
            for (const elem of node.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node.type === "ObjectProperty") {
            this.checkDeclaration(node.value);
          } else if (node.type === "RestElement") {
            this.checkDeclaration(node.argument);
          } else if (node.type === "AssignmentPattern") {
            this.checkDeclaration(node.left);
          }
        }
        checkDuplicateExports(node, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const isMaybeTypeOnly = this.isContextual(126);
            const isString = this.match(129);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
          } else if (isString) {
            node.exported = cloneStringLiteral(node.local);
          } else if (!node.exported) {
            node.exported = cloneIdentifier(node.local);
          }
          return this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(129)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node) {
          if (node.assertions != null) {
            return node.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkJSONModuleImport(node) {
          if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node;
            if (node.specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        parseImport(node) {
          node.specifiers = [];
          if (!this.match(129)) {
            const hasDefault = this.maybeParseDefaultImportSpecifier(node);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            if (parseNext && !hasStar)
              this.parseNamedImportSpecifiers(node);
            this.expectContextual(97);
          }
          node.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          } else {
            const attributes = this.maybeParseModuleAttributes();
            if (attributes) {
              node.attributes = attributes;
            }
          }
          this.checkJSONModuleImport(node);
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(129))
            this.unexpected();
          return this.parseExprAtom();
        }
        shouldParseDefaultImport(node) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type) {
          this.checkLVal(specifier.local, {
            in: specifier,
            binding: BIND_LEXICAL
          });
          return this.finishNode(specifier, type);
        }
        parseAssertEntries() {
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(129)) {
              node.key = this.parseStringLiteral(keyName);
            } else {
              node.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
          } else {
            if (this.hasPlugin("moduleAttributes"))
              return [];
            return null;
          }
          const attrs = [];
          const attributes = /* @__PURE__ */ new Set();
          do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
              });
            }
            if (attributes.has(node.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
              });
            }
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
          } else {
            if (this.hasPlugin("importAssertions"))
              return [];
            return null;
          }
          this.eat(5);
          const attrs = this.parseAssertEntries();
          this.eat(8);
          return attrs;
        }
        maybeParseDefaultImportSpecifier(node) {
          if (this.shouldParseDefaultImport(node)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(129);
            const isMaybeTypeOnly = this.isContextual(126);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      };
      var Parser2 = class extends StatementParser {
        constructor(options, input) {
          options = getOptions(options);
          super(options, input);
          this.options = options;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program);
          file.errors = this.state.errors;
          return file;
        }
      };
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin of plugins) {
          const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
          if (!pluginMap.has(name))
            pluginMap.set(name, options || {});
        }
        return pluginMap;
      }
      function parse2(input, options) {
        var _options;
        if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) {
              return ast;
            }
            if (parser.ambiguousScriptDifferentAst) {
              try {
                options.sourceType = "script";
                return getParser(options, input).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options, input).parse();
        }
      }
      function parseExpression(input, options) {
        const parser = getParser(options, input);
        if (parser.options.strictMode) {
          parser.state.strict = true;
        }
        return parser.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      var tokTypes = generateExportedTokenTypes(tt);
      function getParser(options, input) {
        let cls = Parser2;
        if (options != null && options.plugins) {
          validatePlugins(options.plugins);
          cls = getParserClass(options.plugins);
        }
        return new cls(options, input);
      }
      var parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser2;
          for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      exports.parse = parse2;
      exports.parseExpression = parseExpression;
      exports.tokTypes = tokTypes;
    }
  });

  // ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
  var require_virtual_types = __commonJS({
    "../node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
      var ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
      exports.ReferencedIdentifier = ReferencedIdentifier;
      var ReferencedMemberExpression = ["MemberExpression"];
      exports.ReferencedMemberExpression = ReferencedMemberExpression;
      var BindingIdentifier = ["Identifier"];
      exports.BindingIdentifier = BindingIdentifier;
      var Statement = ["Statement"];
      exports.Statement = Statement;
      var Expression = ["Expression"];
      exports.Expression = Expression;
      var Scope = ["Scopable", "Pattern"];
      exports.Scope = Scope;
      var Referenced = null;
      exports.Referenced = Referenced;
      var BlockScoped = null;
      exports.BlockScoped = BlockScoped;
      var Var = ["VariableDeclaration"];
      exports.Var = Var;
      var User = null;
      exports.User = User;
      var Generated = null;
      exports.Generated = Generated;
      var Pure = null;
      exports.Pure = Pure;
      var Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
      exports.Flow = Flow;
      var RestProperty = ["RestElement"];
      exports.RestProperty = RestProperty;
      var SpreadProperty = ["RestElement"];
      exports.SpreadProperty = SpreadProperty;
      var ExistentialTypeParam = ["ExistsTypeAnnotation"];
      exports.ExistentialTypeParam = ExistentialTypeParam;
      var NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
      exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
      var ForAwaitStatement = ["ForOfStatement"];
      exports.ForAwaitStatement = ForAwaitStatement;
    }
  });

  // ../node_modules/@babel/traverse/lib/visitors.js
  var require_visitors = __commonJS({
    "../node_modules/@babel/traverse/lib/visitors.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.explode = explode;
      exports.merge = merge;
      exports.verify = verify;
      var virtualTypes = require_virtual_types();
      var _t = require_lib3();
      var {
        DEPRECATED_KEYS,
        FLIPPED_ALIAS_KEYS,
        TYPES
      } = _t;
      function isVirtualType(type) {
        return type in virtualTypes;
      }
      function explode(visitor) {
        if (visitor._exploded)
          return visitor;
        visitor._exploded = true;
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          const parts = nodeType.split("|");
          if (parts.length === 1)
            continue;
          const fns = visitor[nodeType];
          delete visitor[nodeType];
          for (const part of parts) {
            visitor[part] = fns;
          }
        }
        verify(visitor);
        delete visitor.__esModule;
        ensureEntranceObjects(visitor);
        ensureCallbackArrays(visitor);
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          if (!isVirtualType(nodeType))
            continue;
          const fns = visitor[nodeType];
          for (const type of Object.keys(fns)) {
            fns[type] = wrapCheck(nodeType, fns[type]);
          }
          delete visitor[nodeType];
          const types = virtualTypes[nodeType];
          if (types !== null) {
            for (const type of types) {
              if (visitor[type]) {
                mergePair(visitor[type], fns);
              } else {
                visitor[type] = fns;
              }
            }
          } else {
            mergePair(visitor, fns);
          }
        }
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          const fns = visitor[nodeType];
          let aliases = FLIPPED_ALIAS_KEYS[nodeType];
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          if (deprecatedKey) {
            console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);
            aliases = [deprecatedKey];
          }
          if (!aliases)
            continue;
          delete visitor[nodeType];
          for (const alias of aliases) {
            const existing = visitor[alias];
            if (existing) {
              mergePair(existing, fns);
            } else {
              visitor[alias] = Object.assign({}, fns);
            }
          }
        }
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType))
            continue;
          ensureCallbackArrays(visitor[nodeType]);
        }
        return visitor;
      }
      function verify(visitor) {
        if (visitor._verified)
          return;
        if (typeof visitor === "function") {
          throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
        }
        for (const nodeType of Object.keys(visitor)) {
          if (nodeType === "enter" || nodeType === "exit") {
            validateVisitorMethods(nodeType, visitor[nodeType]);
          }
          if (shouldIgnoreKey(nodeType))
            continue;
          if (TYPES.indexOf(nodeType) < 0) {
            throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
          }
          const visitors = visitor[nodeType];
          if (typeof visitors === "object") {
            for (const visitorKey of Object.keys(visitors)) {
              if (visitorKey === "enter" || visitorKey === "exit") {
                validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
              } else {
                throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
              }
            }
          }
        }
        visitor._verified = true;
      }
      function validateVisitorMethods(path, val) {
        const fns = [].concat(val);
        for (const fn of fns) {
          if (typeof fn !== "function") {
            throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
          }
        }
      }
      function merge(visitors, states = [], wrapper) {
        const rootVisitor = {};
        for (let i = 0; i < visitors.length; i++) {
          const visitor = visitors[i];
          const state = states[i];
          explode(visitor);
          for (const type of Object.keys(visitor)) {
            let visitorType = visitor[type];
            if (state || wrapper) {
              visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
            }
            const nodeVisitor = rootVisitor[type] || (rootVisitor[type] = {});
            mergePair(nodeVisitor, visitorType);
          }
        }
        return rootVisitor;
      }
      function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
        const newVisitor = {};
        for (const key of Object.keys(oldVisitor)) {
          let fns = oldVisitor[key];
          if (!Array.isArray(fns))
            continue;
          fns = fns.map(function(fn) {
            let newFn = fn;
            if (state) {
              newFn = function(path) {
                return fn.call(state, path, state);
              };
            }
            if (wrapper) {
              newFn = wrapper(state.key, key, newFn);
            }
            if (newFn !== fn) {
              newFn.toString = () => fn.toString();
            }
            return newFn;
          });
          newVisitor[key] = fns;
        }
        return newVisitor;
      }
      function ensureEntranceObjects(obj) {
        for (const key of Object.keys(obj)) {
          if (shouldIgnoreKey(key))
            continue;
          const fns = obj[key];
          if (typeof fns === "function") {
            obj[key] = {
              enter: fns
            };
          }
        }
      }
      function ensureCallbackArrays(obj) {
        if (obj.enter && !Array.isArray(obj.enter))
          obj.enter = [obj.enter];
        if (obj.exit && !Array.isArray(obj.exit))
          obj.exit = [obj.exit];
      }
      function wrapCheck(nodeType, fn) {
        const newFn = function(path) {
          if (path[`is${nodeType}`]()) {
            return fn.apply(this, arguments);
          }
        };
        newFn.toString = () => fn.toString();
        return newFn;
      }
      function shouldIgnoreKey(key) {
        if (key[0] === "_")
          return true;
        if (key === "enter" || key === "exit" || key === "shouldSkip")
          return true;
        if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
          return true;
        }
        return false;
      }
      function mergePair(dest, src) {
        for (const key of Object.keys(src)) {
          dest[key] = [].concat(dest[key] || [], src[key]);
        }
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/cache.js
  var require_cache = __commonJS({
    "../node_modules/@babel/traverse/lib/cache.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.clear = clear;
      exports.clearPath = clearPath;
      exports.clearScope = clearScope;
      exports.scope = exports.path = void 0;
      var path = /* @__PURE__ */ new WeakMap();
      exports.path = path;
      var scope = /* @__PURE__ */ new WeakMap();
      exports.scope = scope;
      function clear() {
        clearPath();
        clearScope();
      }
      function clearPath() {
        exports.path = path = /* @__PURE__ */ new WeakMap();
      }
      function clearScope() {
        exports.scope = scope = /* @__PURE__ */ new WeakMap();
      }
    }
  });

  // ../node_modules/ms/index.js
  var require_ms = __commonJS({
    "../node_modules/ms/index.js"(exports, module) {
      init_inject();
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../node_modules/debug/src/common.js"(exports, module) {
      init_inject();
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../node_modules/debug/src/browser.js"(exports, module) {
      init_inject();
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../node_modules/@babel/traverse/lib/scope/binding.js
  var require_binding = __commonJS({
    "../node_modules/@babel/traverse/lib/scope/binding.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var Binding = class {
        constructor({
          identifier,
          scope,
          path,
          kind
        }) {
          this.identifier = void 0;
          this.scope = void 0;
          this.path = void 0;
          this.kind = void 0;
          this.constantViolations = [];
          this.constant = true;
          this.referencePaths = [];
          this.referenced = false;
          this.references = 0;
          this.identifier = identifier;
          this.scope = scope;
          this.path = path;
          this.kind = kind;
          this.clearValue();
        }
        deoptValue() {
          this.clearValue();
          this.hasDeoptedValue = true;
        }
        setValue(value) {
          if (this.hasDeoptedValue)
            return;
          this.hasValue = true;
          this.value = value;
        }
        clearValue() {
          this.hasDeoptedValue = false;
          this.hasValue = false;
          this.value = null;
        }
        reassign(path) {
          this.constant = false;
          if (this.constantViolations.indexOf(path) !== -1) {
            return;
          }
          this.constantViolations.push(path);
        }
        reference(path) {
          if (this.referencePaths.indexOf(path) !== -1) {
            return;
          }
          this.referenced = true;
          this.references++;
          this.referencePaths.push(path);
        }
        dereference() {
          this.references--;
          this.referenced = !!this.references;
        }
      };
      exports.default = Binding;
    }
  });

  // ../node_modules/@babel/helper-split-export-declaration/lib/index.js
  var require_lib6 = __commonJS({
    "../node_modules/@babel/helper-split-export-declaration/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = splitExportDeclaration;
      var _t = require_lib3();
      var {
        cloneNode,
        exportNamedDeclaration,
        exportSpecifier,
        identifier,
        variableDeclaration,
        variableDeclarator
      } = _t;
      function splitExportDeclaration(exportDeclaration) {
        if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {
          throw new Error("Only default and named export declarations can be split.");
        }
        if (exportDeclaration.isExportDefaultDeclaration()) {
          const declaration2 = exportDeclaration.get("declaration");
          const standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration();
          const scope = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
          let id = declaration2.node.id;
          let needBindingRegistration = false;
          if (!id) {
            needBindingRegistration = true;
            id = scope.generateUidIdentifier("default");
            if (standaloneDeclaration || declaration2.isFunctionExpression() || declaration2.isClassExpression()) {
              declaration2.node.id = cloneNode(id);
            }
          }
          const updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration2.node)]);
          const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
          exportDeclaration.insertAfter(updatedExportDeclaration);
          exportDeclaration.replaceWith(updatedDeclaration);
          if (needBindingRegistration) {
            scope.registerDeclaration(exportDeclaration);
          }
          return exportDeclaration;
        } else if (exportDeclaration.get("specifiers").length > 0) {
          throw new Error("It doesn't make sense to split exported specifiers.");
        }
        const declaration = exportDeclaration.get("declaration");
        const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
        const specifiers = Object.keys(bindingIdentifiers).map((name) => {
          return exportSpecifier(identifier(name), identifier(name));
        });
        const aliasDeclar = exportNamedDeclaration(null, specifiers);
        exportDeclaration.insertAfter(aliasDeclar);
        exportDeclaration.replaceWith(declaration.node);
        return exportDeclaration;
      }
    }
  });

  // ../node_modules/@babel/helper-environment-visitor/lib/index.js
  var require_lib7 = __commonJS({
    "../node_modules/@babel/helper-environment-visitor/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
      exports.skipAllButComputedKey = skipAllButComputedKey;
      function skipAllButComputedKey(path) {
        path.skip();
        if (path.node.computed) {
          path.context.maybeQueue(path.get("key"));
        }
      }
      function requeueComputedKeyAndDecorators(path) {
        const {
          context,
          node
        } = path;
        if (node.computed) {
          context.maybeQueue(path.get("key"));
        }
        if (node.decorators) {
          for (const decorator of path.get("decorators")) {
            context.maybeQueue(decorator);
          }
        }
      }
      var visitor = {
        FunctionParent(path) {
          if (path.isArrowFunctionExpression()) {
            return;
          } else {
            path.skip();
            if (path.isMethod()) {
              requeueComputedKeyAndDecorators(path);
            }
          }
        },
        Property(path) {
          if (path.isObjectProperty()) {
            return;
          }
          path.skip();
          requeueComputedKeyAndDecorators(path);
        }
      };
      var _default = visitor;
      exports.default = _default;
    }
  });

  // ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
  var require_renamer = __commonJS({
    "../node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _binding = require_binding();
      var _helperSplitExportDeclaration = require_lib6();
      var t2 = require_lib3();
      var _helperEnvironmentVisitor = require_lib7();
      var renameVisitor = {
        ReferencedIdentifier({
          node
        }, state) {
          if (node.name === state.oldName) {
            node.name = state.newName;
          }
        },
        Scope(path, state) {
          if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
            path.skip();
            if (path.isMethod()) {
              (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path);
            }
          }
        },
        "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
          if (path.isVariableDeclaration())
            return;
          const ids = path.getOuterBindingIdentifiers();
          for (const name in ids) {
            if (name === state.oldName)
              ids[name].name = state.newName;
          }
        }
      };
      var Renamer = class {
        constructor(binding, oldName, newName) {
          this.newName = newName;
          this.oldName = oldName;
          this.binding = binding;
        }
        maybeConvertFromExportDeclaration(parentDeclar) {
          const maybeExportDeclar = parentDeclar.parentPath;
          if (!maybeExportDeclar.isExportDeclaration()) {
            return;
          }
          if (maybeExportDeclar.isExportDefaultDeclaration()) {
            const {
              declaration
            } = maybeExportDeclar.node;
            if (t2.isDeclaration(declaration) && !declaration.id) {
              return;
            }
          }
          if (maybeExportDeclar.isExportAllDeclaration()) {
            return;
          }
          (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
        }
        maybeConvertFromClassFunctionDeclaration(path) {
          return path;
        }
        maybeConvertFromClassFunctionExpression(path) {
          return path;
        }
        rename(block) {
          const {
            binding,
            oldName,
            newName
          } = this;
          const {
            scope,
            path
          } = binding;
          const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
          if (parentDeclar) {
            const bindingIds = parentDeclar.getOuterBindingIdentifiers();
            if (bindingIds[oldName] === binding.identifier) {
              this.maybeConvertFromExportDeclaration(parentDeclar);
            }
          }
          const blockToTraverse = block || scope.block;
          if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
            blockToTraverse.cases.forEach((c) => {
              scope.traverse(c, renameVisitor, this);
            });
          } else {
            scope.traverse(blockToTraverse, renameVisitor, this);
          }
          if (!block) {
            scope.removeOwnBinding(oldName);
            scope.bindings[newName] = binding;
            this.binding.identifier.name = newName;
          }
          if (parentDeclar) {
            this.maybeConvertFromClassFunctionDeclaration(path);
            this.maybeConvertFromClassFunctionExpression(path);
          }
        }
      };
      exports.default = Renamer;
    }
  });

  // ../node_modules/globals/globals.json
  var require_globals = __commonJS({
    "../node_modules/globals/globals.json"(exports, module) {
      module.exports = {
        builtin: {
          Array: false,
          ArrayBuffer: false,
          Atomics: false,
          BigInt: false,
          BigInt64Array: false,
          BigUint64Array: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          globalThis: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          SharedArrayBuffer: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        es5: {
          Array: false,
          Boolean: false,
          constructor: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          propertyIsEnumerable: false,
          RangeError: false,
          ReferenceError: false,
          RegExp: false,
          String: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false
        },
        es2015: {
          Array: false,
          ArrayBuffer: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        es2017: {
          Array: false,
          ArrayBuffer: false,
          Atomics: false,
          Boolean: false,
          constructor: false,
          DataView: false,
          Date: false,
          decodeURI: false,
          decodeURIComponent: false,
          encodeURI: false,
          encodeURIComponent: false,
          Error: false,
          escape: false,
          eval: false,
          EvalError: false,
          Float32Array: false,
          Float64Array: false,
          Function: false,
          hasOwnProperty: false,
          Infinity: false,
          Int16Array: false,
          Int32Array: false,
          Int8Array: false,
          isFinite: false,
          isNaN: false,
          isPrototypeOf: false,
          JSON: false,
          Map: false,
          Math: false,
          NaN: false,
          Number: false,
          Object: false,
          parseFloat: false,
          parseInt: false,
          Promise: false,
          propertyIsEnumerable: false,
          Proxy: false,
          RangeError: false,
          ReferenceError: false,
          Reflect: false,
          RegExp: false,
          Set: false,
          SharedArrayBuffer: false,
          String: false,
          Symbol: false,
          SyntaxError: false,
          toLocaleString: false,
          toString: false,
          TypeError: false,
          Uint16Array: false,
          Uint32Array: false,
          Uint8Array: false,
          Uint8ClampedArray: false,
          undefined: false,
          unescape: false,
          URIError: false,
          valueOf: false,
          WeakMap: false,
          WeakSet: false
        },
        browser: {
          AbortController: false,
          AbortSignal: false,
          addEventListener: false,
          alert: false,
          AnalyserNode: false,
          Animation: false,
          AnimationEffectReadOnly: false,
          AnimationEffectTiming: false,
          AnimationEffectTimingReadOnly: false,
          AnimationEvent: false,
          AnimationPlaybackEvent: false,
          AnimationTimeline: false,
          applicationCache: false,
          ApplicationCache: false,
          ApplicationCacheErrorEvent: false,
          atob: false,
          Attr: false,
          Audio: false,
          AudioBuffer: false,
          AudioBufferSourceNode: false,
          AudioContext: false,
          AudioDestinationNode: false,
          AudioListener: false,
          AudioNode: false,
          AudioParam: false,
          AudioProcessingEvent: false,
          AudioScheduledSourceNode: false,
          "AudioWorkletGlobalScope ": false,
          AudioWorkletNode: false,
          AudioWorkletProcessor: false,
          BarProp: false,
          BaseAudioContext: false,
          BatteryManager: false,
          BeforeUnloadEvent: false,
          BiquadFilterNode: false,
          Blob: false,
          BlobEvent: false,
          blur: false,
          BroadcastChannel: false,
          btoa: false,
          BudgetService: false,
          ByteLengthQueuingStrategy: false,
          Cache: false,
          caches: false,
          CacheStorage: false,
          cancelAnimationFrame: false,
          cancelIdleCallback: false,
          CanvasCaptureMediaStreamTrack: false,
          CanvasGradient: false,
          CanvasPattern: false,
          CanvasRenderingContext2D: false,
          ChannelMergerNode: false,
          ChannelSplitterNode: false,
          CharacterData: false,
          clearInterval: false,
          clearTimeout: false,
          clientInformation: false,
          ClipboardEvent: false,
          close: false,
          closed: false,
          CloseEvent: false,
          Comment: false,
          CompositionEvent: false,
          confirm: false,
          console: false,
          ConstantSourceNode: false,
          ConvolverNode: false,
          CountQueuingStrategy: false,
          createImageBitmap: false,
          Credential: false,
          CredentialsContainer: false,
          crypto: false,
          Crypto: false,
          CryptoKey: false,
          CSS: false,
          CSSConditionRule: false,
          CSSFontFaceRule: false,
          CSSGroupingRule: false,
          CSSImportRule: false,
          CSSKeyframeRule: false,
          CSSKeyframesRule: false,
          CSSMediaRule: false,
          CSSNamespaceRule: false,
          CSSPageRule: false,
          CSSRule: false,
          CSSRuleList: false,
          CSSStyleDeclaration: false,
          CSSStyleRule: false,
          CSSStyleSheet: false,
          CSSSupportsRule: false,
          CustomElementRegistry: false,
          customElements: false,
          CustomEvent: false,
          DataTransfer: false,
          DataTransferItem: false,
          DataTransferItemList: false,
          defaultstatus: false,
          defaultStatus: false,
          DelayNode: false,
          DeviceMotionEvent: false,
          DeviceOrientationEvent: false,
          devicePixelRatio: false,
          dispatchEvent: false,
          document: false,
          Document: false,
          DocumentFragment: false,
          DocumentType: false,
          DOMError: false,
          DOMException: false,
          DOMImplementation: false,
          DOMMatrix: false,
          DOMMatrixReadOnly: false,
          DOMParser: false,
          DOMPoint: false,
          DOMPointReadOnly: false,
          DOMQuad: false,
          DOMRect: false,
          DOMRectReadOnly: false,
          DOMStringList: false,
          DOMStringMap: false,
          DOMTokenList: false,
          DragEvent: false,
          DynamicsCompressorNode: false,
          Element: false,
          ErrorEvent: false,
          event: false,
          Event: false,
          EventSource: false,
          EventTarget: false,
          external: false,
          fetch: false,
          File: false,
          FileList: false,
          FileReader: false,
          find: false,
          focus: false,
          FocusEvent: false,
          FontFace: false,
          FontFaceSetLoadEvent: false,
          FormData: false,
          frameElement: false,
          frames: false,
          GainNode: false,
          Gamepad: false,
          GamepadButton: false,
          GamepadEvent: false,
          getComputedStyle: false,
          getSelection: false,
          HashChangeEvent: false,
          Headers: false,
          history: false,
          History: false,
          HTMLAllCollection: false,
          HTMLAnchorElement: false,
          HTMLAreaElement: false,
          HTMLAudioElement: false,
          HTMLBaseElement: false,
          HTMLBodyElement: false,
          HTMLBRElement: false,
          HTMLButtonElement: false,
          HTMLCanvasElement: false,
          HTMLCollection: false,
          HTMLContentElement: false,
          HTMLDataElement: false,
          HTMLDataListElement: false,
          HTMLDetailsElement: false,
          HTMLDialogElement: false,
          HTMLDirectoryElement: false,
          HTMLDivElement: false,
          HTMLDListElement: false,
          HTMLDocument: false,
          HTMLElement: false,
          HTMLEmbedElement: false,
          HTMLFieldSetElement: false,
          HTMLFontElement: false,
          HTMLFormControlsCollection: false,
          HTMLFormElement: false,
          HTMLFrameElement: false,
          HTMLFrameSetElement: false,
          HTMLHeadElement: false,
          HTMLHeadingElement: false,
          HTMLHRElement: false,
          HTMLHtmlElement: false,
          HTMLIFrameElement: false,
          HTMLImageElement: false,
          HTMLInputElement: false,
          HTMLLabelElement: false,
          HTMLLegendElement: false,
          HTMLLIElement: false,
          HTMLLinkElement: false,
          HTMLMapElement: false,
          HTMLMarqueeElement: false,
          HTMLMediaElement: false,
          HTMLMenuElement: false,
          HTMLMetaElement: false,
          HTMLMeterElement: false,
          HTMLModElement: false,
          HTMLObjectElement: false,
          HTMLOListElement: false,
          HTMLOptGroupElement: false,
          HTMLOptionElement: false,
          HTMLOptionsCollection: false,
          HTMLOutputElement: false,
          HTMLParagraphElement: false,
          HTMLParamElement: false,
          HTMLPictureElement: false,
          HTMLPreElement: false,
          HTMLProgressElement: false,
          HTMLQuoteElement: false,
          HTMLScriptElement: false,
          HTMLSelectElement: false,
          HTMLShadowElement: false,
          HTMLSlotElement: false,
          HTMLSourceElement: false,
          HTMLSpanElement: false,
          HTMLStyleElement: false,
          HTMLTableCaptionElement: false,
          HTMLTableCellElement: false,
          HTMLTableColElement: false,
          HTMLTableElement: false,
          HTMLTableRowElement: false,
          HTMLTableSectionElement: false,
          HTMLTemplateElement: false,
          HTMLTextAreaElement: false,
          HTMLTimeElement: false,
          HTMLTitleElement: false,
          HTMLTrackElement: false,
          HTMLUListElement: false,
          HTMLUnknownElement: false,
          HTMLVideoElement: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          IdleDeadline: false,
          IIRFilterNode: false,
          Image: false,
          ImageBitmap: false,
          ImageBitmapRenderingContext: false,
          ImageCapture: false,
          ImageData: false,
          indexedDB: false,
          innerHeight: false,
          innerWidth: false,
          InputEvent: false,
          IntersectionObserver: false,
          IntersectionObserverEntry: false,
          Intl: false,
          isSecureContext: false,
          KeyboardEvent: false,
          KeyframeEffect: false,
          KeyframeEffectReadOnly: false,
          length: false,
          localStorage: false,
          location: true,
          Location: false,
          locationbar: false,
          matchMedia: false,
          MediaDeviceInfo: false,
          MediaDevices: false,
          MediaElementAudioSourceNode: false,
          MediaEncryptedEvent: false,
          MediaError: false,
          MediaKeyMessageEvent: false,
          MediaKeySession: false,
          MediaKeyStatusMap: false,
          MediaKeySystemAccess: false,
          MediaList: false,
          MediaQueryList: false,
          MediaQueryListEvent: false,
          MediaRecorder: false,
          MediaSettingsRange: false,
          MediaSource: false,
          MediaStream: false,
          MediaStreamAudioDestinationNode: false,
          MediaStreamAudioSourceNode: false,
          MediaStreamEvent: false,
          MediaStreamTrack: false,
          MediaStreamTrackEvent: false,
          menubar: false,
          MessageChannel: false,
          MessageEvent: false,
          MessagePort: false,
          MIDIAccess: false,
          MIDIConnectionEvent: false,
          MIDIInput: false,
          MIDIInputMap: false,
          MIDIMessageEvent: false,
          MIDIOutput: false,
          MIDIOutputMap: false,
          MIDIPort: false,
          MimeType: false,
          MimeTypeArray: false,
          MouseEvent: false,
          moveBy: false,
          moveTo: false,
          MutationEvent: false,
          MutationObserver: false,
          MutationRecord: false,
          name: false,
          NamedNodeMap: false,
          NavigationPreloadManager: false,
          navigator: false,
          Navigator: false,
          NetworkInformation: false,
          Node: false,
          NodeFilter: false,
          NodeIterator: false,
          NodeList: false,
          Notification: false,
          OfflineAudioCompletionEvent: false,
          OfflineAudioContext: false,
          offscreenBuffering: false,
          OffscreenCanvas: true,
          onabort: true,
          onafterprint: true,
          onanimationend: true,
          onanimationiteration: true,
          onanimationstart: true,
          onappinstalled: true,
          onauxclick: true,
          onbeforeinstallprompt: true,
          onbeforeprint: true,
          onbeforeunload: true,
          onblur: true,
          oncancel: true,
          oncanplay: true,
          oncanplaythrough: true,
          onchange: true,
          onclick: true,
          onclose: true,
          oncontextmenu: true,
          oncuechange: true,
          ondblclick: true,
          ondevicemotion: true,
          ondeviceorientation: true,
          ondeviceorientationabsolute: true,
          ondrag: true,
          ondragend: true,
          ondragenter: true,
          ondragleave: true,
          ondragover: true,
          ondragstart: true,
          ondrop: true,
          ondurationchange: true,
          onemptied: true,
          onended: true,
          onerror: true,
          onfocus: true,
          ongotpointercapture: true,
          onhashchange: true,
          oninput: true,
          oninvalid: true,
          onkeydown: true,
          onkeypress: true,
          onkeyup: true,
          onlanguagechange: true,
          onload: true,
          onloadeddata: true,
          onloadedmetadata: true,
          onloadstart: true,
          onlostpointercapture: true,
          onmessage: true,
          onmessageerror: true,
          onmousedown: true,
          onmouseenter: true,
          onmouseleave: true,
          onmousemove: true,
          onmouseout: true,
          onmouseover: true,
          onmouseup: true,
          onmousewheel: true,
          onoffline: true,
          ononline: true,
          onpagehide: true,
          onpageshow: true,
          onpause: true,
          onplay: true,
          onplaying: true,
          onpointercancel: true,
          onpointerdown: true,
          onpointerenter: true,
          onpointerleave: true,
          onpointermove: true,
          onpointerout: true,
          onpointerover: true,
          onpointerup: true,
          onpopstate: true,
          onprogress: true,
          onratechange: true,
          onrejectionhandled: true,
          onreset: true,
          onresize: true,
          onscroll: true,
          onsearch: true,
          onseeked: true,
          onseeking: true,
          onselect: true,
          onstalled: true,
          onstorage: true,
          onsubmit: true,
          onsuspend: true,
          ontimeupdate: true,
          ontoggle: true,
          ontransitionend: true,
          onunhandledrejection: true,
          onunload: true,
          onvolumechange: true,
          onwaiting: true,
          onwheel: true,
          open: false,
          openDatabase: false,
          opener: false,
          Option: false,
          origin: false,
          OscillatorNode: false,
          outerHeight: false,
          outerWidth: false,
          PageTransitionEvent: false,
          pageXOffset: false,
          pageYOffset: false,
          PannerNode: false,
          parent: false,
          Path2D: false,
          PaymentAddress: false,
          PaymentRequest: false,
          PaymentRequestUpdateEvent: false,
          PaymentResponse: false,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceLongTaskTiming: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceNavigationTiming: false,
          PerformanceObserver: false,
          PerformanceObserverEntryList: false,
          PerformancePaintTiming: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          PeriodicWave: false,
          Permissions: false,
          PermissionStatus: false,
          personalbar: false,
          PhotoCapabilities: false,
          Plugin: false,
          PluginArray: false,
          PointerEvent: false,
          PopStateEvent: false,
          postMessage: false,
          Presentation: false,
          PresentationAvailability: false,
          PresentationConnection: false,
          PresentationConnectionAvailableEvent: false,
          PresentationConnectionCloseEvent: false,
          PresentationConnectionList: false,
          PresentationReceiver: false,
          PresentationRequest: false,
          print: false,
          ProcessingInstruction: false,
          ProgressEvent: false,
          PromiseRejectionEvent: false,
          prompt: false,
          PushManager: false,
          PushSubscription: false,
          PushSubscriptionOptions: false,
          queueMicrotask: false,
          RadioNodeList: false,
          Range: false,
          ReadableStream: false,
          registerProcessor: false,
          RemotePlayback: false,
          removeEventListener: false,
          Request: false,
          requestAnimationFrame: false,
          requestIdleCallback: false,
          resizeBy: false,
          ResizeObserver: false,
          ResizeObserverEntry: false,
          resizeTo: false,
          Response: false,
          RTCCertificate: false,
          RTCDataChannel: false,
          RTCDataChannelEvent: false,
          RTCDtlsTransport: false,
          RTCIceCandidate: false,
          RTCIceGatherer: false,
          RTCIceTransport: false,
          RTCPeerConnection: false,
          RTCPeerConnectionIceEvent: false,
          RTCRtpContributingSource: false,
          RTCRtpReceiver: false,
          RTCRtpSender: false,
          RTCSctpTransport: false,
          RTCSessionDescription: false,
          RTCStatsReport: false,
          RTCTrackEvent: false,
          screen: false,
          Screen: false,
          screenLeft: false,
          ScreenOrientation: false,
          screenTop: false,
          screenX: false,
          screenY: false,
          ScriptProcessorNode: false,
          scroll: false,
          scrollbars: false,
          scrollBy: false,
          scrollTo: false,
          scrollX: false,
          scrollY: false,
          SecurityPolicyViolationEvent: false,
          Selection: false,
          self: false,
          ServiceWorker: false,
          ServiceWorkerContainer: false,
          ServiceWorkerRegistration: false,
          sessionStorage: false,
          setInterval: false,
          setTimeout: false,
          ShadowRoot: false,
          SharedWorker: false,
          SourceBuffer: false,
          SourceBufferList: false,
          speechSynthesis: false,
          SpeechSynthesisEvent: false,
          SpeechSynthesisUtterance: false,
          StaticRange: false,
          status: false,
          statusbar: false,
          StereoPannerNode: false,
          stop: false,
          Storage: false,
          StorageEvent: false,
          StorageManager: false,
          styleMedia: false,
          StyleSheet: false,
          StyleSheetList: false,
          SubtleCrypto: false,
          SVGAElement: false,
          SVGAngle: false,
          SVGAnimatedAngle: false,
          SVGAnimatedBoolean: false,
          SVGAnimatedEnumeration: false,
          SVGAnimatedInteger: false,
          SVGAnimatedLength: false,
          SVGAnimatedLengthList: false,
          SVGAnimatedNumber: false,
          SVGAnimatedNumberList: false,
          SVGAnimatedPreserveAspectRatio: false,
          SVGAnimatedRect: false,
          SVGAnimatedString: false,
          SVGAnimatedTransformList: false,
          SVGAnimateElement: false,
          SVGAnimateMotionElement: false,
          SVGAnimateTransformElement: false,
          SVGAnimationElement: false,
          SVGCircleElement: false,
          SVGClipPathElement: false,
          SVGComponentTransferFunctionElement: false,
          SVGDefsElement: false,
          SVGDescElement: false,
          SVGDiscardElement: false,
          SVGElement: false,
          SVGEllipseElement: false,
          SVGFEBlendElement: false,
          SVGFEColorMatrixElement: false,
          SVGFEComponentTransferElement: false,
          SVGFECompositeElement: false,
          SVGFEConvolveMatrixElement: false,
          SVGFEDiffuseLightingElement: false,
          SVGFEDisplacementMapElement: false,
          SVGFEDistantLightElement: false,
          SVGFEDropShadowElement: false,
          SVGFEFloodElement: false,
          SVGFEFuncAElement: false,
          SVGFEFuncBElement: false,
          SVGFEFuncGElement: false,
          SVGFEFuncRElement: false,
          SVGFEGaussianBlurElement: false,
          SVGFEImageElement: false,
          SVGFEMergeElement: false,
          SVGFEMergeNodeElement: false,
          SVGFEMorphologyElement: false,
          SVGFEOffsetElement: false,
          SVGFEPointLightElement: false,
          SVGFESpecularLightingElement: false,
          SVGFESpotLightElement: false,
          SVGFETileElement: false,
          SVGFETurbulenceElement: false,
          SVGFilterElement: false,
          SVGForeignObjectElement: false,
          SVGGElement: false,
          SVGGeometryElement: false,
          SVGGradientElement: false,
          SVGGraphicsElement: false,
          SVGImageElement: false,
          SVGLength: false,
          SVGLengthList: false,
          SVGLinearGradientElement: false,
          SVGLineElement: false,
          SVGMarkerElement: false,
          SVGMaskElement: false,
          SVGMatrix: false,
          SVGMetadataElement: false,
          SVGMPathElement: false,
          SVGNumber: false,
          SVGNumberList: false,
          SVGPathElement: false,
          SVGPatternElement: false,
          SVGPoint: false,
          SVGPointList: false,
          SVGPolygonElement: false,
          SVGPolylineElement: false,
          SVGPreserveAspectRatio: false,
          SVGRadialGradientElement: false,
          SVGRect: false,
          SVGRectElement: false,
          SVGScriptElement: false,
          SVGSetElement: false,
          SVGStopElement: false,
          SVGStringList: false,
          SVGStyleElement: false,
          SVGSVGElement: false,
          SVGSwitchElement: false,
          SVGSymbolElement: false,
          SVGTextContentElement: false,
          SVGTextElement: false,
          SVGTextPathElement: false,
          SVGTextPositioningElement: false,
          SVGTitleElement: false,
          SVGTransform: false,
          SVGTransformList: false,
          SVGTSpanElement: false,
          SVGUnitTypes: false,
          SVGUseElement: false,
          SVGViewElement: false,
          TaskAttributionTiming: false,
          Text: false,
          TextDecoder: false,
          TextEncoder: false,
          TextEvent: false,
          TextMetrics: false,
          TextTrack: false,
          TextTrackCue: false,
          TextTrackCueList: false,
          TextTrackList: false,
          TimeRanges: false,
          toolbar: false,
          top: false,
          Touch: false,
          TouchEvent: false,
          TouchList: false,
          TrackEvent: false,
          TransitionEvent: false,
          TreeWalker: false,
          UIEvent: false,
          URL: false,
          URLSearchParams: false,
          ValidityState: false,
          visualViewport: false,
          VisualViewport: false,
          VTTCue: false,
          WaveShaperNode: false,
          WebAssembly: false,
          WebGL2RenderingContext: false,
          WebGLActiveInfo: false,
          WebGLBuffer: false,
          WebGLContextEvent: false,
          WebGLFramebuffer: false,
          WebGLProgram: false,
          WebGLQuery: false,
          WebGLRenderbuffer: false,
          WebGLRenderingContext: false,
          WebGLSampler: false,
          WebGLShader: false,
          WebGLShaderPrecisionFormat: false,
          WebGLSync: false,
          WebGLTexture: false,
          WebGLTransformFeedback: false,
          WebGLUniformLocation: false,
          WebGLVertexArrayObject: false,
          WebSocket: false,
          WheelEvent: false,
          window: false,
          Window: false,
          Worker: false,
          WritableStream: false,
          XMLDocument: false,
          XMLHttpRequest: false,
          XMLHttpRequestEventTarget: false,
          XMLHttpRequestUpload: false,
          XMLSerializer: false,
          XPathEvaluator: false,
          XPathExpression: false,
          XPathResult: false,
          XSLTProcessor: false
        },
        worker: {
          addEventListener: false,
          applicationCache: false,
          atob: false,
          Blob: false,
          BroadcastChannel: false,
          btoa: false,
          Cache: false,
          caches: false,
          clearInterval: false,
          clearTimeout: false,
          close: true,
          console: false,
          fetch: false,
          FileReaderSync: false,
          FormData: false,
          Headers: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          ImageData: false,
          importScripts: true,
          indexedDB: false,
          location: false,
          MessageChannel: false,
          MessagePort: false,
          name: false,
          navigator: false,
          Notification: false,
          onclose: true,
          onconnect: true,
          onerror: true,
          onlanguagechange: true,
          onmessage: true,
          onoffline: true,
          ononline: true,
          onrejectionhandled: true,
          onunhandledrejection: true,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          postMessage: true,
          Promise: false,
          queueMicrotask: false,
          removeEventListener: false,
          Request: false,
          Response: false,
          self: true,
          ServiceWorkerRegistration: false,
          setInterval: false,
          setTimeout: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false,
          WebSocket: false,
          Worker: false,
          WorkerGlobalScope: false,
          XMLHttpRequest: false
        },
        node: {
          __dirname: false,
          __filename: false,
          Buffer: false,
          clearImmediate: false,
          clearInterval: false,
          clearTimeout: false,
          console: false,
          exports: true,
          global: false,
          Intl: false,
          module: false,
          process: false,
          queueMicrotask: false,
          require: false,
          setImmediate: false,
          setInterval: false,
          setTimeout: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false
        },
        commonjs: {
          exports: true,
          global: false,
          module: false,
          require: false
        },
        amd: {
          define: false,
          require: false
        },
        mocha: {
          after: false,
          afterEach: false,
          before: false,
          beforeEach: false,
          context: false,
          describe: false,
          it: false,
          mocha: false,
          run: false,
          setup: false,
          specify: false,
          suite: false,
          suiteSetup: false,
          suiteTeardown: false,
          teardown: false,
          test: false,
          xcontext: false,
          xdescribe: false,
          xit: false,
          xspecify: false
        },
        jasmine: {
          afterAll: false,
          afterEach: false,
          beforeAll: false,
          beforeEach: false,
          describe: false,
          expect: false,
          fail: false,
          fdescribe: false,
          fit: false,
          it: false,
          jasmine: false,
          pending: false,
          runs: false,
          spyOn: false,
          spyOnProperty: false,
          waits: false,
          waitsFor: false,
          xdescribe: false,
          xit: false
        },
        jest: {
          afterAll: false,
          afterEach: false,
          beforeAll: false,
          beforeEach: false,
          describe: false,
          expect: false,
          fdescribe: false,
          fit: false,
          it: false,
          jest: false,
          pit: false,
          require: false,
          test: false,
          xdescribe: false,
          xit: false,
          xtest: false
        },
        qunit: {
          asyncTest: false,
          deepEqual: false,
          equal: false,
          expect: false,
          module: false,
          notDeepEqual: false,
          notEqual: false,
          notOk: false,
          notPropEqual: false,
          notStrictEqual: false,
          ok: false,
          propEqual: false,
          QUnit: false,
          raises: false,
          start: false,
          stop: false,
          strictEqual: false,
          test: false,
          throws: false
        },
        phantomjs: {
          console: true,
          exports: true,
          phantom: true,
          require: true,
          WebPage: true
        },
        couch: {
          emit: false,
          exports: false,
          getRow: false,
          log: false,
          module: false,
          provides: false,
          require: false,
          respond: false,
          send: false,
          start: false,
          sum: false
        },
        rhino: {
          defineClass: false,
          deserialize: false,
          gc: false,
          help: false,
          importClass: false,
          importPackage: false,
          java: false,
          load: false,
          loadClass: false,
          Packages: false,
          print: false,
          quit: false,
          readFile: false,
          readUrl: false,
          runCommand: false,
          seal: false,
          serialize: false,
          spawn: false,
          sync: false,
          toint32: false,
          version: false
        },
        nashorn: {
          __DIR__: false,
          __FILE__: false,
          __LINE__: false,
          com: false,
          edu: false,
          exit: false,
          java: false,
          Java: false,
          javafx: false,
          JavaImporter: false,
          javax: false,
          JSAdapter: false,
          load: false,
          loadWithNewGlobal: false,
          org: false,
          Packages: false,
          print: false,
          quit: false
        },
        wsh: {
          ActiveXObject: true,
          Enumerator: true,
          GetObject: true,
          ScriptEngine: true,
          ScriptEngineBuildVersion: true,
          ScriptEngineMajorVersion: true,
          ScriptEngineMinorVersion: true,
          VBArray: true,
          WScript: true,
          WSH: true,
          XDomainRequest: true
        },
        jquery: {
          $: false,
          jQuery: false
        },
        yui: {
          YAHOO: false,
          YAHOO_config: false,
          YUI: false,
          YUI_config: false
        },
        shelljs: {
          cat: false,
          cd: false,
          chmod: false,
          config: false,
          cp: false,
          dirs: false,
          echo: false,
          env: false,
          error: false,
          exec: false,
          exit: false,
          find: false,
          grep: false,
          ln: false,
          ls: false,
          mkdir: false,
          mv: false,
          popd: false,
          pushd: false,
          pwd: false,
          rm: false,
          sed: false,
          set: false,
          target: false,
          tempdir: false,
          test: false,
          touch: false,
          which: false
        },
        prototypejs: {
          $: false,
          $$: false,
          $A: false,
          $break: false,
          $continue: false,
          $F: false,
          $H: false,
          $R: false,
          $w: false,
          Abstract: false,
          Ajax: false,
          Autocompleter: false,
          Builder: false,
          Class: false,
          Control: false,
          Draggable: false,
          Draggables: false,
          Droppables: false,
          Effect: false,
          Element: false,
          Enumerable: false,
          Event: false,
          Field: false,
          Form: false,
          Hash: false,
          Insertion: false,
          ObjectRange: false,
          PeriodicalExecuter: false,
          Position: false,
          Prototype: false,
          Scriptaculous: false,
          Selector: false,
          Sortable: false,
          SortableObserver: false,
          Sound: false,
          Template: false,
          Toggle: false,
          Try: false
        },
        meteor: {
          _: false,
          $: false,
          Accounts: false,
          AccountsClient: false,
          AccountsCommon: false,
          AccountsServer: false,
          App: false,
          Assets: false,
          Blaze: false,
          check: false,
          Cordova: false,
          DDP: false,
          DDPRateLimiter: false,
          DDPServer: false,
          Deps: false,
          EJSON: false,
          Email: false,
          HTTP: false,
          Log: false,
          Match: false,
          Meteor: false,
          Mongo: false,
          MongoInternals: false,
          Npm: false,
          Package: false,
          Plugin: false,
          process: false,
          Random: false,
          ReactiveDict: false,
          ReactiveVar: false,
          Router: false,
          ServiceConfiguration: false,
          Session: false,
          share: false,
          Spacebars: false,
          Template: false,
          Tinytest: false,
          Tracker: false,
          UI: false,
          Utils: false,
          WebApp: false,
          WebAppInternals: false
        },
        mongo: {
          _isWindows: false,
          _rand: false,
          BulkWriteResult: false,
          cat: false,
          cd: false,
          connect: false,
          db: false,
          getHostName: false,
          getMemInfo: false,
          hostname: false,
          ISODate: false,
          listFiles: false,
          load: false,
          ls: false,
          md5sumFile: false,
          mkdir: false,
          Mongo: false,
          NumberInt: false,
          NumberLong: false,
          ObjectId: false,
          PlanCache: false,
          print: false,
          printjson: false,
          pwd: false,
          quit: false,
          removeFile: false,
          rs: false,
          sh: false,
          UUID: false,
          version: false,
          WriteResult: false
        },
        applescript: {
          $: false,
          Application: false,
          Automation: false,
          console: false,
          delay: false,
          Library: false,
          ObjC: false,
          ObjectSpecifier: false,
          Path: false,
          Progress: false,
          Ref: false
        },
        serviceworker: {
          addEventListener: false,
          applicationCache: false,
          atob: false,
          Blob: false,
          BroadcastChannel: false,
          btoa: false,
          Cache: false,
          caches: false,
          CacheStorage: false,
          clearInterval: false,
          clearTimeout: false,
          Client: false,
          clients: false,
          Clients: false,
          close: true,
          console: false,
          ExtendableEvent: false,
          ExtendableMessageEvent: false,
          fetch: false,
          FetchEvent: false,
          FileReaderSync: false,
          FormData: false,
          Headers: false,
          IDBCursor: false,
          IDBCursorWithValue: false,
          IDBDatabase: false,
          IDBFactory: false,
          IDBIndex: false,
          IDBKeyRange: false,
          IDBObjectStore: false,
          IDBOpenDBRequest: false,
          IDBRequest: false,
          IDBTransaction: false,
          IDBVersionChangeEvent: false,
          ImageData: false,
          importScripts: false,
          indexedDB: false,
          location: false,
          MessageChannel: false,
          MessagePort: false,
          name: false,
          navigator: false,
          Notification: false,
          onclose: true,
          onconnect: true,
          onerror: true,
          onfetch: true,
          oninstall: true,
          onlanguagechange: true,
          onmessage: true,
          onmessageerror: true,
          onnotificationclick: true,
          onnotificationclose: true,
          onoffline: true,
          ononline: true,
          onpush: true,
          onpushsubscriptionchange: true,
          onrejectionhandled: true,
          onsync: true,
          onunhandledrejection: true,
          performance: false,
          Performance: false,
          PerformanceEntry: false,
          PerformanceMark: false,
          PerformanceMeasure: false,
          PerformanceNavigation: false,
          PerformanceResourceTiming: false,
          PerformanceTiming: false,
          postMessage: true,
          Promise: false,
          queueMicrotask: false,
          registration: false,
          removeEventListener: false,
          Request: false,
          Response: false,
          self: false,
          ServiceWorker: false,
          ServiceWorkerContainer: false,
          ServiceWorkerGlobalScope: false,
          ServiceWorkerMessageEvent: false,
          ServiceWorkerRegistration: false,
          setInterval: false,
          setTimeout: false,
          skipWaiting: false,
          TextDecoder: false,
          TextEncoder: false,
          URL: false,
          URLSearchParams: false,
          WebSocket: false,
          WindowClient: false,
          Worker: false,
          WorkerGlobalScope: false,
          XMLHttpRequest: false
        },
        atomtest: {
          advanceClock: false,
          fakeClearInterval: false,
          fakeClearTimeout: false,
          fakeSetInterval: false,
          fakeSetTimeout: false,
          resetTimeouts: false,
          waitsForPromise: false
        },
        embertest: {
          andThen: false,
          click: false,
          currentPath: false,
          currentRouteName: false,
          currentURL: false,
          fillIn: false,
          find: false,
          findAll: false,
          findWithAssert: false,
          keyEvent: false,
          pauseTest: false,
          resumeTest: false,
          triggerEvent: false,
          visit: false,
          wait: false
        },
        protractor: {
          $: false,
          $$: false,
          browser: false,
          by: false,
          By: false,
          DartObject: false,
          element: false,
          protractor: false
        },
        "shared-node-browser": {
          clearInterval: false,
          clearTimeout: false,
          console: false,
          setInterval: false,
          setTimeout: false,
          URL: false,
          URLSearchParams: false
        },
        webextensions: {
          browser: false,
          chrome: false,
          opr: false
        },
        greasemonkey: {
          cloneInto: false,
          createObjectIn: false,
          exportFunction: false,
          GM: false,
          GM_addStyle: false,
          GM_deleteValue: false,
          GM_getResourceText: false,
          GM_getResourceURL: false,
          GM_getValue: false,
          GM_info: false,
          GM_listValues: false,
          GM_log: false,
          GM_openInTab: false,
          GM_registerMenuCommand: false,
          GM_setClipboard: false,
          GM_setValue: false,
          GM_xmlhttpRequest: false,
          unsafeWindow: false
        },
        devtools: {
          $: false,
          $_: false,
          $$: false,
          $0: false,
          $1: false,
          $2: false,
          $3: false,
          $4: false,
          $x: false,
          chrome: false,
          clear: false,
          copy: false,
          debug: false,
          dir: false,
          dirxml: false,
          getEventListeners: false,
          inspect: false,
          keys: false,
          monitor: false,
          monitorEvents: false,
          profile: false,
          profileEnd: false,
          queryObjects: false,
          table: false,
          undebug: false,
          unmonitor: false,
          unmonitorEvents: false,
          values: false
        }
      };
    }
  });

  // ../node_modules/globals/index.js
  var require_globals2 = __commonJS({
    "../node_modules/globals/index.js"(exports, module) {
      "use strict";
      init_inject();
      module.exports = require_globals();
    }
  });

  // ../node_modules/@babel/traverse/lib/scope/index.js
  var require_scope = __commonJS({
    "../node_modules/@babel/traverse/lib/scope/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _renamer = require_renamer();
      var _index = require_lib13();
      var _binding = require_binding();
      var _globals = require_globals2();
      var _t = require_lib3();
      var _cache = require_cache();
      var {
        NOT_LOCAL_BINDING,
        callExpression,
        cloneNode,
        getBindingIdentifiers,
        identifier,
        isArrayExpression,
        isBinary,
        isClass,
        isClassBody,
        isClassDeclaration,
        isExportAllDeclaration,
        isExportDefaultDeclaration,
        isExportNamedDeclaration,
        isFunctionDeclaration,
        isIdentifier,
        isImportDeclaration,
        isLiteral,
        isMethod,
        isModuleDeclaration,
        isModuleSpecifier,
        isNullLiteral,
        isObjectExpression,
        isProperty,
        isPureish,
        isRegExpLiteral,
        isSuper,
        isTaggedTemplateExpression,
        isTemplateLiteral,
        isThisExpression,
        isUnaryExpression,
        isVariableDeclaration,
        matchesPattern,
        memberExpression,
        numericLiteral,
        toIdentifier,
        unaryExpression,
        variableDeclaration,
        variableDeclarator,
        isRecordExpression,
        isTupleExpression,
        isObjectProperty,
        isTopicReference,
        isMetaProperty,
        isPrivateName
      } = _t;
      function gatherNodeParts(node, parts) {
        switch (node == null ? void 0 : node.type) {
          default:
            if (isModuleDeclaration(node)) {
              if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
                gatherNodeParts(node.source, parts);
              } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
                for (const e of node.specifiers)
                  gatherNodeParts(e, parts);
              } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
                gatherNodeParts(node.declaration, parts);
              }
            } else if (isModuleSpecifier(node)) {
              gatherNodeParts(node.local, parts);
            } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
              parts.push(node.value);
            }
            break;
          case "MemberExpression":
          case "OptionalMemberExpression":
          case "JSXMemberExpression":
            gatherNodeParts(node.object, parts);
            gatherNodeParts(node.property, parts);
            break;
          case "Identifier":
          case "JSXIdentifier":
            parts.push(node.name);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            gatherNodeParts(node.callee, parts);
            break;
          case "ObjectExpression":
          case "ObjectPattern":
            for (const e of node.properties) {
              gatherNodeParts(e, parts);
            }
            break;
          case "SpreadElement":
          case "RestElement":
            gatherNodeParts(node.argument, parts);
            break;
          case "ObjectProperty":
          case "ObjectMethod":
          case "ClassProperty":
          case "ClassMethod":
          case "ClassPrivateProperty":
          case "ClassPrivateMethod":
            gatherNodeParts(node.key, parts);
            break;
          case "ThisExpression":
            parts.push("this");
            break;
          case "Super":
            parts.push("super");
            break;
          case "Import":
            parts.push("import");
            break;
          case "DoExpression":
            parts.push("do");
            break;
          case "YieldExpression":
            parts.push("yield");
            gatherNodeParts(node.argument, parts);
            break;
          case "AwaitExpression":
            parts.push("await");
            gatherNodeParts(node.argument, parts);
            break;
          case "AssignmentExpression":
            gatherNodeParts(node.left, parts);
            break;
          case "VariableDeclarator":
            gatherNodeParts(node.id, parts);
            break;
          case "FunctionExpression":
          case "FunctionDeclaration":
          case "ClassExpression":
          case "ClassDeclaration":
            gatherNodeParts(node.id, parts);
            break;
          case "PrivateName":
            gatherNodeParts(node.id, parts);
            break;
          case "ParenthesizedExpression":
            gatherNodeParts(node.expression, parts);
            break;
          case "UnaryExpression":
          case "UpdateExpression":
            gatherNodeParts(node.argument, parts);
            break;
          case "MetaProperty":
            gatherNodeParts(node.meta, parts);
            gatherNodeParts(node.property, parts);
            break;
          case "JSXElement":
            gatherNodeParts(node.openingElement, parts);
            break;
          case "JSXOpeningElement":
            gatherNodeParts(node.name, parts);
            break;
          case "JSXFragment":
            gatherNodeParts(node.openingFragment, parts);
            break;
          case "JSXOpeningFragment":
            parts.push("Fragment");
            break;
          case "JSXNamespacedName":
            gatherNodeParts(node.namespace, parts);
            gatherNodeParts(node.name, parts);
            break;
        }
      }
      var collectorVisitor = {
        ForStatement(path) {
          const declar = path.get("init");
          if (declar.isVar()) {
            const {
              scope
            } = path;
            const parentScope = scope.getFunctionParent() || scope.getProgramParent();
            parentScope.registerBinding("var", declar);
          }
        },
        Declaration(path) {
          if (path.isBlockScoped())
            return;
          if (path.isImportDeclaration())
            return;
          if (path.isExportDeclaration())
            return;
          const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parent.registerDeclaration(path);
        },
        ImportDeclaration(path) {
          const parent = path.scope.getBlockParent();
          parent.registerDeclaration(path);
        },
        ReferencedIdentifier(path, state) {
          state.references.push(path);
        },
        ForXStatement(path, state) {
          const left = path.get("left");
          if (left.isPattern() || left.isIdentifier()) {
            state.constantViolations.push(path);
          } else if (left.isVar()) {
            const {
              scope
            } = path;
            const parentScope = scope.getFunctionParent() || scope.getProgramParent();
            parentScope.registerBinding("var", left);
          }
        },
        ExportDeclaration: {
          exit(path) {
            const {
              node,
              scope
            } = path;
            if (isExportAllDeclaration(node))
              return;
            const declar = node.declaration;
            if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
              const id = declar.id;
              if (!id)
                return;
              const binding = scope.getBinding(id.name);
              binding == null ? void 0 : binding.reference(path);
            } else if (isVariableDeclaration(declar)) {
              for (const decl of declar.declarations) {
                for (const name of Object.keys(getBindingIdentifiers(decl))) {
                  const binding = scope.getBinding(name);
                  binding == null ? void 0 : binding.reference(path);
                }
              }
            }
          }
        },
        LabeledStatement(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        },
        AssignmentExpression(path, state) {
          state.assignments.push(path);
        },
        UpdateExpression(path, state) {
          state.constantViolations.push(path);
        },
        UnaryExpression(path, state) {
          if (path.node.operator === "delete") {
            state.constantViolations.push(path);
          }
        },
        BlockScoped(path) {
          let scope = path.scope;
          if (scope.path === path)
            scope = scope.parent;
          const parent = scope.getBlockParent();
          parent.registerDeclaration(path);
          if (path.isClassDeclaration() && path.node.id) {
            const id = path.node.id;
            const name = id.name;
            path.scope.bindings[name] = path.scope.parent.getBinding(name);
          }
        },
        CatchClause(path) {
          path.scope.registerBinding("let", path);
        },
        Function(path) {
          const params = path.get("params");
          for (const param of params) {
            path.scope.registerBinding("param", param);
          }
          if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
            path.scope.registerBinding("local", path.get("id"), path);
          }
        },
        ClassExpression(path) {
          if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
            path.scope.registerBinding("local", path);
          }
        }
      };
      var uid = 0;
      var Scope = class {
        constructor(path) {
          this.uid = void 0;
          this.path = void 0;
          this.block = void 0;
          this.labels = void 0;
          this.inited = void 0;
          this.bindings = void 0;
          this.references = void 0;
          this.globals = void 0;
          this.uids = void 0;
          this.data = void 0;
          this.crawling = void 0;
          const {
            node
          } = path;
          const cached = _cache.scope.get(node);
          if ((cached == null ? void 0 : cached.path) === path) {
            return cached;
          }
          _cache.scope.set(node, this);
          this.uid = uid++;
          this.block = node;
          this.path = path;
          this.labels = /* @__PURE__ */ new Map();
          this.inited = false;
        }
        get parent() {
          var _parent;
          let parent, path = this.path;
          do {
            const shouldSkip = path.key === "key" || path.listKey === "decorators";
            path = path.parentPath;
            if (shouldSkip && path.isMethod())
              path = path.parentPath;
            if (path && path.isScope())
              parent = path;
          } while (path && !parent);
          return (_parent = parent) == null ? void 0 : _parent.scope;
        }
        get parentBlock() {
          return this.path.parent;
        }
        get hub() {
          return this.path.hub;
        }
        traverse(node, opts, state) {
          (0, _index.default)(node, opts, this, state, this.path);
        }
        generateDeclaredUidIdentifier(name) {
          const id = this.generateUidIdentifier(name);
          this.push({
            id
          });
          return cloneNode(id);
        }
        generateUidIdentifier(name) {
          return identifier(this.generateUid(name));
        }
        generateUid(name = "temp") {
          name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
          let uid2;
          let i = 1;
          do {
            uid2 = this._generateUid(name, i);
            i++;
          } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
          const program = this.getProgramParent();
          program.references[uid2] = true;
          program.uids[uid2] = true;
          return uid2;
        }
        _generateUid(name, i) {
          let id = name;
          if (i > 1)
            id += i;
          return `_${id}`;
        }
        generateUidBasedOnNode(node, defaultName) {
          const parts = [];
          gatherNodeParts(node, parts);
          let id = parts.join("$");
          id = id.replace(/^_/, "") || defaultName || "ref";
          return this.generateUid(id.slice(0, 20));
        }
        generateUidIdentifierBasedOnNode(node, defaultName) {
          return identifier(this.generateUidBasedOnNode(node, defaultName));
        }
        isStatic(node) {
          if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
            return true;
          }
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            if (binding) {
              return binding.constant;
            } else {
              return this.hasBinding(node.name);
            }
          }
          return false;
        }
        maybeGenerateMemoised(node, dontPush) {
          if (this.isStatic(node)) {
            return null;
          } else {
            const id = this.generateUidIdentifierBasedOnNode(node);
            if (!dontPush) {
              this.push({
                id
              });
              return cloneNode(id);
            }
            return id;
          }
        }
        checkBlockScopedCollisions(local, kind, name, id) {
          if (kind === "param")
            return;
          if (local.kind === "local")
            return;
          const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
          if (duplicate) {
            throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
          }
        }
        rename(oldName, newName, block) {
          const binding = this.getBinding(oldName);
          if (binding) {
            newName = newName || this.generateUidIdentifier(oldName).name;
            return new _renamer.default(binding, oldName, newName).rename(block);
          }
        }
        _renameFromMap(map, oldName, newName, value) {
          if (map[oldName]) {
            map[newName] = value;
            map[oldName] = null;
          }
        }
        dump() {
          const sep = "-".repeat(60);
          console.log(sep);
          let scope = this;
          do {
            console.log("#", scope.block.type);
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              console.log(" -", name, {
                constant: binding.constant,
                references: binding.references,
                violations: binding.constantViolations.length,
                kind: binding.kind
              });
            }
          } while (scope = scope.parent);
          console.log(sep);
        }
        toArray(node, i, arrayLikeIsIterable) {
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
              return node;
            }
          }
          if (isArrayExpression(node)) {
            return node;
          }
          if (isIdentifier(node, {
            name: "arguments"
          })) {
            return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
          }
          let helperName;
          const args = [node];
          if (i === true) {
            helperName = "toConsumableArray";
          } else if (i) {
            args.push(numericLiteral(i));
            helperName = "slicedToArray";
          } else {
            helperName = "toArray";
          }
          if (arrayLikeIsIterable) {
            args.unshift(this.hub.addHelper(helperName));
            helperName = "maybeArrayLike";
          }
          return callExpression(this.hub.addHelper(helperName), args);
        }
        hasLabel(name) {
          return !!this.getLabel(name);
        }
        getLabel(name) {
          return this.labels.get(name);
        }
        registerLabel(path) {
          this.labels.set(path.node.label.name, path);
        }
        registerDeclaration(path) {
          if (path.isLabeledStatement()) {
            this.registerLabel(path);
          } else if (path.isFunctionDeclaration()) {
            this.registerBinding("hoisted", path.get("id"), path);
          } else if (path.isVariableDeclaration()) {
            const declarations = path.get("declarations");
            for (const declar of declarations) {
              this.registerBinding(path.node.kind, declar);
            }
          } else if (path.isClassDeclaration()) {
            if (path.node.declare)
              return;
            this.registerBinding("let", path);
          } else if (path.isImportDeclaration()) {
            const specifiers = path.get("specifiers");
            for (const specifier of specifiers) {
              this.registerBinding("module", specifier);
            }
          } else if (path.isExportDeclaration()) {
            const declar = path.get("declaration");
            if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
              this.registerDeclaration(declar);
            }
          } else {
            this.registerBinding("unknown", path);
          }
        }
        buildUndefinedNode() {
          return unaryExpression("void", numericLiteral(0), true);
        }
        registerConstantViolation(path) {
          const ids = path.getBindingIdentifiers();
          for (const name of Object.keys(ids)) {
            const binding = this.getBinding(name);
            if (binding)
              binding.reassign(path);
          }
        }
        registerBinding(kind, path, bindingPath = path) {
          if (!kind)
            throw new ReferenceError("no `kind`");
          if (path.isVariableDeclaration()) {
            const declarators = path.get("declarations");
            for (const declar of declarators) {
              this.registerBinding(kind, declar);
            }
            return;
          }
          const parent = this.getProgramParent();
          const ids = path.getOuterBindingIdentifiers(true);
          for (const name of Object.keys(ids)) {
            parent.references[name] = true;
            for (const id of ids[name]) {
              const local = this.getOwnBinding(name);
              if (local) {
                if (local.identifier === id)
                  continue;
                this.checkBlockScopedCollisions(local, kind, name, id);
              }
              if (local) {
                this.registerConstantViolation(bindingPath);
              } else {
                this.bindings[name] = new _binding.default({
                  identifier: id,
                  scope: this,
                  path: bindingPath,
                  kind
                });
              }
            }
          }
        }
        addGlobal(node) {
          this.globals[node.name] = node;
        }
        hasUid(name) {
          let scope = this;
          do {
            if (scope.uids[name])
              return true;
          } while (scope = scope.parent);
          return false;
        }
        hasGlobal(name) {
          let scope = this;
          do {
            if (scope.globals[name])
              return true;
          } while (scope = scope.parent);
          return false;
        }
        hasReference(name) {
          return !!this.getProgramParent().references[name];
        }
        isPure(node, constantsOnly) {
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            if (!binding)
              return false;
            if (constantsOnly)
              return binding.constant;
            return true;
          } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
            return true;
          } else if (isClass(node)) {
            var _node$decorators;
            if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
              return false;
            }
            if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
              return false;
            }
            return this.isPure(node.body, constantsOnly);
          } else if (isClassBody(node)) {
            for (const method of node.body) {
              if (!this.isPure(method, constantsOnly))
                return false;
            }
            return true;
          } else if (isBinary(node)) {
            return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
          } else if (isArrayExpression(node) || isTupleExpression(node)) {
            for (const elem of node.elements) {
              if (elem !== null && !this.isPure(elem, constantsOnly))
                return false;
            }
            return true;
          } else if (isObjectExpression(node) || isRecordExpression(node)) {
            for (const prop of node.properties) {
              if (!this.isPure(prop, constantsOnly))
                return false;
            }
            return true;
          } else if (isMethod(node)) {
            var _node$decorators2;
            if (node.computed && !this.isPure(node.key, constantsOnly))
              return false;
            if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
              return false;
            }
            return true;
          } else if (isProperty(node)) {
            var _node$decorators3;
            if (node.computed && !this.isPure(node.key, constantsOnly))
              return false;
            if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
              return false;
            }
            if (isObjectProperty(node) || node.static) {
              if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
                return false;
              }
            }
            return true;
          } else if (isUnaryExpression(node)) {
            return this.isPure(node.argument, constantsOnly);
          } else if (isTaggedTemplateExpression(node)) {
            return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
          } else if (isTemplateLiteral(node)) {
            for (const expression of node.expressions) {
              if (!this.isPure(expression, constantsOnly))
                return false;
            }
            return true;
          } else {
            return isPureish(node);
          }
        }
        setData(key, val) {
          return this.data[key] = val;
        }
        getData(key) {
          let scope = this;
          do {
            const data = scope.data[key];
            if (data != null)
              return data;
          } while (scope = scope.parent);
        }
        removeData(key) {
          let scope = this;
          do {
            const data = scope.data[key];
            if (data != null)
              scope.data[key] = null;
          } while (scope = scope.parent);
        }
        init() {
          if (!this.inited) {
            this.inited = true;
            this.crawl();
          }
        }
        crawl() {
          const path = this.path;
          this.references = /* @__PURE__ */ Object.create(null);
          this.bindings = /* @__PURE__ */ Object.create(null);
          this.globals = /* @__PURE__ */ Object.create(null);
          this.uids = /* @__PURE__ */ Object.create(null);
          this.data = /* @__PURE__ */ Object.create(null);
          const programParent = this.getProgramParent();
          if (programParent.crawling)
            return;
          const state = {
            references: [],
            constantViolations: [],
            assignments: []
          };
          this.crawling = true;
          if (path.type !== "Program" && collectorVisitor._exploded) {
            for (const visit of collectorVisitor.enter) {
              visit(path, state);
            }
            const typeVisitors = collectorVisitor[path.type];
            if (typeVisitors) {
              for (const visit of typeVisitors.enter) {
                visit(path, state);
              }
            }
          }
          path.traverse(collectorVisitor, state);
          this.crawling = false;
          for (const path2 of state.assignments) {
            const ids = path2.getBindingIdentifiers();
            for (const name of Object.keys(ids)) {
              if (path2.scope.getBinding(name))
                continue;
              programParent.addGlobal(ids[name]);
            }
            path2.scope.registerConstantViolation(path2);
          }
          for (const ref of state.references) {
            const binding = ref.scope.getBinding(ref.node.name);
            if (binding) {
              binding.reference(ref);
            } else {
              programParent.addGlobal(ref.node);
            }
          }
          for (const path2 of state.constantViolations) {
            path2.scope.registerConstantViolation(path2);
          }
        }
        push(opts) {
          let path = this.path;
          if (path.isPattern()) {
            path = this.getPatternParent().path;
          } else if (!path.isBlockStatement() && !path.isProgram()) {
            path = this.getBlockParent().path;
          }
          if (path.isSwitchStatement()) {
            path = (this.getFunctionParent() || this.getProgramParent()).path;
          }
          if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
            path.ensureBlock();
            path = path.get("body");
          }
          const unique = opts.unique;
          const kind = opts.kind || "var";
          const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
          const dataKey = `declaration:${kind}:${blockHoist}`;
          let declarPath = !unique && path.getData(dataKey);
          if (!declarPath) {
            const declar = variableDeclaration(kind, []);
            declar._blockHoist = blockHoist;
            [declarPath] = path.unshiftContainer("body", [declar]);
            if (!unique)
              path.setData(dataKey, declarPath);
          }
          const declarator = variableDeclarator(opts.id, opts.init);
          const len = declarPath.node.declarations.push(declarator);
          path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
        }
        getProgramParent() {
          let scope = this;
          do {
            if (scope.path.isProgram()) {
              return scope;
            }
          } while (scope = scope.parent);
          throw new Error("Couldn't find a Program");
        }
        getFunctionParent() {
          let scope = this;
          do {
            if (scope.path.isFunctionParent()) {
              return scope;
            }
          } while (scope = scope.parent);
          return null;
        }
        getBlockParent() {
          let scope = this;
          do {
            if (scope.path.isBlockParent()) {
              return scope;
            }
          } while (scope = scope.parent);
          throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }
        getPatternParent() {
          let scope = this;
          do {
            if (!scope.path.isPattern()) {
              return scope.getBlockParent();
            }
          } while (scope = scope.parent.parent);
          throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }
        getAllBindings() {
          const ids = /* @__PURE__ */ Object.create(null);
          let scope = this;
          do {
            for (const key of Object.keys(scope.bindings)) {
              if (key in ids === false) {
                ids[key] = scope.bindings[key];
              }
            }
            scope = scope.parent;
          } while (scope);
          return ids;
        }
        getAllBindingsOfKind(...kinds) {
          const ids = /* @__PURE__ */ Object.create(null);
          for (const kind of kinds) {
            let scope = this;
            do {
              for (const name of Object.keys(scope.bindings)) {
                const binding = scope.bindings[name];
                if (binding.kind === kind)
                  ids[name] = binding;
              }
              scope = scope.parent;
            } while (scope);
          }
          return ids;
        }
        bindingIdentifierEquals(name, node) {
          return this.getBindingIdentifier(name) === node;
        }
        getBinding(name) {
          let scope = this;
          let previousPath;
          do {
            const binding = scope.getOwnBinding(name);
            if (binding) {
              var _previousPath;
              if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
              } else {
                return binding;
              }
            } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
            previousPath = scope.path;
          } while (scope = scope.parent);
        }
        getOwnBinding(name) {
          return this.bindings[name];
        }
        getBindingIdentifier(name) {
          var _this$getBinding;
          return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
        }
        getOwnBindingIdentifier(name) {
          const binding = this.bindings[name];
          return binding == null ? void 0 : binding.identifier;
        }
        hasOwnBinding(name) {
          return !!this.getOwnBinding(name);
        }
        hasBinding(name, noGlobals) {
          if (!name)
            return false;
          if (this.hasOwnBinding(name))
            return true;
          if (this.parentHasBinding(name, noGlobals))
            return true;
          if (this.hasUid(name))
            return true;
          if (!noGlobals && Scope.globals.includes(name))
            return true;
          if (!noGlobals && Scope.contextVariables.includes(name))
            return true;
          return false;
        }
        parentHasBinding(name, noGlobals) {
          var _this$parent;
          return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
        }
        moveBindingTo(name, scope) {
          const info = this.getBinding(name);
          if (info) {
            info.scope.removeOwnBinding(name);
            info.scope = scope;
            scope.bindings[name] = info;
          }
        }
        removeOwnBinding(name) {
          delete this.bindings[name];
        }
        removeBinding(name) {
          var _this$getBinding2;
          (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
          let scope = this;
          do {
            if (scope.uids[name]) {
              scope.uids[name] = false;
            }
          } while (scope = scope.parent);
        }
      };
      exports.default = Scope;
      Scope.globals = Object.keys(_globals.builtin);
      Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    }
  });

  // ../node_modules/@babel/traverse/lib/path/ancestry.js
  var require_ancestry = __commonJS({
    "../node_modules/@babel/traverse/lib/path/ancestry.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.find = find;
      exports.findParent = findParent;
      exports.getAncestry = getAncestry;
      exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
      exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
      exports.getFunctionParent = getFunctionParent;
      exports.getStatementParent = getStatementParent;
      exports.inType = inType;
      exports.isAncestor = isAncestor;
      exports.isDescendant = isDescendant;
      var _t = require_lib3();
      var _index = require_path();
      var {
        VISITOR_KEYS
      } = _t;
      function findParent(callback) {
        let path = this;
        while (path = path.parentPath) {
          if (callback(path))
            return path;
        }
        return null;
      }
      function find(callback) {
        let path = this;
        do {
          if (callback(path))
            return path;
        } while (path = path.parentPath);
        return null;
      }
      function getFunctionParent() {
        return this.findParent((p) => p.isFunction());
      }
      function getStatementParent() {
        let path = this;
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            break;
          } else {
            path = path.parentPath;
          }
        } while (path);
        if (path && (path.isProgram() || path.isFile())) {
          throw new Error("File/Program node, we can't possibly find a statement parent to this");
        }
        return path;
      }
      function getEarliestCommonAncestorFrom(paths) {
        return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
          let earliest;
          const keys = VISITOR_KEYS[deepest.type];
          for (const ancestry of ancestries) {
            const path = ancestry[i + 1];
            if (!earliest) {
              earliest = path;
              continue;
            }
            if (path.listKey && earliest.listKey === path.listKey) {
              if (path.key < earliest.key) {
                earliest = path;
                continue;
              }
            }
            const earliestKeyIndex = keys.indexOf(earliest.parentKey);
            const currentKeyIndex = keys.indexOf(path.parentKey);
            if (earliestKeyIndex > currentKeyIndex) {
              earliest = path;
            }
          }
          return earliest;
        });
      }
      function getDeepestCommonAncestorFrom(paths, filter2) {
        if (!paths.length) {
          return this;
        }
        if (paths.length === 1) {
          return paths[0];
        }
        let minDepth = Infinity;
        let lastCommonIndex, lastCommon;
        const ancestries = paths.map((path) => {
          const ancestry = [];
          do {
            ancestry.unshift(path);
          } while ((path = path.parentPath) && path !== this);
          if (ancestry.length < minDepth) {
            minDepth = ancestry.length;
          }
          return ancestry;
        });
        const first = ancestries[0];
        depthLoop:
          for (let i = 0; i < minDepth; i++) {
            const shouldMatch = first[i];
            for (const ancestry of ancestries) {
              if (ancestry[i] !== shouldMatch) {
                break depthLoop;
              }
            }
            lastCommonIndex = i;
            lastCommon = shouldMatch;
          }
        if (lastCommon) {
          if (filter2) {
            return filter2(lastCommon, lastCommonIndex, ancestries);
          } else {
            return lastCommon;
          }
        } else {
          throw new Error("Couldn't find intersection");
        }
      }
      function getAncestry() {
        let path = this;
        const paths = [];
        do {
          paths.push(path);
        } while (path = path.parentPath);
        return paths;
      }
      function isAncestor(maybeDescendant) {
        return maybeDescendant.isDescendant(this);
      }
      function isDescendant(maybeAncestor) {
        return !!this.findParent((parent) => parent === maybeAncestor);
      }
      function inType(...candidateTypes) {
        let path = this;
        while (path) {
          for (const type of candidateTypes) {
            if (path.node.type === type)
              return true;
          }
          path = path.parentPath;
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/inference/util.js
  var require_util = __commonJS({
    "../node_modules/@babel/traverse/lib/path/inference/util.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnionType = createUnionType;
      var _t = require_lib3();
      var {
        createFlowUnionType,
        createTSUnionType,
        createUnionTypeAnnotation,
        isFlowType,
        isTSType
      } = _t;
      function createUnionType(types) {
        {
          if (isFlowType(types[0])) {
            if (createFlowUnionType) {
              return createFlowUnionType(types);
            }
            return createUnionTypeAnnotation(types);
          } else {
            if (createTSUnionType) {
              return createTSUnionType(types);
            }
          }
        }
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
  var require_inferer_reference = __commonJS({
    "../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = _default;
      var _t = require_lib3();
      var _util = require_util();
      var {
        BOOLEAN_NUMBER_BINARY_OPERATORS,
        createTypeAnnotationBasedOnTypeof,
        numberTypeAnnotation,
        voidTypeAnnotation
      } = _t;
      function _default(node) {
        if (!this.isReferenced())
          return;
        const binding = this.scope.getBinding(node.name);
        if (binding) {
          if (binding.identifier.typeAnnotation) {
            return binding.identifier.typeAnnotation;
          } else {
            return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
          }
        }
        if (node.name === "undefined") {
          return voidTypeAnnotation();
        } else if (node.name === "NaN" || node.name === "Infinity") {
          return numberTypeAnnotation();
        } else if (node.name === "arguments") {
        }
      }
      function getTypeAnnotationBindingConstantViolations(binding, path, name) {
        const types = [];
        const functionConstantViolations = [];
        let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
        const testType = getConditionalAnnotation(binding, path, name);
        if (testType) {
          const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
          constantViolations = constantViolations.filter((path2) => testConstantViolations.indexOf(path2) < 0);
          types.push(testType.typeAnnotation);
        }
        if (constantViolations.length) {
          constantViolations.push(...functionConstantViolations);
          for (const violation of constantViolations) {
            types.push(violation.getTypeAnnotation());
          }
        }
        if (!types.length) {
          return;
        }
        return (0, _util.createUnionType)(types);
      }
      function getConstantViolationsBefore(binding, path, functions) {
        const violations = binding.constantViolations.slice();
        violations.unshift(binding.path);
        return violations.filter((violation) => {
          violation = violation.resolve();
          const status = violation._guessExecutionStatusRelativeTo(path);
          if (functions && status === "unknown")
            functions.push(violation);
          return status === "before";
        });
      }
      function inferAnnotationFromBinaryExpression(name, path) {
        const operator = path.node.operator;
        const right = path.get("right").resolve();
        const left = path.get("left").resolve();
        let target;
        if (left.isIdentifier({
          name
        })) {
          target = right;
        } else if (right.isIdentifier({
          name
        })) {
          target = left;
        }
        if (target) {
          if (operator === "===") {
            return target.getTypeAnnotation();
          }
          if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
            return numberTypeAnnotation();
          }
          return;
        }
        if (operator !== "===" && operator !== "==")
          return;
        let typeofPath;
        let typePath;
        if (left.isUnaryExpression({
          operator: "typeof"
        })) {
          typeofPath = left;
          typePath = right;
        } else if (right.isUnaryExpression({
          operator: "typeof"
        })) {
          typeofPath = right;
          typePath = left;
        }
        if (!typeofPath)
          return;
        if (!typeofPath.get("argument").isIdentifier({
          name
        }))
          return;
        typePath = typePath.resolve();
        if (!typePath.isLiteral())
          return;
        const typeValue = typePath.node.value;
        if (typeof typeValue !== "string")
          return;
        return createTypeAnnotationBasedOnTypeof(typeValue);
      }
      function getParentConditionalPath(binding, path, name) {
        let parentPath;
        while (parentPath = path.parentPath) {
          if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
            if (path.key === "test") {
              return;
            }
            return parentPath;
          }
          if (parentPath.isFunction()) {
            if (parentPath.parentPath.scope.getBinding(name) !== binding)
              return;
          }
          path = parentPath;
        }
      }
      function getConditionalAnnotation(binding, path, name) {
        const ifStatement = getParentConditionalPath(binding, path, name);
        if (!ifStatement)
          return;
        const test = ifStatement.get("test");
        const paths = [test];
        const types = [];
        for (let i = 0; i < paths.length; i++) {
          const path2 = paths[i];
          if (path2.isLogicalExpression()) {
            if (path2.node.operator === "&&") {
              paths.push(path2.get("left"));
              paths.push(path2.get("right"));
            }
          } else if (path2.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name, path2);
            if (type)
              types.push(type);
          }
        }
        if (types.length) {
          return {
            typeAnnotation: (0, _util.createUnionType)(types),
            ifStatement
          };
        }
        return getConditionalAnnotation(binding, ifStatement, name);
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/inference/inferers.js
  var require_inferers = __commonJS({
    "../node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrayExpression = ArrayExpression;
      exports.AssignmentExpression = AssignmentExpression;
      exports.BinaryExpression = BinaryExpression;
      exports.BooleanLiteral = BooleanLiteral;
      exports.CallExpression = CallExpression;
      exports.ConditionalExpression = ConditionalExpression;
      exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
      Object.defineProperty(exports, "Identifier", {
        enumerable: true,
        get: function() {
          return _infererReference.default;
        }
      });
      exports.LogicalExpression = LogicalExpression;
      exports.NewExpression = NewExpression;
      exports.NullLiteral = NullLiteral;
      exports.NumericLiteral = NumericLiteral;
      exports.ObjectExpression = ObjectExpression;
      exports.ParenthesizedExpression = ParenthesizedExpression;
      exports.RegExpLiteral = RegExpLiteral;
      exports.RestElement = RestElement;
      exports.SequenceExpression = SequenceExpression;
      exports.StringLiteral = StringLiteral;
      exports.TSAsExpression = TSAsExpression;
      exports.TSNonNullExpression = TSNonNullExpression;
      exports.TaggedTemplateExpression = TaggedTemplateExpression;
      exports.TemplateLiteral = TemplateLiteral;
      exports.TypeCastExpression = TypeCastExpression;
      exports.UnaryExpression = UnaryExpression;
      exports.UpdateExpression = UpdateExpression;
      exports.VariableDeclarator = VariableDeclarator;
      var _t = require_lib3();
      var _infererReference = require_inferer_reference();
      var _util = require_util();
      var {
        BOOLEAN_BINARY_OPERATORS,
        BOOLEAN_UNARY_OPERATORS,
        NUMBER_BINARY_OPERATORS,
        NUMBER_UNARY_OPERATORS,
        STRING_UNARY_OPERATORS,
        anyTypeAnnotation,
        arrayTypeAnnotation,
        booleanTypeAnnotation,
        buildMatchMemberExpression,
        genericTypeAnnotation,
        identifier,
        nullLiteralTypeAnnotation,
        numberTypeAnnotation,
        stringTypeAnnotation,
        tupleTypeAnnotation,
        unionTypeAnnotation,
        voidTypeAnnotation,
        isIdentifier
      } = _t;
      function VariableDeclarator() {
        if (!this.get("id").isIdentifier())
          return;
        return this.get("init").getTypeAnnotation();
      }
      function TypeCastExpression(node) {
        return node.typeAnnotation;
      }
      TypeCastExpression.validParent = true;
      function TSAsExpression(node) {
        return node.typeAnnotation;
      }
      TSAsExpression.validParent = true;
      function TSNonNullExpression() {
        return this.get("expression").getTypeAnnotation();
      }
      function NewExpression(node) {
        if (node.callee.type === "Identifier") {
          return genericTypeAnnotation(node.callee);
        }
      }
      function TemplateLiteral() {
        return stringTypeAnnotation();
      }
      function UnaryExpression(node) {
        const operator = node.operator;
        if (operator === "void") {
          return voidTypeAnnotation();
        } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return numberTypeAnnotation();
        } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return stringTypeAnnotation();
        } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
          return booleanTypeAnnotation();
        }
      }
      function BinaryExpression(node) {
        const operator = node.operator;
        if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return numberTypeAnnotation();
        } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return booleanTypeAnnotation();
        } else if (operator === "+") {
          const right = this.get("right");
          const left = this.get("left");
          if (left.isBaseType("number") && right.isBaseType("number")) {
            return numberTypeAnnotation();
          } else if (left.isBaseType("string") || right.isBaseType("string")) {
            return stringTypeAnnotation();
          }
          return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
        }
      }
      function LogicalExpression() {
        const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
        return (0, _util.createUnionType)(argumentTypes);
      }
      function ConditionalExpression() {
        const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
        return (0, _util.createUnionType)(argumentTypes);
      }
      function SequenceExpression() {
        return this.get("expressions").pop().getTypeAnnotation();
      }
      function ParenthesizedExpression() {
        return this.get("expression").getTypeAnnotation();
      }
      function AssignmentExpression() {
        return this.get("right").getTypeAnnotation();
      }
      function UpdateExpression(node) {
        const operator = node.operator;
        if (operator === "++" || operator === "--") {
          return numberTypeAnnotation();
        }
      }
      function StringLiteral() {
        return stringTypeAnnotation();
      }
      function NumericLiteral() {
        return numberTypeAnnotation();
      }
      function BooleanLiteral() {
        return booleanTypeAnnotation();
      }
      function NullLiteral() {
        return nullLiteralTypeAnnotation();
      }
      function RegExpLiteral() {
        return genericTypeAnnotation(identifier("RegExp"));
      }
      function ObjectExpression() {
        return genericTypeAnnotation(identifier("Object"));
      }
      function ArrayExpression() {
        return genericTypeAnnotation(identifier("Array"));
      }
      function RestElement() {
        return ArrayExpression();
      }
      RestElement.validParent = true;
      function Func() {
        return genericTypeAnnotation(identifier("Function"));
      }
      var isArrayFrom = buildMatchMemberExpression("Array.from");
      var isObjectKeys = buildMatchMemberExpression("Object.keys");
      var isObjectValues = buildMatchMemberExpression("Object.values");
      var isObjectEntries = buildMatchMemberExpression("Object.entries");
      function CallExpression() {
        const {
          callee
        } = this.node;
        if (isObjectKeys(callee)) {
          return arrayTypeAnnotation(stringTypeAnnotation());
        } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
          name: "Array"
        })) {
          return arrayTypeAnnotation(anyTypeAnnotation());
        } else if (isObjectEntries(callee)) {
          return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
        }
        return resolveCall(this.get("callee"));
      }
      function TaggedTemplateExpression() {
        return resolveCall(this.get("tag"));
      }
      function resolveCall(callee) {
        callee = callee.resolve();
        if (callee.isFunction()) {
          const {
            node
          } = callee;
          if (node.async) {
            if (node.generator) {
              return genericTypeAnnotation(identifier("AsyncIterator"));
            } else {
              return genericTypeAnnotation(identifier("Promise"));
            }
          } else {
            if (node.generator) {
              return genericTypeAnnotation(identifier("Iterator"));
            } else if (callee.node.returnType) {
              return callee.node.returnType;
            } else {
            }
          }
        }
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/inference/index.js
  var require_inference = __commonJS({
    "../node_modules/@babel/traverse/lib/path/inference/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._getTypeAnnotation = _getTypeAnnotation;
      exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
      exports.couldBeBaseType = couldBeBaseType;
      exports.getTypeAnnotation = getTypeAnnotation;
      exports.isBaseType = isBaseType;
      exports.isGenericType = isGenericType;
      var inferers = require_inferers();
      var _t = require_lib3();
      var {
        anyTypeAnnotation,
        isAnyTypeAnnotation,
        isArrayTypeAnnotation,
        isBooleanTypeAnnotation,
        isEmptyTypeAnnotation,
        isFlowBaseAnnotation,
        isGenericTypeAnnotation,
        isIdentifier,
        isMixedTypeAnnotation,
        isNumberTypeAnnotation,
        isStringTypeAnnotation,
        isTSArrayType,
        isTSTypeAnnotation,
        isTSTypeReference,
        isTupleTypeAnnotation,
        isTypeAnnotation,
        isUnionTypeAnnotation,
        isVoidTypeAnnotation,
        stringTypeAnnotation,
        voidTypeAnnotation
      } = _t;
      function getTypeAnnotation() {
        let type = this.getData("typeAnnotation");
        if (type != null) {
          return type;
        }
        type = this._getTypeAnnotation() || anyTypeAnnotation();
        if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
          type = type.typeAnnotation;
        }
        this.setData("typeAnnotation", type);
        return type;
      }
      var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
      function _getTypeAnnotation() {
        const node = this.node;
        if (!node) {
          if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
            const declar = this.parentPath.parentPath;
            const declarParent = declar.parentPath;
            if (declar.key === "left" && declarParent.isForInStatement()) {
              return stringTypeAnnotation();
            }
            if (declar.key === "left" && declarParent.isForOfStatement()) {
              return anyTypeAnnotation();
            }
            return voidTypeAnnotation();
          } else {
            return;
          }
        }
        if (node.typeAnnotation) {
          return node.typeAnnotation;
        }
        if (typeAnnotationInferringNodes.has(node)) {
          return;
        }
        typeAnnotationInferringNodes.add(node);
        try {
          var _inferer;
          let inferer = inferers[node.type];
          if (inferer) {
            return inferer.call(this, node);
          }
          inferer = inferers[this.parentPath.type];
          if ((_inferer = inferer) != null && _inferer.validParent) {
            return this.parentPath.getTypeAnnotation();
          }
        } finally {
          typeAnnotationInferringNodes.delete(node);
        }
      }
      function isBaseType(baseName, soft) {
        return _isBaseType(baseName, this.getTypeAnnotation(), soft);
      }
      function _isBaseType(baseName, type, soft) {
        if (baseName === "string") {
          return isStringTypeAnnotation(type);
        } else if (baseName === "number") {
          return isNumberTypeAnnotation(type);
        } else if (baseName === "boolean") {
          return isBooleanTypeAnnotation(type);
        } else if (baseName === "any") {
          return isAnyTypeAnnotation(type);
        } else if (baseName === "mixed") {
          return isMixedTypeAnnotation(type);
        } else if (baseName === "empty") {
          return isEmptyTypeAnnotation(type);
        } else if (baseName === "void") {
          return isVoidTypeAnnotation(type);
        } else {
          if (soft) {
            return false;
          } else {
            throw new Error(`Unknown base type ${baseName}`);
          }
        }
      }
      function couldBeBaseType(name) {
        const type = this.getTypeAnnotation();
        if (isAnyTypeAnnotation(type))
          return true;
        if (isUnionTypeAnnotation(type)) {
          for (const type2 of type.types) {
            if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
              return true;
            }
          }
          return false;
        } else {
          return _isBaseType(name, type, true);
        }
      }
      function baseTypeStrictlyMatches(rightArg) {
        const left = this.getTypeAnnotation();
        const right = rightArg.getTypeAnnotation();
        if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
          return right.type === left.type;
        }
        return false;
      }
      function isGenericType(genericName) {
        const type = this.getTypeAnnotation();
        if (genericName === "Array") {
          if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
            return true;
          }
        }
        return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
          name: genericName
        }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
          name: genericName
        });
      }
    }
  });

  // ../node_modules/js-tokens/index.js
  var require_js_tokens = __commonJS({
    "../node_modules/js-tokens/index.js"(exports) {
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
      exports.matchToToken = function(match) {
        var token = { type: "invalid", value: match[0], closed: void 0 };
        if (match[1])
          token.type = "string", token.closed = !!(match[3] || match[4]);
        else if (match[5])
          token.type = "comment";
        else if (match[6])
          token.type = "comment", token.closed = !!match[7];
        else if (match[8])
          token.type = "regex";
        else if (match[9])
          token.type = "number";
        else if (match[10])
          token.type = "name";
        else if (match[11])
          token.type = "punctuator";
        else if (match[12])
          token.type = "whitespace";
        return token;
      };
    }
  });

  // ../node_modules/escape-string-regexp/index.js
  var require_escape_string_regexp = __commonJS({
    "../node_modules/escape-string-regexp/index.js"(exports, module) {
      "use strict";
      init_inject();
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      module.exports = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
    }
  });

  // ../node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../node_modules/color-name/index.js"(exports, module) {
      "use strict";
      init_inject();
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "../node_modules/color-convert/conversions.js"(exports, module) {
      init_inject();
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
      }
      var key;
      var convert = module.exports = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      for (model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!("channels" in convert[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          channels = convert[model].channels;
          labels = convert[model].labels;
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], "channels", { value: channels });
          Object.defineProperty(convert[model], "labels", { value: labels });
        }
      }
      var channels;
      var labels;
      var model;
      convert.rgb.hsl = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h;
        var s;
        var l;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
      };
      convert.rgb.hsv = function(rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h;
        var s;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);
        var diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h = convert.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }
      convert.rgb.keyword = function(rgb) {
        var reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        var currentClosestDistance = Infinity;
        var currentClosestKeyword;
        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword];
            var distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        var xyz = convert.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.hsl.rgb = function(hsl) {
        var h = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t2;
        var t3;
        var rgb;
        var val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        var h = hsl[0];
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert.hsv.rgb = function(hsv) {
        var h = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h) % 6;
        var f = h - Math.floor(h);
        var p = 255 * v * (1 - s);
        var q = 255 * v * (1 - s * f);
        var t2 = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t2, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t2];
          case 3:
            return [p, q, v];
          case 4:
            return [t2, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        var h = hsv[0];
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s) * v;
        lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert.hwb.rgb = function(hwb) {
        var h = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i;
        var v;
        var f;
        var n;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        i = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        n = wh + f * (v - wh);
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.rgb = function(xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.lab = function(xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.lab.xyz = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert.lab.lch = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h;
        var c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert.lch.lab = function(lch) {
        var l = lch[0];
        var c = lch[1];
        var h = lch[2];
        var a;
        var b;
        var hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert.rgb.ansi16 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        var color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert.rgb.hex = function(args) {
        var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        var colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map(function(char) {
            return char + char;
          }).join("");
        }
        var integer = parseInt(colorString, 16);
        var r = integer >> 16 & 255;
        var g = integer >> 8 & 255;
        var b = integer & 255;
        return [r, g, b];
      };
      convert.rgb.hcg = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;
        if (l < 0.5) {
          c = 2 * s * l;
        } else {
          c = 2 * s * (1 - l);
        }
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert.hsv.hcg = function(hsv) {
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s * v;
        var f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert.hcg.rgb = function(hcg) {
        var h = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        var pure = [0, 0, 0];
        var hi = h % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        var f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert.hcg.hsl = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1 - c) + 0.5 * c;
        var s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert.hcg.hwb = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = convert.gray.hsv = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        var val = Math.round(gray[0] / 100 * 255) & 255;
        var integer = (val << 16) + (val << 8) + val;
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../node_modules/color-convert/route.js
  var require_route = __commonJS({
    "../node_modules/color-convert/route.js"(exports, module) {
      init_inject();
      var conversions = require_conversions();
      function buildGraph() {
        var graph = {};
        var models = Object.keys(conversions);
        for (var len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        var graph = buildGraph();
        var queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          var current = queue.pop();
          var adjacents = Object.keys(conversions[current]);
          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i];
            var node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel];
        var fn = conversions[graph[toModel].parent][toModel];
        var cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        var graph = deriveBFS(fromModel);
        var conversion = {};
        var models = Object.keys(graph);
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i];
          var node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "../node_modules/color-convert/index.js"(exports, module) {
      init_inject();
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          var result = fn(args);
          if (typeof result === "object") {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach(function(fromModel) {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        var routes = route(fromModel);
        var routeModels = Object.keys(routes);
        routeModels.forEach(function(toModel) {
          var fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // ../node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "../node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      init_inject();
      var colorConvert = require_color_convert();
      var wrapAnsi16 = (fn, offset) => function() {
        const code = fn.apply(colorConvert, arguments);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => function() {
        const code = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => function() {
        const rgb = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.grey = styles.color.gray;
        for (const groupName of Object.keys(styles)) {
          const group = styles[groupName];
          for (const styleName of Object.keys(group)) {
            const style = group[styleName];
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
        }
        const ansi2ansi = (n) => n;
        const rgb2rgb = (r, g, b) => [r, g, b];
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0)
        };
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0)
        };
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0)
        };
        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10)
        };
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10)
        };
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10)
        };
        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== "object") {
            continue;
          }
          const suite = colorConvert[key];
          if (key === "ansi16") {
            key = "ansi";
          }
          if ("ansi16" in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
          }
          if ("ansi256" in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
          }
          if ("rgb" in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
          }
        }
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // ../node_modules/supports-color/browser.js
  var require_browser2 = __commonJS({
    "../node_modules/supports-color/browser.js"(exports, module) {
      "use strict";
      init_inject();
      module.exports = {
        stdout: false,
        stderr: false
      };
    }
  });

  // ../node_modules/chalk/templates.js
  var require_templates = __commonJS({
    "../node_modules/chalk/templates.js"(exports, module) {
      "use strict";
      init_inject();
      var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, args) {
        const results = [];
        const chunks = args.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk));
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape(escape2) : chr));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk;
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName]);
            } else {
              current = current[styleName];
            }
          }
        }
        return current;
      }
      module.exports = (chalk, tmp) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
          if (escapeChar) {
            chunk.push(unescape(escapeChar));
          } else if (style) {
            const str = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(chr);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMsg);
        }
        return chunks.join("");
      };
    }
  });

  // ../node_modules/chalk/index.js
  var require_chalk = __commonJS({
    "../node_modules/chalk/index.js"(exports, module) {
      "use strict";
      init_inject();
      var escapeStringRegexp = require_escape_string_regexp();
      var ansiStyles = require_ansi_styles();
      var stdoutColor = require_browser2().stdout;
      var template2 = require_templates();
      var isSimpleWindowsTerm = false;
      var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
      var skipModels = /* @__PURE__ */ new Set(["gray"]);
      var styles = /* @__PURE__ */ Object.create(null);
      function applyOptions(obj, options) {
        options = options || {};
        const scLevel = stdoutColor ? stdoutColor.level : 0;
        obj.level = options.level === void 0 ? scLevel : options.level;
        obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
      }
      function Chalk(options) {
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk = {};
          applyOptions(chalk, options);
          chalk.template = function() {
            const args = [].slice.call(arguments);
            return chalkTag.apply(null, [chalk.template].concat(args));
          };
          Object.setPrototypeOf(chalk, Chalk.prototype);
          Object.setPrototypeOf(chalk.template, chalk);
          chalk.template.constructor = Chalk;
          return chalk.template;
        }
        applyOptions(this, options);
      }
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = "\x1B[94m";
      }
      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        styles[key] = {
          get() {
            const codes = ansiStyles[key];
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
          }
        };
      }
      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, "visible");
        }
      };
      ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        styles[model] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, styles);
      function build(_styles, _empty, key) {
        const builder = function() {
          return applyStyle.apply(builder, arguments);
        };
        builder._styles = _styles;
        builder._empty = _empty;
        const self2 = this;
        Object.defineProperty(builder, "level", {
          enumerable: true,
          get() {
            return self2.level;
          },
          set(level) {
            self2.level = level;
          }
        });
        Object.defineProperty(builder, "enabled", {
          enumerable: true,
          get() {
            return self2.enabled;
          },
          set(enabled) {
            self2.enabled = enabled;
          }
        });
        builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
        builder.__proto__ = proto;
        return builder;
      }
      function applyStyle() {
        const args = arguments;
        const argsLen = args.length;
        let str = String(arguments[0]);
        if (argsLen === 0) {
          return "";
        }
        if (argsLen > 1) {
          for (let a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? "" : str;
        }
        const originalDim = ansiStyles.dim.open;
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = "";
        }
        for (const code of this._styles.slice().reverse()) {
          str = code.open + str.replace(code.closeRe, code.open) + code.close;
          str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
        }
        ansiStyles.dim.open = originalDim;
        return str;
      }
      function chalkTag(chalk, strings) {
        if (!Array.isArray(strings)) {
          return [].slice.call(arguments, 1).join(" ");
        }
        const args = [].slice.call(arguments, 2);
        const parts = [strings.raw[0]];
        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
          parts.push(String(strings.raw[i]));
        }
        return template2(chalk, parts.join(""));
      }
      Object.defineProperties(Chalk.prototype, styles);
      module.exports = Chalk();
      module.exports.supportsColor = stdoutColor;
      module.exports.default = module.exports;
    }
  });

  // ../node_modules/@babel/highlight/lib/index.js
  var require_lib8 = __commonJS({
    "../node_modules/@babel/highlight/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = highlight;
      exports.getChalk = getChalk;
      exports.shouldHighlight = shouldHighlight;
      var _jsTokens = require_js_tokens();
      var _helperValidatorIdentifier = require_lib();
      var _chalk = require_chalk();
      var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
      function getDefs(chalk) {
        return {
          keyword: chalk.cyan,
          capitalized: chalk.yellow,
          jsxIdentifier: chalk.yellow,
          punctuator: chalk.yellow,
          number: chalk.magenta,
          string: chalk.green,
          regex: chalk.magenta,
          comment: chalk.grey,
          invalid: chalk.white.bgRed.bold
        };
      }
      var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
      var BRACKET = /^[()[\]{}]$/;
      var tokenize;
      {
        const JSX_TAG = /^[a-z][\w-]*$/i;
        const getTokenType = function(token, offset, text) {
          if (token.type === "name") {
            if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
              return "keyword";
            }
            if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
              return "jsxIdentifier";
            }
            if (token.value[0] !== token.value[0].toLowerCase()) {
              return "capitalized";
            }
          }
          if (token.type === "punctuator" && BRACKET.test(token.value)) {
            return "bracket";
          }
          if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
            return "punctuator";
          }
          return token.type;
        };
        tokenize = function* (text) {
          let match;
          while (match = _jsTokens.default.exec(text)) {
            const token = _jsTokens.matchToToken(match);
            yield {
              type: getTokenType(token, match.index, text),
              value: token.value
            };
          }
        };
      }
      function highlightTokens(defs, text) {
        let highlighted = "";
        for (const {
          type,
          value
        } of tokenize(text)) {
          const colorize = defs[type];
          if (colorize) {
            highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
          } else {
            highlighted += value;
          }
        }
        return highlighted;
      }
      function shouldHighlight(options) {
        return !!_chalk.supportsColor || options.forceColor;
      }
      function getChalk(options) {
        return options.forceColor ? new _chalk.constructor({
          enabled: true,
          level: 1
        }) : _chalk;
      }
      function highlight(code, options = {}) {
        if (code !== "" && shouldHighlight(options)) {
          const chalk = getChalk(options);
          const defs = getDefs(chalk);
          return highlightTokens(defs, code);
        } else {
          return code;
        }
      }
    }
  });

  // ../node_modules/@babel/code-frame/lib/index.js
  var require_lib9 = __commonJS({
    "../node_modules/@babel/code-frame/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.codeFrameColumns = codeFrameColumns;
      exports.default = _default;
      var _highlight = require_lib8();
      var deprecationWarningShown = false;
      function getDefs(chalk) {
        return {
          gutter: chalk.grey,
          marker: chalk.red.bold,
          message: chalk.red.bold
        };
      }
      var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
      function getMarkerLines(loc, source, opts) {
        const startLoc = Object.assign({
          column: 0,
          line: -1
        }, loc.start);
        const endLoc = Object.assign({}, startLoc, loc.end);
        const {
          linesAbove = 2,
          linesBelow = 3
        } = opts || {};
        const startLine = startLoc.line;
        const startColumn = startLoc.column;
        const endLine = endLoc.line;
        const endColumn = endLoc.column;
        let start = Math.max(startLine - (linesAbove + 1), 0);
        let end = Math.min(source.length, endLine + linesBelow);
        if (startLine === -1) {
          start = 0;
        }
        if (endLine === -1) {
          end = source.length;
        }
        const lineDiff = endLine - startLine;
        const markerLines = {};
        if (lineDiff) {
          for (let i = 0; i <= lineDiff; i++) {
            const lineNumber = i + startLine;
            if (!startColumn) {
              markerLines[lineNumber] = true;
            } else if (i === 0) {
              const sourceLength = source[lineNumber - 1].length;
              markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
            } else if (i === lineDiff) {
              markerLines[lineNumber] = [0, endColumn];
            } else {
              const sourceLength = source[lineNumber - i].length;
              markerLines[lineNumber] = [0, sourceLength];
            }
          }
        } else {
          if (startColumn === endColumn) {
            if (startColumn) {
              markerLines[startLine] = [startColumn, 0];
            } else {
              markerLines[startLine] = true;
            }
          } else {
            markerLines[startLine] = [startColumn, endColumn - startColumn];
          }
        }
        return {
          start,
          end,
          markerLines
        };
      }
      function codeFrameColumns(rawLines, loc, opts = {}) {
        const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
        const chalk = (0, _highlight.getChalk)(opts);
        const defs = getDefs(chalk);
        const maybeHighlight = (chalkFn, string) => {
          return highlighted ? chalkFn(string) : string;
        };
        const lines = rawLines.split(NEWLINE);
        const {
          start,
          end,
          markerLines
        } = getMarkerLines(loc, lines, opts);
        const hasColumns = loc.start && typeof loc.start.column === "number";
        const numberMaxWidth = String(end).length;
        const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
        let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
          const number = start + 1 + index;
          const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
          const gutter = ` ${paddedNumber} |`;
          const hasMarker = markerLines[number];
          const lastMarkerLine = !markerLines[number + 1];
          if (hasMarker) {
            let markerLine = "";
            if (Array.isArray(hasMarker)) {
              const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
              const numberOfMarkers = hasMarker[1] || 1;
              markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
              if (lastMarkerLine && opts.message) {
                markerLine += " " + maybeHighlight(defs.message, opts.message);
              }
            }
            return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
          } else {
            return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
          }
        }).join("\n");
        if (opts.message && !hasColumns) {
          frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
        }
        if (highlighted) {
          return chalk.reset(frame);
        } else {
          return frame;
        }
      }
      function _default(rawLines, lineNumber, colNumber, opts = {}) {
        if (!deprecationWarningShown) {
          deprecationWarningShown = true;
          const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
          if (process.emitWarning) {
            process.emitWarning(message, "DeprecationWarning");
          } else {
            const deprecationError = new Error(message);
            deprecationError.name = "DeprecationWarning";
            console.warn(new Error(message));
          }
        }
        colNumber = Math.max(colNumber, 0);
        const location = {
          start: {
            column: colNumber,
            line: lineNumber
          }
        };
        return codeFrameColumns(rawLines, location, opts);
      }
    }
  });

  // ../node_modules/@babel/helper-hoist-variables/lib/index.js
  var require_lib10 = __commonJS({
    "../node_modules/@babel/helper-hoist-variables/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = hoistVariables;
      var _t = require_lib3();
      var {
        assignmentExpression,
        expressionStatement,
        identifier
      } = _t;
      var visitor = {
        Scope(path, state) {
          if (state.kind === "let")
            path.skip();
        },
        FunctionParent(path) {
          path.skip();
        },
        VariableDeclaration(path, state) {
          if (state.kind && path.node.kind !== state.kind)
            return;
          const nodes = [];
          const declarations = path.get("declarations");
          let firstId;
          for (const declar of declarations) {
            firstId = declar.node.id;
            if (declar.node.init) {
              nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
            }
            for (const name of Object.keys(declar.getBindingIdentifiers())) {
              state.emit(identifier(name), name, declar.node.init !== null);
            }
          }
          if (path.parentPath.isFor({
            left: path.node
          })) {
            path.replaceWith(firstId);
          } else {
            path.replaceWithMultiple(nodes);
          }
        }
      };
      function hoistVariables(path, emit, kind = "var") {
        path.traverse(visitor, {
          kind,
          emit
        });
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/replacement.js
  var require_replacement = __commonJS({
    "../node_modules/@babel/traverse/lib/path/replacement.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._replaceWith = _replaceWith;
      exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
      exports.replaceInline = replaceInline;
      exports.replaceWith = replaceWith;
      exports.replaceWithMultiple = replaceWithMultiple;
      exports.replaceWithSourceString = replaceWithSourceString;
      var _codeFrame = require_lib9();
      var _index = require_lib13();
      var _index2 = require_path();
      var _cache = require_cache();
      var _parser = require_lib5();
      var _t = require_lib3();
      var _helperHoistVariables = require_lib10();
      var {
        FUNCTION_TYPES,
        arrowFunctionExpression,
        assignmentExpression,
        awaitExpression,
        blockStatement,
        callExpression,
        cloneNode,
        expressionStatement,
        identifier,
        inheritLeadingComments,
        inheritTrailingComments,
        inheritsComments,
        isExpression,
        isProgram,
        isStatement,
        removeComments,
        returnStatement,
        toSequenceExpression,
        validate,
        yieldExpression
      } = _t;
      function replaceWithMultiple(nodes) {
        var _pathCache$get;
        this.resync();
        nodes = this._verifyNodeList(nodes);
        inheritLeadingComments(nodes[0], this.node);
        inheritTrailingComments(nodes[nodes.length - 1], this.node);
        (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);
        this.node = this.container[this.key] = null;
        const paths = this.insertAfter(nodes);
        if (this.node) {
          this.requeue();
        } else {
          this.remove();
        }
        return paths;
      }
      function replaceWithSourceString(replacement) {
        this.resync();
        let ast;
        try {
          replacement = `(${replacement})`;
          ast = (0, _parser.parse)(replacement);
        } catch (err) {
          const loc = err.loc;
          if (loc) {
            err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
              start: {
                line: loc.line,
                column: loc.column + 1
              }
            });
            err.code = "BABEL_REPLACE_SOURCE_ERROR";
          }
          throw err;
        }
        const expressionAST = ast.program.body[0].expression;
        _index.default.removeProperties(expressionAST);
        return this.replaceWith(expressionAST);
      }
      function replaceWith(replacementPath) {
        this.resync();
        if (this.removed) {
          throw new Error("You can't replace this node, we've already removed it");
        }
        let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
        if (!replacement) {
          throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
        }
        if (this.node === replacement) {
          return [this];
        }
        if (this.isProgram() && !isProgram(replacement)) {
          throw new Error("You can only replace a Program root node with another Program node");
        }
        if (Array.isArray(replacement)) {
          throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
        }
        if (typeof replacement === "string") {
          throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
        }
        let nodePath = "";
        if (this.isNodeType("Statement") && isExpression(replacement)) {
          if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
            replacement = expressionStatement(replacement);
            nodePath = "expression";
          }
        }
        if (this.isNodeType("Expression") && isStatement(replacement)) {
          if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
            return this.replaceExpressionWithStatements([replacement]);
          }
        }
        const oldNode = this.node;
        if (oldNode) {
          inheritsComments(replacement, oldNode);
          removeComments(oldNode);
        }
        this._replaceWith(replacement);
        this.type = replacement.type;
        this.setScope();
        this.requeue();
        return [nodePath ? this.get(nodePath) : this];
      }
      function _replaceWith(node) {
        var _pathCache$get2;
        if (!this.container) {
          throw new ReferenceError("Container is falsy");
        }
        if (this.inList) {
          validate(this.parent, this.key, [node]);
        } else {
          validate(this.parent, this.key, node);
        }
        this.debug(`Replace with ${node == null ? void 0 : node.type}`);
        (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);
        this.node = this.container[this.key] = node;
      }
      function replaceExpressionWithStatements(nodes) {
        this.resync();
        const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
        if (nodesAsSequenceExpression) {
          return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
        }
        const functionParent = this.getFunctionParent();
        const isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
        const isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
        const container = arrowFunctionExpression([], blockStatement(nodes));
        this.replaceWith(callExpression(container, []));
        const callee = this.get("callee");
        (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
          this.scope.push({
            id
          });
        }, "var");
        const completionRecords = this.get("callee").getCompletionRecords();
        for (const path of completionRecords) {
          if (!path.isExpressionStatement())
            continue;
          const loop = path.findParent((path2) => path2.isLoop());
          if (loop) {
            let uid = loop.getData("expressionReplacementReturnUid");
            if (!uid) {
              uid = callee.scope.generateDeclaredUidIdentifier("ret");
              callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
              loop.setData("expressionReplacementReturnUid", uid);
            } else {
              uid = identifier(uid.name);
            }
            path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
          } else {
            path.replaceWith(returnStatement(path.node.expression));
          }
        }
        callee.arrowFunctionToExpression();
        const newCallee = callee;
        const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
        const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
        if (needToAwaitFunction) {
          newCallee.set("async", true);
          if (!needToYieldFunction) {
            this.replaceWith(awaitExpression(this.node));
          }
        }
        if (needToYieldFunction) {
          newCallee.set("generator", true);
          this.replaceWith(yieldExpression(this.node, true));
        }
        return newCallee.get("body.body");
      }
      function replaceInline(nodes) {
        this.resync();
        if (Array.isArray(nodes)) {
          if (Array.isArray(this.container)) {
            nodes = this._verifyNodeList(nodes);
            const paths = this._containerInsertAfter(nodes);
            this.remove();
            return paths;
          } else {
            return this.replaceWithMultiple(nodes);
          }
        } else {
          return this.replaceWith(nodes);
        }
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/evaluation.js
  var require_evaluation = __commonJS({
    "../node_modules/@babel/traverse/lib/path/evaluation.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.evaluate = evaluate;
      exports.evaluateTruthy = evaluateTruthy;
      var VALID_CALLEES = ["String", "Number", "Math"];
      var INVALID_METHODS = ["random"];
      function isValidCallee(val) {
        return VALID_CALLEES.includes(val);
      }
      function isInvalidMethod(val) {
        return INVALID_METHODS.includes(val);
      }
      function evaluateTruthy() {
        const res = this.evaluate();
        if (res.confident)
          return !!res.value;
      }
      function deopt(path, state) {
        if (!state.confident)
          return;
        state.deoptPath = path;
        state.confident = false;
      }
      function evaluateCached(path, state) {
        const {
          node
        } = path;
        const {
          seen
        } = state;
        if (seen.has(node)) {
          const existing = seen.get(node);
          if (existing.resolved) {
            return existing.value;
          } else {
            deopt(path, state);
            return;
          }
        } else {
          const item = {
            resolved: false
          };
          seen.set(node, item);
          const val = _evaluate(path, state);
          if (state.confident) {
            item.resolved = true;
            item.value = val;
          }
          return val;
        }
      }
      function _evaluate(path, state) {
        if (!state.confident)
          return;
        if (path.isSequenceExpression()) {
          const exprs = path.get("expressions");
          return evaluateCached(exprs[exprs.length - 1], state);
        }
        if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
          return path.node.value;
        }
        if (path.isNullLiteral()) {
          return null;
        }
        if (path.isTemplateLiteral()) {
          return evaluateQuasis(path, path.node.quasis, state);
        }
        if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
          const object = path.get("tag.object");
          const {
            node: {
              name
            }
          } = object;
          const property = path.get("tag.property");
          if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
            return evaluateQuasis(path, path.node.quasi.quasis, state, true);
          }
        }
        if (path.isConditionalExpression()) {
          const testResult = evaluateCached(path.get("test"), state);
          if (!state.confident)
            return;
          if (testResult) {
            return evaluateCached(path.get("consequent"), state);
          } else {
            return evaluateCached(path.get("alternate"), state);
          }
        }
        if (path.isExpressionWrapper()) {
          return evaluateCached(path.get("expression"), state);
        }
        if (path.isMemberExpression() && !path.parentPath.isCallExpression({
          callee: path.node
        })) {
          const property = path.get("property");
          const object = path.get("object");
          if (object.isLiteral() && property.isIdentifier()) {
            const value = object.node.value;
            const type = typeof value;
            if (type === "number" || type === "string") {
              return value[property.node.name];
            }
          }
        }
        if (path.isReferencedIdentifier()) {
          const binding = path.scope.getBinding(path.node.name);
          if (binding && binding.constantViolations.length > 0) {
            return deopt(binding.path, state);
          }
          if (binding && path.node.start < binding.path.node.end) {
            return deopt(binding.path, state);
          }
          if (binding != null && binding.hasValue) {
            return binding.value;
          } else {
            if (path.node.name === "undefined") {
              return binding ? deopt(binding.path, state) : void 0;
            } else if (path.node.name === "Infinity") {
              return binding ? deopt(binding.path, state) : Infinity;
            } else if (path.node.name === "NaN") {
              return binding ? deopt(binding.path, state) : NaN;
            }
            const resolved = path.resolve();
            if (resolved === path) {
              return deopt(path, state);
            } else {
              return evaluateCached(resolved, state);
            }
          }
        }
        if (path.isUnaryExpression({
          prefix: true
        })) {
          if (path.node.operator === "void") {
            return void 0;
          }
          const argument = path.get("argument");
          if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
            return "function";
          }
          const arg = evaluateCached(argument, state);
          if (!state.confident)
            return;
          switch (path.node.operator) {
            case "!":
              return !arg;
            case "+":
              return +arg;
            case "-":
              return -arg;
            case "~":
              return ~arg;
            case "typeof":
              return typeof arg;
          }
        }
        if (path.isArrayExpression()) {
          const arr = [];
          const elems = path.get("elements");
          for (const elem of elems) {
            const elemValue = elem.evaluate();
            if (elemValue.confident) {
              arr.push(elemValue.value);
            } else {
              return deopt(elemValue.deopt, state);
            }
          }
          return arr;
        }
        if (path.isObjectExpression()) {
          const obj = {};
          const props = path.get("properties");
          for (const prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
              return deopt(prop, state);
            }
            const keyPath = prop.get("key");
            let key = keyPath;
            if (prop.node.computed) {
              key = key.evaluate();
              if (!key.confident) {
                return deopt(key.deopt, state);
              }
              key = key.value;
            } else if (key.isIdentifier()) {
              key = key.node.name;
            } else {
              key = key.node.value;
            }
            const valuePath = prop.get("value");
            let value = valuePath.evaluate();
            if (!value.confident) {
              return deopt(value.deopt, state);
            }
            value = value.value;
            obj[key] = value;
          }
          return obj;
        }
        if (path.isLogicalExpression()) {
          const wasConfident = state.confident;
          const left = evaluateCached(path.get("left"), state);
          const leftConfident = state.confident;
          state.confident = wasConfident;
          const right = evaluateCached(path.get("right"), state);
          const rightConfident = state.confident;
          switch (path.node.operator) {
            case "||":
              state.confident = leftConfident && (!!left || rightConfident);
              if (!state.confident)
                return;
              return left || right;
            case "&&":
              state.confident = leftConfident && (!left || rightConfident);
              if (!state.confident)
                return;
              return left && right;
            case "??":
              state.confident = leftConfident && (left != null || rightConfident);
              if (!state.confident)
                return;
              return left != null ? left : right;
          }
        }
        if (path.isBinaryExpression()) {
          const left = evaluateCached(path.get("left"), state);
          if (!state.confident)
            return;
          const right = evaluateCached(path.get("right"), state);
          if (!state.confident)
            return;
          switch (path.node.operator) {
            case "-":
              return left - right;
            case "+":
              return left + right;
            case "/":
              return left / right;
            case "*":
              return left * right;
            case "%":
              return left % right;
            case "**":
              return Math.pow(left, right);
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "|":
              return left | right;
            case "&":
              return left & right;
            case "^":
              return left ^ right;
            case "<<":
              return left << right;
            case ">>":
              return left >> right;
            case ">>>":
              return left >>> right;
          }
        }
        if (path.isCallExpression()) {
          const callee = path.get("callee");
          let context;
          let func;
          if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {
            func = global[callee.node.name];
          }
          if (callee.isMemberExpression()) {
            const object = callee.get("object");
            const property = callee.get("property");
            if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
              context = global[object.node.name];
              func = context[property.node.name];
            }
            if (object.isLiteral() && property.isIdentifier()) {
              const type = typeof object.node.value;
              if (type === "string" || type === "number") {
                context = object.node.value;
                func = context[property.node.name];
              }
            }
          }
          if (func) {
            const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
            if (!state.confident)
              return;
            return func.apply(context, args);
          }
        }
        deopt(path, state);
      }
      function evaluateQuasis(path, quasis, state, raw = false) {
        let str = "";
        let i = 0;
        const exprs = path.get("expressions");
        for (const elem of quasis) {
          if (!state.confident)
            break;
          str += raw ? elem.value.raw : elem.value.cooked;
          const expr = exprs[i++];
          if (expr)
            str += String(evaluateCached(expr, state));
        }
        if (!state.confident)
          return;
        return str;
      }
      function evaluate() {
        const state = {
          confident: true,
          deoptPath: null,
          seen: /* @__PURE__ */ new Map()
        };
        let value = evaluateCached(this, state);
        if (!state.confident)
          value = void 0;
        return {
          confident: state.confident,
          deopt: state.deoptPath,
          value
        };
      }
    }
  });

  // ../node_modules/@babel/template/lib/formatters.js
  var require_formatters = __commonJS({
    "../node_modules/@babel/template/lib/formatters.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
      var _t = require_lib3();
      var {
        assertExpressionStatement
      } = _t;
      function makeStatementFormatter(fn) {
        return {
          code: (str) => `/* @babel/template */;
${str}`,
          validate: () => {
          },
          unwrap: (ast) => {
            return fn(ast.program.body.slice(1));
          }
        };
      }
      var smart = makeStatementFormatter((body) => {
        if (body.length > 1) {
          return body;
        } else {
          return body[0];
        }
      });
      exports.smart = smart;
      var statements = makeStatementFormatter((body) => body);
      exports.statements = statements;
      var statement = makeStatementFormatter((body) => {
        if (body.length === 0) {
          throw new Error("Found nothing to return.");
        }
        if (body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        return body[0];
      });
      exports.statement = statement;
      var expression = {
        code: (str) => `(
${str}
)`,
        validate: (ast) => {
          if (ast.program.body.length > 1) {
            throw new Error("Found multiple statements but wanted one");
          }
          if (expression.unwrap(ast).start === 0) {
            throw new Error("Parse result included parens.");
          }
        },
        unwrap: ({
          program: program2
        }) => {
          const [stmt] = program2.body;
          assertExpressionStatement(stmt);
          return stmt.expression;
        }
      };
      exports.expression = expression;
      var program = {
        code: (str) => str,
        validate: () => {
        },
        unwrap: (ast) => ast.program
      };
      exports.program = program;
    }
  });

  // ../node_modules/@babel/template/lib/options.js
  var require_options = __commonJS({
    "../node_modules/@babel/template/lib/options.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.merge = merge;
      exports.normalizeReplacements = normalizeReplacements;
      exports.validate = validate;
      var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function merge(a, b) {
        const {
          placeholderWhitelist = a.placeholderWhitelist,
          placeholderPattern = a.placeholderPattern,
          preserveComments = a.preserveComments,
          syntacticPlaceholders = a.syntacticPlaceholders
        } = b;
        return {
          parser: Object.assign({}, a.parser, b.parser),
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        };
      }
      function validate(opts) {
        if (opts != null && typeof opts !== "object") {
          throw new Error("Unknown template options.");
        }
        const _ref = opts || {}, {
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
        if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
          throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
        }
        if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
          throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
        }
        if (preserveComments != null && typeof preserveComments !== "boolean") {
          throw new Error("'.preserveComments' must be a boolean, null, or undefined");
        }
        if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
          throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
        }
        if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
          throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        }
        return {
          parser,
          placeholderWhitelist: placeholderWhitelist || void 0,
          placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
          preserveComments: preserveComments == null ? void 0 : preserveComments,
          syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
        };
      }
      function normalizeReplacements(replacements) {
        if (Array.isArray(replacements)) {
          return replacements.reduce((acc, replacement, i) => {
            acc["$" + i] = replacement;
            return acc;
          }, {});
        } else if (typeof replacements === "object" || replacements == null) {
          return replacements || void 0;
        }
        throw new Error("Template replacements must be an array, object, null, or undefined");
      }
    }
  });

  // ../node_modules/@babel/template/lib/parse.js
  var require_parse = __commonJS({
    "../node_modules/@babel/template/lib/parse.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = parseAndBuildMetadata;
      var _t = require_lib3();
      var _parser = require_lib5();
      var _codeFrame = require_lib9();
      var {
        isCallExpression,
        isExpressionStatement,
        isFunction,
        isIdentifier,
        isJSXIdentifier,
        isNewExpression,
        isPlaceholder,
        isStatement,
        isStringLiteral,
        removePropertiesDeep,
        traverse: traverse2
      } = _t;
      var PATTERN = /^[_$A-Z0-9]+$/;
      function parseAndBuildMetadata(formatter, code, opts) {
        const {
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        } = opts;
        const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
        removePropertiesDeep(ast, {
          preserveComments
        });
        formatter.validate(ast);
        const syntactic = {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        };
        const legacy = {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        };
        const isLegacyRef = {
          value: void 0
        };
        traverse2(ast, placeholderVisitorHandler, {
          syntactic,
          legacy,
          isLegacyRef,
          placeholderWhitelist,
          placeholderPattern,
          syntacticPlaceholders
        });
        return Object.assign({
          ast
        }, isLegacyRef.value ? legacy : syntactic);
      }
      function placeholderVisitorHandler(node, ancestors, state) {
        var _state$placeholderWhi;
        let name;
        if (isPlaceholder(node)) {
          if (state.syntacticPlaceholders === false) {
            throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
          } else {
            name = node.name.name;
            state.isLegacyRef.value = false;
          }
        } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
          return;
        } else if (isIdentifier(node) || isJSXIdentifier(node)) {
          name = node.name;
          state.isLegacyRef.value = true;
        } else if (isStringLiteral(node)) {
          name = node.value;
          state.isLegacyRef.value = true;
        } else {
          return;
        }
        if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
          throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        }
        if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
          return;
        }
        ancestors = ancestors.slice();
        const {
          node: parent,
          key
        } = ancestors[ancestors.length - 1];
        let type;
        if (isStringLiteral(node) || isPlaceholder(node, {
          expectedNode: "StringLiteral"
        })) {
          type = "string";
        } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
          type = "param";
        } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
          type = "statement";
          ancestors = ancestors.slice(0, -1);
        } else if (isStatement(node) && isPlaceholder(node)) {
          type = "statement";
        } else {
          type = "other";
        }
        const {
          placeholders,
          placeholderNames
        } = state.isLegacyRef.value ? state.legacy : state.syntactic;
        placeholders.push({
          name,
          type,
          resolve: (ast) => resolveAncestors(ast, ancestors),
          isDuplicate: placeholderNames.has(name)
        });
        placeholderNames.add(name);
      }
      function resolveAncestors(ast, ancestors) {
        let parent = ast;
        for (let i = 0; i < ancestors.length - 1; i++) {
          const {
            key: key2,
            index: index2
          } = ancestors[i];
          if (index2 === void 0) {
            parent = parent[key2];
          } else {
            parent = parent[key2][index2];
          }
        }
        const {
          key,
          index
        } = ancestors[ancestors.length - 1];
        return {
          parent,
          key,
          index
        };
      }
      function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
        const plugins = (parserOpts.plugins || []).slice();
        if (syntacticPlaceholders !== false) {
          plugins.push("placeholders");
        }
        parserOpts = Object.assign({
          allowReturnOutsideFunction: true,
          allowSuperOutsideMethod: true,
          sourceType: "module"
        }, parserOpts, {
          plugins
        });
        try {
          return (0, _parser.parse)(code, parserOpts);
        } catch (err) {
          const loc = err.loc;
          if (loc) {
            err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
              start: loc
            });
            err.code = "BABEL_TEMPLATE_PARSE_ERROR";
          }
          throw err;
        }
      }
    }
  });

  // ../node_modules/@babel/template/lib/populate.js
  var require_populate = __commonJS({
    "../node_modules/@babel/template/lib/populate.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = populatePlaceholders;
      var _t = require_lib3();
      var {
        blockStatement,
        cloneNode,
        emptyStatement,
        expressionStatement,
        identifier,
        isStatement,
        isStringLiteral,
        stringLiteral: stringLiteral2,
        validate
      } = _t;
      function populatePlaceholders(metadata, replacements) {
        const ast = cloneNode(metadata.ast);
        if (replacements) {
          metadata.placeholders.forEach((placeholder) => {
            if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
              const placeholderName = placeholder.name;
              throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
          });
          Object.keys(replacements).forEach((key) => {
            if (!metadata.placeholderNames.has(key)) {
              throw new Error(`Unknown substitution "${key}" given`);
            }
          });
        }
        metadata.placeholders.slice().reverse().forEach((placeholder) => {
          try {
            applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
          } catch (e) {
            e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
            throw e;
          }
        });
        return ast;
      }
      function applyReplacement(placeholder, ast, replacement) {
        if (placeholder.isDuplicate) {
          if (Array.isArray(replacement)) {
            replacement = replacement.map((node) => cloneNode(node));
          } else if (typeof replacement === "object") {
            replacement = cloneNode(replacement);
          }
        }
        const {
          parent,
          key,
          index
        } = placeholder.resolve(ast);
        if (placeholder.type === "string") {
          if (typeof replacement === "string") {
            replacement = stringLiteral2(replacement);
          }
          if (!replacement || !isStringLiteral(replacement)) {
            throw new Error("Expected string substitution");
          }
        } else if (placeholder.type === "statement") {
          if (index === void 0) {
            if (!replacement) {
              replacement = emptyStatement();
            } else if (Array.isArray(replacement)) {
              replacement = blockStatement(replacement);
            } else if (typeof replacement === "string") {
              replacement = expressionStatement(identifier(replacement));
            } else if (!isStatement(replacement)) {
              replacement = expressionStatement(replacement);
            }
          } else {
            if (replacement && !Array.isArray(replacement)) {
              if (typeof replacement === "string") {
                replacement = identifier(replacement);
              }
              if (!isStatement(replacement)) {
                replacement = expressionStatement(replacement);
              }
            }
          }
        } else if (placeholder.type === "param") {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }
          if (index === void 0)
            throw new Error("Assertion failure.");
        } else {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }
          if (Array.isArray(replacement)) {
            throw new Error("Cannot replace single expression with an array.");
          }
        }
        if (index === void 0) {
          validate(parent, key, replacement);
          parent[key] = replacement;
        } else {
          const items = parent[key].slice();
          if (placeholder.type === "statement" || placeholder.type === "param") {
            if (replacement == null) {
              items.splice(index, 1);
            } else if (Array.isArray(replacement)) {
              items.splice(index, 1, ...replacement);
            } else {
              items[index] = replacement;
            }
          } else {
            items[index] = replacement;
          }
          validate(parent, key, items);
          parent[key] = items;
        }
      }
    }
  });

  // ../node_modules/@babel/template/lib/string.js
  var require_string = __commonJS({
    "../node_modules/@babel/template/lib/string.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = stringTemplate;
      var _options = require_options();
      var _parse = require_parse();
      var _populate = require_populate();
      function stringTemplate(formatter, code, opts) {
        code = formatter.code(code);
        let metadata;
        return (arg) => {
          const replacements = (0, _options.normalizeReplacements)(arg);
          if (!metadata)
            metadata = (0, _parse.default)(formatter, code, opts);
          return formatter.unwrap((0, _populate.default)(metadata, replacements));
        };
      }
    }
  });

  // ../node_modules/@babel/template/lib/literal.js
  var require_literal = __commonJS({
    "../node_modules/@babel/template/lib/literal.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = literalTemplate;
      var _options = require_options();
      var _parse = require_parse();
      var _populate = require_populate();
      function literalTemplate(formatter, tpl, opts) {
        const {
          metadata,
          names
        } = buildLiteralData(formatter, tpl, opts);
        return (arg) => {
          const defaultReplacements2 = {};
          arg.forEach((replacement, i) => {
            defaultReplacements2[names[i]] = replacement;
          });
          return (arg2) => {
            const replacements = (0, _options.normalizeReplacements)(arg2);
            if (replacements) {
              Object.keys(replacements).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(defaultReplacements2, key)) {
                  throw new Error("Unexpected replacement overlap.");
                }
              });
            }
            return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements2) : defaultReplacements2));
          };
        };
      }
      function buildLiteralData(formatter, tpl, opts) {
        let names;
        let nameSet;
        let metadata;
        let prefix = "";
        do {
          prefix += "$";
          const result = buildTemplateCode(tpl, prefix);
          names = result.names;
          nameSet = new Set(names);
          metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
            parser: opts.parser,
            placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
            placeholderPattern: opts.placeholderPattern,
            preserveComments: opts.preserveComments,
            syntacticPlaceholders: opts.syntacticPlaceholders
          });
        } while (metadata.placeholders.some((placeholder) => placeholder.isDuplicate && nameSet.has(placeholder.name)));
        return {
          metadata,
          names
        };
      }
      function buildTemplateCode(tpl, prefix) {
        const names = [];
        let code = tpl[0];
        for (let i = 1; i < tpl.length; i++) {
          const value = `${prefix}${i - 1}`;
          names.push(value);
          code += value + tpl[i];
        }
        return {
          names,
          code
        };
      }
    }
  });

  // ../node_modules/@babel/template/lib/builder.js
  var require_builder = __commonJS({
    "../node_modules/@babel/template/lib/builder.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = createTemplateBuilder;
      var _options = require_options();
      var _string = require_string();
      var _literal = require_literal();
      var NO_PLACEHOLDER = (0, _options.validate)({
        placeholderPattern: false
      });
      function createTemplateBuilder(formatter, defaultOpts) {
        const templateFnCache = /* @__PURE__ */ new WeakMap();
        const templateAstCache = /* @__PURE__ */ new WeakMap();
        const cachedOpts = defaultOpts || (0, _options.validate)(null);
        return Object.assign((tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1)
              throw new Error("Unexpected extra params.");
            return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
          } else if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, cachedOpts);
              templateFnCache.set(tpl, builder);
            }
            return extendedTrace(builder(args));
          } else if (typeof tpl === "object" && tpl) {
            if (args.length > 0)
              throw new Error("Unexpected extra params.");
            return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }, {
          ast: (tpl, ...args) => {
            if (typeof tpl === "string") {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
            } else if (Array.isArray(tpl)) {
              let builder = templateAstCache.get(tpl);
              if (!builder) {
                builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
                templateAstCache.set(tpl, builder);
              }
              return builder(args)();
            }
            throw new Error(`Unexpected template param ${typeof tpl}`);
          }
        });
      }
      function extendedTrace(fn) {
        let rootStack = "";
        try {
          throw new Error();
        } catch (error) {
          if (error.stack) {
            rootStack = error.stack.split("\n").slice(3).join("\n");
          }
        }
        return (arg) => {
          try {
            return fn(arg);
          } catch (err) {
            err.stack += `
    =============
${rootStack}`;
            throw err;
          }
        };
      }
    }
  });

  // ../node_modules/@babel/template/lib/index.js
  var require_lib11 = __commonJS({
    "../node_modules/@babel/template/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
      var formatters = require_formatters();
      var _builder = require_builder();
      var smart = (0, _builder.default)(formatters.smart);
      exports.smart = smart;
      var statement = (0, _builder.default)(formatters.statement);
      exports.statement = statement;
      var statements = (0, _builder.default)(formatters.statements);
      exports.statements = statements;
      var expression = (0, _builder.default)(formatters.expression);
      exports.expression = expression;
      var program = (0, _builder.default)(formatters.program);
      exports.program = program;
      var _default = Object.assign(smart.bind(void 0), {
        smart,
        statement,
        statements,
        expression,
        program,
        ast: smart.ast
      });
      exports.default = _default;
    }
  });

  // ../node_modules/@babel/helper-function-name/lib/index.js
  var require_lib12 = __commonJS({
    "../node_modules/@babel/helper-function-name/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = _default;
      var _template = require_lib11();
      var _t = require_lib3();
      var {
        NOT_LOCAL_BINDING,
        cloneNode,
        identifier,
        isAssignmentExpression,
        isAssignmentPattern,
        isFunction,
        isIdentifier,
        isLiteral,
        isNullLiteral,
        isObjectMethod,
        isObjectProperty,
        isRegExpLiteral,
        isRestElement,
        isTemplateLiteral,
        isVariableDeclarator,
        toBindingIdentifierName
      } = _t;
      function getFunctionArity(node) {
        const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
        return count === -1 ? node.params.length : count;
      }
      var buildPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
      var buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
      var visitor = {
        "ReferencedIdentifier|BindingIdentifier"(path, state) {
          if (path.node.name !== state.name)
            return;
          const localDeclar = path.scope.getBindingIdentifier(state.name);
          if (localDeclar !== state.outerDeclar)
            return;
          state.selfReference = true;
          path.stop();
        }
      };
      function getNameFromLiteralId(id) {
        if (isNullLiteral(id)) {
          return "null";
        }
        if (isRegExpLiteral(id)) {
          return `_${id.pattern}_${id.flags}`;
        }
        if (isTemplateLiteral(id)) {
          return id.quasis.map((quasi) => quasi.value.raw).join("");
        }
        if (id.value !== void 0) {
          return id.value + "";
        }
        return "";
      }
      function wrap(state, method, id, scope) {
        if (state.selfReference) {
          if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
            scope.rename(id.name);
          } else {
            if (!isFunction(method))
              return;
            let build = buildPropertyMethodAssignmentWrapper;
            if (method.generator) {
              build = buildGeneratorPropertyMethodAssignmentWrapper;
            }
            const template2 = build({
              FUNCTION: method,
              FUNCTION_ID: id,
              FUNCTION_KEY: scope.generateUidIdentifier(id.name)
            }).expression;
            const params = template2.callee.body.body[0].params;
            for (let i = 0, len = getFunctionArity(method); i < len; i++) {
              params.push(scope.generateUidIdentifier("x"));
            }
            return template2;
          }
        }
        method.id = id;
        scope.getProgramParent().references[id.name] = true;
      }
      function visit(node, name, scope) {
        const state = {
          selfAssignment: false,
          selfReference: false,
          outerDeclar: scope.getBindingIdentifier(name),
          name
        };
        const binding = scope.getOwnBinding(name);
        if (binding) {
          if (binding.kind === "param") {
            state.selfReference = true;
          } else {
          }
        } else if (state.outerDeclar || scope.hasGlobal(name)) {
          scope.traverse(node, visitor, state);
        }
        return state;
      }
      function _default({
        node,
        parent,
        scope,
        id
      }, localBinding = false, supportUnicodeId = false) {
        if (node.id)
          return;
        if ((isObjectProperty(parent) || isObjectMethod(parent, {
          kind: "method"
        })) && (!parent.computed || isLiteral(parent.key))) {
          id = parent.key;
        } else if (isVariableDeclarator(parent)) {
          id = parent.id;
          if (isIdentifier(id) && !localBinding) {
            const binding = scope.parent.getBinding(id.name);
            if (binding && binding.constant && scope.getBinding(id.name) === binding) {
              node.id = cloneNode(id);
              node.id[NOT_LOCAL_BINDING] = true;
              return;
            }
          }
        } else if (isAssignmentExpression(parent, {
          operator: "="
        })) {
          id = parent.left;
        } else if (!id) {
          return;
        }
        let name;
        if (id && isLiteral(id)) {
          name = getNameFromLiteralId(id);
        } else if (id && isIdentifier(id)) {
          name = id.name;
        }
        if (name === void 0) {
          return;
        }
        if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name)) {
          return;
        }
        name = toBindingIdentifierName(name);
        const newId = identifier(name);
        newId[NOT_LOCAL_BINDING] = true;
        const state = visit(node, name, scope);
        return wrap(state, node, newId, scope) || node;
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/conversion.js
  var require_conversion = __commonJS({
    "../node_modules/@babel/traverse/lib/path/conversion.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.arrowFunctionToExpression = arrowFunctionToExpression;
      exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
      exports.ensureBlock = ensureBlock;
      exports.toComputedKey = toComputedKey;
      exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
      var _t = require_lib3();
      var _helperEnvironmentVisitor = require_lib7();
      var _helperFunctionName = require_lib12();
      var _visitors = require_visitors();
      var {
        arrowFunctionExpression,
        assignmentExpression,
        binaryExpression,
        blockStatement,
        callExpression,
        conditionalExpression,
        expressionStatement,
        identifier,
        isIdentifier,
        jsxIdentifier,
        logicalExpression,
        LOGICAL_OPERATORS,
        memberExpression,
        metaProperty,
        numericLiteral,
        objectExpression,
        restElement,
        returnStatement,
        sequenceExpression,
        spreadElement,
        stringLiteral: stringLiteral2,
        super: _super,
        thisExpression,
        toExpression,
        unaryExpression
      } = _t;
      function toComputedKey() {
        let key;
        if (this.isMemberExpression()) {
          key = this.node.property;
        } else if (this.isProperty() || this.isMethod()) {
          key = this.node.key;
        } else {
          throw new ReferenceError("todo");
        }
        if (!this.node.computed) {
          if (isIdentifier(key))
            key = stringLiteral2(key.name);
        }
        return key;
      }
      function ensureBlock() {
        const body = this.get("body");
        const bodyNode = body.node;
        if (Array.isArray(body)) {
          throw new Error("Can't convert array path to a block statement");
        }
        if (!bodyNode) {
          throw new Error("Can't convert node without a body");
        }
        if (body.isBlockStatement()) {
          return bodyNode;
        }
        const statements = [];
        let stringPath = "body";
        let key;
        let listKey;
        if (body.isStatement()) {
          listKey = "body";
          key = 0;
          statements.push(body.node);
        } else {
          stringPath += ".body.0";
          if (this.isFunction()) {
            key = "argument";
            statements.push(returnStatement(body.node));
          } else {
            key = "expression";
            statements.push(expressionStatement(body.node));
          }
        }
        this.node.body = blockStatement(statements);
        const parentPath = this.get(stringPath);
        body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
        return this.node;
      }
      function arrowFunctionToShadowed() {
        if (!this.isArrowFunctionExpression())
          return;
        this.arrowFunctionToExpression();
      }
      function unwrapFunctionEnvironment() {
        if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
          throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
        }
        hoistFunctionEnvironment(this);
      }
      function setType(path, type) {
        path.node.type = type;
      }
      function arrowFunctionToExpression({
        allowInsertArrow = true,
        specCompliant = false,
        noNewArrows = !specCompliant
      } = {}) {
        if (!this.isArrowFunctionExpression()) {
          throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
        }
        const {
          thisBinding,
          fnPath: fn
        } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
        fn.ensureBlock();
        setType(fn, "FunctionExpression");
        if (!noNewArrows) {
          const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
          if (checkBinding) {
            fn.parentPath.scope.push({
              id: checkBinding,
              init: objectExpression([])
            });
          }
          fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
          fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
          return fn.get("callee.object");
        }
        return fn;
      }
      var getSuperCallsVisitor = (0, _visitors.merge)([{
        CallExpression(child, {
          allSuperCalls
        }) {
          if (!child.get("callee").isSuper())
            return;
          allSuperCalls.push(child);
        }
      }, _helperEnvironmentVisitor.default]);
      function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {
        let arrowParent;
        let thisEnvFn = fnPath.findParent((p) => {
          if (p.isArrowFunctionExpression()) {
            var _arrowParent;
            (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
            return false;
          }
          return p.isFunction() || p.isProgram() || p.isClassProperty({
            static: false
          }) || p.isClassPrivateProperty({
            static: false
          });
        });
        const inConstructor = thisEnvFn.isClassMethod({
          kind: "constructor"
        });
        if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
          if (arrowParent) {
            thisEnvFn = arrowParent;
          } else if (allowInsertArrow) {
            fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
            thisEnvFn = fnPath.get("callee");
            fnPath = thisEnvFn.get("body");
          } else {
            throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
          }
        }
        const {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        } = getScopeInformation(fnPath);
        if (inConstructor && superCalls.length > 0) {
          if (!allowInsertArrow) {
            throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
          }
          const allSuperCalls = [];
          thisEnvFn.traverse(getSuperCallsVisitor, {
            allSuperCalls
          });
          const superBinding = getSuperBinding(thisEnvFn);
          allSuperCalls.forEach((superCall) => {
            const callee = identifier(superBinding);
            callee.loc = superCall.node.callee.loc;
            superCall.get("callee").replaceWith(callee);
          });
        }
        if (argumentsPaths.length > 0) {
          const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
            const args = () => identifier("arguments");
            if (thisEnvFn.scope.path.isProgram()) {
              return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral2("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
            } else {
              return args();
            }
          });
          argumentsPaths.forEach((argumentsChild) => {
            const argsRef = identifier(argumentsBinding);
            argsRef.loc = argumentsChild.node.loc;
            argumentsChild.replaceWith(argsRef);
          });
        }
        if (newTargetPaths.length > 0) {
          const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
          newTargetPaths.forEach((targetChild) => {
            const targetRef = identifier(newTargetBinding);
            targetRef.loc = targetChild.node.loc;
            targetChild.replaceWith(targetRef);
          });
        }
        if (superProps.length > 0) {
          if (!allowInsertArrow) {
            throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
          }
          const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
          flatSuperProps.forEach((superProp) => {
            const key = superProp.node.computed ? "" : superProp.get("property").node.name;
            const superParentPath = superProp.parentPath;
            const isAssignment = superParentPath.isAssignmentExpression({
              left: superProp.node
            });
            const isCall = superParentPath.isCallExpression({
              callee: superProp.node
            });
            const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
            const args = [];
            if (superProp.node.computed) {
              args.push(superProp.get("property").node);
            }
            if (isAssignment) {
              const value = superParentPath.node.right;
              args.push(value);
            }
            const call = callExpression(identifier(superBinding), args);
            if (isCall) {
              superParentPath.unshiftContainer("arguments", thisExpression());
              superProp.replaceWith(memberExpression(call, identifier("call")));
              thisPaths.push(superParentPath.get("arguments.0"));
            } else if (isAssignment) {
              superParentPath.replaceWith(call);
            } else {
              superProp.replaceWith(call);
            }
          });
        }
        let thisBinding;
        if (thisPaths.length > 0 || !noNewArrows) {
          thisBinding = getThisBinding(thisEnvFn, inConstructor);
          if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
            thisPaths.forEach((thisChild) => {
              const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
              thisRef.loc = thisChild.node.loc;
              thisChild.replaceWith(thisRef);
            });
            if (!noNewArrows)
              thisBinding = null;
          }
        }
        return {
          thisBinding,
          fnPath
        };
      }
      function isLogicalOp(op) {
        return LOGICAL_OPERATORS.includes(op);
      }
      function standardizeSuperProperty(superProp) {
        if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
          const assignmentPath = superProp.parentPath;
          const op = assignmentPath.node.operator.slice(0, -1);
          const value = assignmentPath.node.right;
          const isLogicalAssignment = isLogicalOp(op);
          if (superProp.node.computed) {
            const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
            const object = superProp.node.object;
            const property = superProp.node.property;
            assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
            assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
          } else {
            const object = superProp.node.object;
            const property = superProp.node.property;
            assignmentPath.get("left").replaceWith(memberExpression(object, property));
            assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
          }
          if (isLogicalAssignment) {
            assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
          } else {
            assignmentPath.node.operator = "=";
          }
          return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
        } else if (superProp.parentPath.isUpdateExpression()) {
          const updateExpr = superProp.parentPath;
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
          const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
          if (!superProp.parentPath.node.prefix) {
            parts.push(identifier(tmp.name));
          }
          updateExpr.replaceWith(sequenceExpression(parts));
          const left = updateExpr.get("expressions.0.right");
          const right = updateExpr.get("expressions.1.left");
          return [left, right];
        }
        return [superProp];
        function rightExpression(op, left, right) {
          if (op === "=") {
            return assignmentExpression("=", left, right);
          } else {
            return binaryExpression(op, left, right);
          }
        }
      }
      function hasSuperClass(thisEnvFn) {
        return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
      }
      var assignSuperThisVisitor = (0, _visitors.merge)([{
        CallExpression(child, {
          supers,
          thisBinding
        }) {
          if (!child.get("callee").isSuper())
            return;
          if (supers.has(child.node))
            return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
        }
      }, _helperEnvironmentVisitor.default]);
      function getThisBinding(thisEnvFn, inConstructor) {
        return getBinding(thisEnvFn, "this", (thisBinding) => {
          if (!inConstructor || !hasSuperClass(thisEnvFn))
            return thisExpression();
          thisEnvFn.traverse(assignSuperThisVisitor, {
            supers: /* @__PURE__ */ new WeakSet(),
            thisBinding
          });
        });
      }
      function getSuperBinding(thisEnvFn) {
        return getBinding(thisEnvFn, "supercall", () => {
          const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
          return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
        });
      }
      function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
        const op = isAssignment ? "set" : "get";
        return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
          const argsList = [];
          let fnBody;
          if (propName) {
            fnBody = memberExpression(_super(), identifier(propName));
          } else {
            const method = thisEnvFn.scope.generateUidIdentifier("prop");
            argsList.unshift(method);
            fnBody = memberExpression(_super(), identifier(method.name), true);
          }
          if (isAssignment) {
            const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
            argsList.push(valueIdent);
            fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
          }
          return arrowFunctionExpression(argsList, fnBody);
        });
      }
      function getBinding(thisEnvFn, key, init) {
        const cacheKey = "binding:" + key;
        let data = thisEnvFn.getData(cacheKey);
        if (!data) {
          const id = thisEnvFn.scope.generateUidIdentifier(key);
          data = id.name;
          thisEnvFn.setData(cacheKey, data);
          thisEnvFn.scope.push({
            id,
            init: init(data)
          });
        }
        return data;
      }
      var getScopeInformationVisitor = (0, _visitors.merge)([{
        ThisExpression(child, {
          thisPaths
        }) {
          thisPaths.push(child);
        },
        JSXIdentifier(child, {
          thisPaths
        }) {
          if (child.node.name !== "this")
            return;
          if (!child.parentPath.isJSXMemberExpression({
            object: child.node
          }) && !child.parentPath.isJSXOpeningElement({
            name: child.node
          })) {
            return;
          }
          thisPaths.push(child);
        },
        CallExpression(child, {
          superCalls
        }) {
          if (child.get("callee").isSuper())
            superCalls.push(child);
        },
        MemberExpression(child, {
          superProps
        }) {
          if (child.get("object").isSuper())
            superProps.push(child);
        },
        Identifier(child, {
          argumentsPaths
        }) {
          if (!child.isReferencedIdentifier({
            name: "arguments"
          }))
            return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments")) {
              curr.rename("arguments");
              return;
            }
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
              break;
            }
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        },
        MetaProperty(child, {
          newTargetPaths
        }) {
          if (!child.get("meta").isIdentifier({
            name: "new"
          }))
            return;
          if (!child.get("property").isIdentifier({
            name: "target"
          }))
            return;
          newTargetPaths.push(child);
        }
      }, _helperEnvironmentVisitor.default]);
      function getScopeInformation(fnPath) {
        const thisPaths = [];
        const argumentsPaths = [];
        const newTargetPaths = [];
        const superProps = [];
        const superCalls = [];
        fnPath.traverse(getScopeInformationVisitor, {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        });
        return {
          thisPaths,
          argumentsPaths,
          newTargetPaths,
          superProps,
          superCalls
        };
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/introspection.js
  var require_introspection = __commonJS({
    "../node_modules/@babel/traverse/lib/path/introspection.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
      exports._resolve = _resolve;
      exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
      exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
      exports.equals = equals;
      exports.getSource = getSource;
      exports.has = has;
      exports.is = void 0;
      exports.isCompletionRecord = isCompletionRecord;
      exports.isConstantExpression = isConstantExpression;
      exports.isInStrictMode = isInStrictMode;
      exports.isNodeType = isNodeType;
      exports.isStatementOrBlock = isStatementOrBlock;
      exports.isStatic = isStatic;
      exports.isnt = isnt;
      exports.matchesPattern = matchesPattern;
      exports.referencesImport = referencesImport;
      exports.resolve = resolve;
      exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
      var _t = require_lib3();
      var {
        STATEMENT_OR_BLOCK_KEYS,
        VISITOR_KEYS,
        isBlockStatement,
        isExpression,
        isIdentifier,
        isLiteral,
        isStringLiteral,
        isType,
        matchesPattern: _matchesPattern
      } = _t;
      function matchesPattern(pattern, allowPartial) {
        return _matchesPattern(this.node, pattern, allowPartial);
      }
      function has(key) {
        const val = this.node && this.node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      }
      function isStatic() {
        return this.scope.isStatic(this.node);
      }
      var is2 = has;
      exports.is = is2;
      function isnt(key) {
        return !this.has(key);
      }
      function equals(key, value) {
        return this.node[key] === value;
      }
      function isNodeType(type) {
        return isType(this.type, type);
      }
      function canHaveVariableDeclarationOrExpression() {
        return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
      }
      function canSwapBetweenExpressionAndStatement(replacement) {
        if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
          return false;
        }
        if (this.isExpression()) {
          return isBlockStatement(replacement);
        } else if (this.isBlockStatement()) {
          return isExpression(replacement);
        }
        return false;
      }
      function isCompletionRecord(allowInsideFunction) {
        let path = this;
        let first = true;
        do {
          const {
            type,
            container
          } = path;
          if (!first && (path.isFunction() || type === "StaticBlock")) {
            return !!allowInsideFunction;
          }
          first = false;
          if (Array.isArray(container) && path.key !== container.length - 1) {
            return false;
          }
        } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
        return true;
      }
      function isStatementOrBlock() {
        if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
          return false;
        } else {
          return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
        }
      }
      function referencesImport(moduleSource, importName) {
        if (!this.isReferencedIdentifier()) {
          if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
            value: importName
          }) : this.node.property.name === importName)) {
            const object = this.get("object");
            return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
          }
          return false;
        }
        const binding = this.scope.getBinding(this.node.name);
        if (!binding || binding.kind !== "module")
          return false;
        const path = binding.path;
        const parent = path.parentPath;
        if (!parent.isImportDeclaration())
          return false;
        if (parent.node.source.value === moduleSource) {
          if (!importName)
            return true;
        } else {
          return false;
        }
        if (path.isImportDefaultSpecifier() && importName === "default") {
          return true;
        }
        if (path.isImportNamespaceSpecifier() && importName === "*") {
          return true;
        }
        if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
          name: importName
        })) {
          return true;
        }
        return false;
      }
      function getSource() {
        const node = this.node;
        if (node.end) {
          const code = this.hub.getCode();
          if (code)
            return code.slice(node.start, node.end);
        }
        return "";
      }
      function willIMaybeExecuteBefore(target) {
        return this._guessExecutionStatusRelativeTo(target) !== "after";
      }
      function getOuterFunction(path) {
        return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
      }
      function isExecutionUncertain(type, key) {
        switch (type) {
          case "LogicalExpression":
            return key === "right";
          case "ConditionalExpression":
          case "IfStatement":
            return key === "consequent" || key === "alternate";
          case "WhileStatement":
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForOfStatement":
            return key === "body";
          case "ForStatement":
            return key === "body" || key === "update";
          case "SwitchStatement":
            return key === "cases";
          case "TryStatement":
            return key === "handler";
          case "AssignmentPattern":
            return key === "right";
          case "OptionalMemberExpression":
            return key === "property";
          case "OptionalCallExpression":
            return key === "arguments";
          default:
            return false;
        }
      }
      function isExecutionUncertainInList(paths, maxIndex) {
        for (let i = 0; i < maxIndex; i++) {
          const path = paths[i];
          if (isExecutionUncertain(path.parent.type, path.parentKey)) {
            return true;
          }
        }
        return false;
      }
      function _guessExecutionStatusRelativeTo(target) {
        return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
      }
      function _guessExecutionStatusRelativeToCached(base, target, cache) {
        const funcParent = {
          this: getOuterFunction(base),
          target: getOuterFunction(target)
        };
        if (funcParent.target.node !== funcParent.this.node) {
          return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
        }
        const paths = {
          target: target.getAncestry(),
          this: base.getAncestry()
        };
        if (paths.target.indexOf(base) >= 0)
          return "after";
        if (paths.this.indexOf(target) >= 0)
          return "before";
        let commonPath;
        const commonIndex = {
          target: 0,
          this: 0
        };
        while (!commonPath && commonIndex.this < paths.this.length) {
          const path = paths.this[commonIndex.this];
          commonIndex.target = paths.target.indexOf(path);
          if (commonIndex.target >= 0) {
            commonPath = path;
          } else {
            commonIndex.this++;
          }
        }
        if (!commonPath) {
          throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
        }
        if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
          return "unknown";
        }
        const divergence = {
          this: paths.this[commonIndex.this - 1],
          target: paths.target[commonIndex.target - 1]
        };
        if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
          return divergence.target.key > divergence.this.key ? "before" : "after";
        }
        const keys = VISITOR_KEYS[commonPath.type];
        const keyPosition = {
          this: keys.indexOf(divergence.this.parentKey),
          target: keys.indexOf(divergence.target.parentKey)
        };
        return keyPosition.target > keyPosition.this ? "before" : "after";
      }
      var executionOrderCheckedNodes = /* @__PURE__ */ new Set();
      function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
        if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
          return "unknown";
        }
        const binding = target.scope.getBinding(target.node.id.name);
        if (!binding.references)
          return "before";
        const referencePaths = binding.referencePaths;
        let allStatus;
        for (const path of referencePaths) {
          const childOfFunction = !!path.find((path2) => path2.node === target.node);
          if (childOfFunction)
            continue;
          if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
            return "unknown";
          }
          if (executionOrderCheckedNodes.has(path.node))
            continue;
          executionOrderCheckedNodes.add(path.node);
          try {
            const status = _guessExecutionStatusRelativeToCached(base, path, cache);
            if (allStatus && allStatus !== status) {
              return "unknown";
            } else {
              allStatus = status;
            }
          } finally {
            executionOrderCheckedNodes.delete(path.node);
          }
        }
        return allStatus;
      }
      function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
        let nodeMap = cache.get(base.node);
        if (!nodeMap) {
          cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
        } else if (nodeMap.has(target.node)) {
          return nodeMap.get(target.node);
        }
        const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
        nodeMap.set(target.node, result);
        return result;
      }
      function resolve(dangerous, resolved) {
        return this._resolve(dangerous, resolved) || this;
      }
      function _resolve(dangerous, resolved) {
        if (resolved && resolved.indexOf(this) >= 0)
          return;
        resolved = resolved || [];
        resolved.push(this);
        if (this.isVariableDeclarator()) {
          if (this.get("id").isIdentifier()) {
            return this.get("init").resolve(dangerous, resolved);
          } else {
          }
        } else if (this.isReferencedIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          if (!binding)
            return;
          if (!binding.constant)
            return;
          if (binding.kind === "module")
            return;
          if (binding.path !== this) {
            const ret = binding.path.resolve(dangerous, resolved);
            if (this.find((parent) => parent.node === ret.node))
              return;
            return ret;
          }
        } else if (this.isTypeCastExpression()) {
          return this.get("expression").resolve(dangerous, resolved);
        } else if (dangerous && this.isMemberExpression()) {
          const targetKey = this.toComputedKey();
          if (!isLiteral(targetKey))
            return;
          const targetName = targetKey.value;
          const target = this.get("object").resolve(dangerous, resolved);
          if (target.isObjectExpression()) {
            const props = target.get("properties");
            for (const prop of props) {
              if (!prop.isProperty())
                continue;
              const key = prop.get("key");
              let match = prop.isnt("computed") && key.isIdentifier({
                name: targetName
              });
              match = match || key.isLiteral({
                value: targetName
              });
              if (match)
                return prop.get("value").resolve(dangerous, resolved);
            }
          } else if (target.isArrayExpression() && !isNaN(+targetName)) {
            const elems = target.get("elements");
            const elem = elems[targetName];
            if (elem)
              return elem.resolve(dangerous, resolved);
          }
        }
      }
      function isConstantExpression() {
        if (this.isIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          if (!binding)
            return false;
          return binding.constant;
        }
        if (this.isLiteral()) {
          if (this.isRegExpLiteral()) {
            return false;
          }
          if (this.isTemplateLiteral()) {
            return this.get("expressions").every((expression) => expression.isConstantExpression());
          }
          return true;
        }
        if (this.isUnaryExpression()) {
          if (this.node.operator !== "void") {
            return false;
          }
          return this.get("argument").isConstantExpression();
        }
        if (this.isBinaryExpression()) {
          return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
        }
        return false;
      }
      function isInStrictMode() {
        const start = this.isProgram() ? this : this.parentPath;
        const strictParent = start.find((path) => {
          if (path.isProgram({
            sourceType: "module"
          }))
            return true;
          if (path.isClass())
            return true;
          if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
            return false;
          }
          let body;
          if (path.isFunction()) {
            body = path.node.body;
          } else if (path.isProgram()) {
            body = path.node;
          } else {
            return false;
          }
          for (const directive of body.directives) {
            if (directive.value.value === "use strict") {
              return true;
            }
          }
        });
        return !!strictParent;
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/context.js
  var require_context = __commonJS({
    "../node_modules/@babel/traverse/lib/path/context.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._call = _call;
      exports._getQueueContexts = _getQueueContexts;
      exports._resyncKey = _resyncKey;
      exports._resyncList = _resyncList;
      exports._resyncParent = _resyncParent;
      exports._resyncRemoved = _resyncRemoved;
      exports.call = call;
      exports.isBlacklisted = exports.isDenylisted = isDenylisted;
      exports.popContext = popContext;
      exports.pushContext = pushContext;
      exports.requeue = requeue;
      exports.resync = resync;
      exports.setContext = setContext;
      exports.setKey = setKey;
      exports.setScope = setScope;
      exports.setup = setup;
      exports.skip = skip;
      exports.skipKey = skipKey;
      exports.stop = stop;
      exports.visit = visit;
      var _traverseNode = require_traverse_node();
      var _index = require_path();
      function call(key) {
        const opts = this.opts;
        this.debug(key);
        if (this.node) {
          if (this._call(opts[key]))
            return true;
        }
        if (this.node) {
          return this._call(opts[this.node.type] && opts[this.node.type][key]);
        }
        return false;
      }
      function _call(fns) {
        if (!fns)
          return false;
        for (const fn of fns) {
          if (!fn)
            continue;
          const node = this.node;
          if (!node)
            return true;
          const ret = fn.call(this.state, this, this.state);
          if (ret && typeof ret === "object" && typeof ret.then === "function") {
            throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
          if (ret) {
            throw new Error(`Unexpected return value from visitor method ${fn}`);
          }
          if (this.node !== node)
            return true;
          if (this._traverseFlags > 0)
            return true;
        }
        return false;
      }
      function isDenylisted() {
        var _this$opts$denylist;
        const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
        return denylist && denylist.indexOf(this.node.type) > -1;
      }
      function restoreContext(path, context) {
        if (path.context !== context) {
          path.context = context;
          path.state = context.state;
          path.opts = context.opts;
        }
      }
      function visit() {
        if (!this.node) {
          return false;
        }
        if (this.isDenylisted()) {
          return false;
        }
        if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
          return false;
        }
        const currentContext = this.context;
        if (this.shouldSkip || this.call("enter")) {
          this.debug("Skip...");
          return this.shouldStop;
        }
        restoreContext(this, currentContext);
        this.debug("Recursing into...");
        this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
        restoreContext(this, currentContext);
        this.call("exit");
        return this.shouldStop;
      }
      function skip() {
        this.shouldSkip = true;
      }
      function skipKey(key) {
        if (this.skipKeys == null) {
          this.skipKeys = {};
        }
        this.skipKeys[key] = true;
      }
      function stop() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
      }
      function setScope() {
        if (this.opts && this.opts.noScope)
          return;
        let path = this.parentPath;
        if ((this.key === "key" || this.listKey === "decorators") && path.isMethod()) {
          path = path.parentPath;
        }
        let target;
        while (path && !target) {
          if (path.opts && path.opts.noScope)
            return;
          target = path.scope;
          path = path.parentPath;
        }
        this.scope = this.getScope(target);
        if (this.scope)
          this.scope.init();
      }
      function setContext(context) {
        if (this.skipKeys != null) {
          this.skipKeys = {};
        }
        this._traverseFlags = 0;
        if (context) {
          this.context = context;
          this.state = context.state;
          this.opts = context.opts;
        }
        this.setScope();
        return this;
      }
      function resync() {
        if (this.removed)
          return;
        this._resyncParent();
        this._resyncList();
        this._resyncKey();
      }
      function _resyncParent() {
        if (this.parentPath) {
          this.parent = this.parentPath.node;
        }
      }
      function _resyncKey() {
        if (!this.container)
          return;
        if (this.node === this.container[this.key]) {
          return;
        }
        if (Array.isArray(this.container)) {
          for (let i = 0; i < this.container.length; i++) {
            if (this.container[i] === this.node) {
              return this.setKey(i);
            }
          }
        } else {
          for (const key of Object.keys(this.container)) {
            if (this.container[key] === this.node) {
              return this.setKey(key);
            }
          }
        }
        this.key = null;
      }
      function _resyncList() {
        if (!this.parent || !this.inList)
          return;
        const newContainer = this.parent[this.listKey];
        if (this.container === newContainer)
          return;
        this.container = newContainer || null;
      }
      function _resyncRemoved() {
        if (this.key == null || !this.container || this.container[this.key] !== this.node) {
          this._markRemoved();
        }
      }
      function popContext() {
        this.contexts.pop();
        if (this.contexts.length > 0) {
          this.setContext(this.contexts[this.contexts.length - 1]);
        } else {
          this.setContext(void 0);
        }
      }
      function pushContext(context) {
        this.contexts.push(context);
        this.setContext(context);
      }
      function setup(parentPath, container, listKey, key) {
        this.listKey = listKey;
        this.container = container;
        this.parentPath = parentPath || this.parentPath;
        this.setKey(key);
      }
      function setKey(key) {
        var _this$node;
        this.key = key;
        this.node = this.container[this.key];
        this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
      }
      function requeue(pathToQueue = this) {
        if (pathToQueue.removed)
          return;
        ;
        const contexts = this.contexts;
        for (const context of contexts) {
          context.maybeQueue(pathToQueue);
        }
      }
      function _getQueueContexts() {
        let path = this;
        let contexts = this.contexts;
        while (!contexts.length) {
          path = path.parentPath;
          if (!path)
            break;
          contexts = path.contexts;
        }
        return contexts;
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
  var require_removal_hooks = __commonJS({
    "../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hooks = void 0;
      var _ = require_path();
      var hooks = [function(self2, parent) {
        const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
        if (removeParent) {
          parent.remove();
          return true;
        }
      }, function(self2, parent) {
        if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
          parent.replaceWith(parent.node.expressions[0]);
          return true;
        }
      }, function(self2, parent) {
        if (parent.isBinary()) {
          if (self2.key === "left") {
            parent.replaceWith(parent.node.right);
          } else {
            parent.replaceWith(parent.node.left);
          }
          return true;
        }
      }, function(self2, parent) {
        if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
          self2.replaceWith({
            type: "BlockStatement",
            body: []
          });
          return true;
        }
      }];
      exports.hooks = hooks;
    }
  });

  // ../node_modules/@babel/traverse/lib/path/removal.js
  var require_removal = __commonJS({
    "../node_modules/@babel/traverse/lib/path/removal.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._assertUnremoved = _assertUnremoved;
      exports._callRemovalHooks = _callRemovalHooks;
      exports._markRemoved = _markRemoved;
      exports._remove = _remove;
      exports._removeFromScope = _removeFromScope;
      exports.remove = remove;
      var _removalHooks = require_removal_hooks();
      var _cache = require_cache();
      var _index = require_path();
      function remove() {
        var _this$opts;
        this._assertUnremoved();
        this.resync();
        if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
          this._removeFromScope();
        }
        if (this._callRemovalHooks()) {
          this._markRemoved();
          return;
        }
        this.shareCommentsWithSiblings();
        this._remove();
        this._markRemoved();
      }
      function _removeFromScope() {
        const bindings = this.getBindingIdentifiers();
        Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
      }
      function _callRemovalHooks() {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath))
            return true;
        }
      }
      function _remove() {
        if (Array.isArray(this.container)) {
          this.container.splice(this.key, 1);
          this.updateSiblingKeys(this.key, -1);
        } else {
          this._replaceWith(null);
        }
      }
      function _markRemoved() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
        if (this.parent)
          _cache.path.get(this.parent).delete(this.node);
        this.node = null;
      }
      function _assertUnremoved() {
        if (this.removed) {
          throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/lib/hoister.js
  var require_hoister = __commonJS({
    "../node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _t = require_lib3();
      var _t2 = _t;
      var {
        react
      } = _t;
      var {
        cloneNode,
        jsxExpressionContainer,
        variableDeclaration,
        variableDeclarator
      } = _t2;
      var referenceVisitor = {
        ReferencedIdentifier(path, state) {
          if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
            return;
          }
          if (path.node.name === "this") {
            let scope = path.scope;
            do {
              if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
                break;
              }
            } while (scope = scope.parent);
            if (scope)
              state.breakOnScopePaths.push(scope.path);
          }
          const binding = path.scope.getBinding(path.node.name);
          if (!binding)
            return;
          for (const violation of binding.constantViolations) {
            if (violation.scope !== binding.path.scope) {
              state.mutableBinding = true;
              path.stop();
              return;
            }
          }
          if (binding !== state.scope.getBinding(path.node.name))
            return;
          state.bindings[path.node.name] = binding;
        }
      };
      var PathHoister = class {
        constructor(path, scope) {
          this.breakOnScopePaths = void 0;
          this.bindings = void 0;
          this.mutableBinding = void 0;
          this.scopes = void 0;
          this.scope = void 0;
          this.path = void 0;
          this.attachAfter = void 0;
          this.breakOnScopePaths = [];
          this.bindings = {};
          this.mutableBinding = false;
          this.scopes = [];
          this.scope = scope;
          this.path = path;
          this.attachAfter = false;
        }
        isCompatibleScope(scope) {
          for (const key of Object.keys(this.bindings)) {
            const binding = this.bindings[key];
            if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
              return false;
            }
          }
          return true;
        }
        getCompatibleScopes() {
          let scope = this.path.scope;
          do {
            if (this.isCompatibleScope(scope)) {
              this.scopes.push(scope);
            } else {
              break;
            }
            if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
              break;
            }
          } while (scope = scope.parent);
        }
        getAttachmentPath() {
          let path = this._getAttachmentPath();
          if (!path)
            return;
          let targetScope = path.scope;
          if (targetScope.path === path) {
            targetScope = path.scope.parent;
          }
          if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
            for (const name of Object.keys(this.bindings)) {
              if (!targetScope.hasOwnBinding(name))
                continue;
              const binding = this.bindings[name];
              if (binding.kind === "param" || binding.path.parentKey === "params") {
                continue;
              }
              const bindingParentPath = this.getAttachmentParentForPath(binding.path);
              if (bindingParentPath.key >= path.key) {
                this.attachAfter = true;
                path = binding.path;
                for (const violationPath of binding.constantViolations) {
                  if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                    path = violationPath;
                  }
                }
              }
            }
          }
          return path;
        }
        _getAttachmentPath() {
          const scopes = this.scopes;
          const scope = scopes.pop();
          if (!scope)
            return;
          if (scope.path.isFunction()) {
            if (this.hasOwnParamBindings(scope)) {
              if (this.scope === scope)
                return;
              const bodies = scope.path.get("body").get("body");
              for (let i = 0; i < bodies.length; i++) {
                if (bodies[i].node._blockHoist)
                  continue;
                return bodies[i];
              }
            } else {
              return this.getNextScopeAttachmentParent();
            }
          } else if (scope.path.isProgram()) {
            return this.getNextScopeAttachmentParent();
          }
        }
        getNextScopeAttachmentParent() {
          const scope = this.scopes.pop();
          if (scope)
            return this.getAttachmentParentForPath(scope.path);
        }
        getAttachmentParentForPath(path) {
          do {
            if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
              return path;
            }
          } while (path = path.parentPath);
        }
        hasOwnParamBindings(scope) {
          for (const name of Object.keys(this.bindings)) {
            if (!scope.hasOwnBinding(name))
              continue;
            const binding = this.bindings[name];
            if (binding.kind === "param" && binding.constant)
              return true;
          }
          return false;
        }
        run() {
          this.path.traverse(referenceVisitor, this);
          if (this.mutableBinding)
            return;
          this.getCompatibleScopes();
          const attachTo = this.getAttachmentPath();
          if (!attachTo)
            return;
          if (attachTo.getFunctionParent() === this.path.getFunctionParent())
            return;
          let uid = attachTo.scope.generateUidIdentifier("ref");
          const declarator = variableDeclarator(uid, this.path.node);
          const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
          const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
          const parent = this.path.parentPath;
          if (parent.isJSXElement() && this.path.container === parent.node.children) {
            uid = jsxExpressionContainer(uid);
          }
          this.path.replaceWith(cloneNode(uid));
          return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
        }
      };
      exports.default = PathHoister;
    }
  });

  // ../node_modules/@babel/traverse/lib/path/modification.js
  var require_modification = __commonJS({
    "../node_modules/@babel/traverse/lib/path/modification.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._containerInsert = _containerInsert;
      exports._containerInsertAfter = _containerInsertAfter;
      exports._containerInsertBefore = _containerInsertBefore;
      exports._verifyNodeList = _verifyNodeList;
      exports.hoist = hoist;
      exports.insertAfter = insertAfter;
      exports.insertBefore = insertBefore;
      exports.pushContainer = pushContainer;
      exports.unshiftContainer = unshiftContainer;
      exports.updateSiblingKeys = updateSiblingKeys;
      var _cache = require_cache();
      var _hoister = require_hoister();
      var _index = require_path();
      var _t = require_lib3();
      var {
        arrowFunctionExpression,
        assertExpression,
        assignmentExpression,
        blockStatement,
        callExpression,
        cloneNode,
        expressionStatement,
        isAssignmentExpression,
        isCallExpression,
        isExpression,
        isIdentifier,
        isSequenceExpression,
        isSuper,
        thisExpression
      } = _t;
      function insertBefore(nodes_) {
        this._assertUnremoved();
        const nodes = this._verifyNodeList(nodes_);
        const {
          parentPath
        } = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
          return parentPath.insertBefore(nodes);
        } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
          if (this.node)
            nodes.push(this.node);
          return this.replaceExpressionWithStatements(nodes);
        } else if (Array.isArray(this.container)) {
          return this._containerInsertBefore(nodes);
        } else if (this.isStatementOrBlock()) {
          const node = this.node;
          const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
          this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
          return this.unshiftContainer("body", nodes);
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      function _containerInsert(from, nodes) {
        this.updateSiblingKeys(from, nodes.length);
        const paths = [];
        this.container.splice(from, 0, ...nodes);
        for (let i = 0; i < nodes.length; i++) {
          const to = from + i;
          const path = this.getSibling(to);
          paths.push(path);
          if (this.context && this.context.queue) {
            path.pushContext(this.context);
          }
        }
        const contexts = this._getQueueContexts();
        for (const path of paths) {
          path.setScope();
          path.debug("Inserted.");
          for (const context of contexts) {
            context.maybeQueue(path, true);
          }
        }
        return paths;
      }
      function _containerInsertBefore(nodes) {
        return this._containerInsert(this.key, nodes);
      }
      function _containerInsertAfter(nodes) {
        return this._containerInsert(this.key + 1, nodes);
      }
      var last = (arr) => arr[arr.length - 1];
      function isHiddenInSequenceExpression(path) {
        return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
      }
      function isAlmostConstantAssignment(node, scope) {
        if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
          return false;
        }
        const blockScope = scope.getBlockParent();
        return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
      }
      function insertAfter(nodes_) {
        this._assertUnremoved();
        if (this.isSequenceExpression()) {
          return last(this.get("expressions")).insertAfter(nodes_);
        }
        const nodes = this._verifyNodeList(nodes_);
        const {
          parentPath
        } = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
          return parentPath.insertAfter(nodes.map((node) => {
            return isExpression(node) ? expressionStatement(node) : node;
          }));
        } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
          if (this.node) {
            const node = this.node;
            let {
              scope
            } = this;
            if (scope.path.isPattern()) {
              assertExpression(node);
              this.replaceWith(callExpression(arrowFunctionExpression([], node), []));
              this.get("callee.body").insertAfter(nodes);
              return [this];
            }
            if (isHiddenInSequenceExpression(this)) {
              nodes.unshift(node);
            } else if (isCallExpression(node) && isSuper(node.callee)) {
              nodes.unshift(node);
              nodes.push(thisExpression());
            } else if (isAlmostConstantAssignment(node, scope)) {
              nodes.unshift(node);
              nodes.push(cloneNode(node.left));
            } else if (scope.isPure(node, true)) {
              nodes.push(node);
            } else {
              if (parentPath.isMethod({
                computed: true,
                key: node
              })) {
                scope = scope.parent;
              }
              const temp = scope.generateDeclaredUidIdentifier();
              nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
              nodes.push(expressionStatement(cloneNode(temp)));
            }
          }
          return this.replaceExpressionWithStatements(nodes);
        } else if (Array.isArray(this.container)) {
          return this._containerInsertAfter(nodes);
        } else if (this.isStatementOrBlock()) {
          const node = this.node;
          const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
          this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
          return this.pushContainer("body", nodes);
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      function updateSiblingKeys(fromIndex, incrementBy) {
        if (!this.parent)
          return;
        const paths = _cache.path.get(this.parent);
        for (const [, path] of paths) {
          if (path.key >= fromIndex) {
            path.key += incrementBy;
          }
        }
      }
      function _verifyNodeList(nodes) {
        if (!nodes) {
          return [];
        }
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          let msg;
          if (!node) {
            msg = "has falsy node";
          } else if (typeof node !== "object") {
            msg = "contains a non-object node";
          } else if (!node.type) {
            msg = "without a type";
          } else if (node instanceof _index.default) {
            msg = "has a NodePath when it expected a raw object";
          }
          if (msg) {
            const type = Array.isArray(node) ? "array" : typeof node;
            throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
          }
        }
        return nodes;
      }
      function unshiftContainer(listKey, nodes) {
        this._assertUnremoved();
        nodes = this._verifyNodeList(nodes);
        const path = _index.default.get({
          parentPath: this,
          parent: this.node,
          container: this.node[listKey],
          listKey,
          key: 0
        }).setContext(this.context);
        return path._containerInsertBefore(nodes);
      }
      function pushContainer(listKey, nodes) {
        this._assertUnremoved();
        const verifiedNodes = this._verifyNodeList(nodes);
        const container = this.node[listKey];
        const path = _index.default.get({
          parentPath: this,
          parent: this.node,
          container,
          listKey,
          key: container.length
        }).setContext(this.context);
        return path.replaceWithMultiple(verifiedNodes);
      }
      function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/family.js
  var require_family = __commonJS({
    "../node_modules/@babel/traverse/lib/path/family.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._getKey = _getKey;
      exports._getPattern = _getPattern;
      exports.get = get;
      exports.getAllNextSiblings = getAllNextSiblings;
      exports.getAllPrevSiblings = getAllPrevSiblings;
      exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
      exports.getBindingIdentifiers = getBindingIdentifiers;
      exports.getCompletionRecords = getCompletionRecords;
      exports.getNextSibling = getNextSibling;
      exports.getOpposite = getOpposite;
      exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
      exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
      exports.getPrevSibling = getPrevSibling;
      exports.getSibling = getSibling;
      var _index = require_path();
      var _t = require_lib3();
      var {
        getBindingIdentifiers: _getBindingIdentifiers,
        getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
        isDeclaration,
        numericLiteral,
        unaryExpression
      } = _t;
      var NORMAL_COMPLETION = 0;
      var BREAK_COMPLETION = 1;
      function NormalCompletion(path) {
        return {
          type: NORMAL_COMPLETION,
          path
        };
      }
      function BreakCompletion(path) {
        return {
          type: BREAK_COMPLETION,
          path
        };
      }
      function getOpposite() {
        if (this.key === "left") {
          return this.getSibling("right");
        } else if (this.key === "right") {
          return this.getSibling("left");
        }
        return null;
      }
      function addCompletionRecords(path, records, context) {
        if (path) {
          records.push(..._getCompletionRecords(path, context));
        }
        return records;
      }
      function completionRecordForSwitch(cases, records, context) {
        let lastNormalCompletions = [];
        for (let i = 0; i < cases.length; i++) {
          const casePath = cases[i];
          const caseCompletions = _getCompletionRecords(casePath, context);
          const normalCompletions = [];
          const breakCompletions = [];
          for (const c of caseCompletions) {
            if (c.type === NORMAL_COMPLETION) {
              normalCompletions.push(c);
            }
            if (c.type === BREAK_COMPLETION) {
              breakCompletions.push(c);
            }
          }
          if (normalCompletions.length) {
            lastNormalCompletions = normalCompletions;
          }
          records.push(...breakCompletions);
        }
        records.push(...lastNormalCompletions);
        return records;
      }
      function normalCompletionToBreak(completions) {
        completions.forEach((c) => {
          c.type = BREAK_COMPLETION;
        });
      }
      function replaceBreakStatementInBreakCompletion(completions, reachable) {
        completions.forEach((c) => {
          if (c.path.isBreakStatement({
            label: null
          })) {
            if (reachable) {
              c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
            } else {
              c.path.remove();
            }
          }
        });
      }
      function getStatementListCompletion(paths, context) {
        const completions = [];
        if (context.canHaveBreak) {
          let lastNormalCompletions = [];
          for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            const newContext = Object.assign({}, context, {
              inCaseClause: false
            });
            if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
              newContext.shouldPopulateBreak = true;
            } else {
              newContext.shouldPopulateBreak = false;
            }
            const statementCompletions = _getCompletionRecords(path, newContext);
            if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
              if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
                label: null
              }))) {
                normalCompletionToBreak(lastNormalCompletions);
                completions.push(...lastNormalCompletions);
                if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                  completions.push(...statementCompletions);
                  replaceBreakStatementInBreakCompletion(statementCompletions, true);
                }
                replaceBreakStatementInBreakCompletion(statementCompletions, false);
              } else {
                completions.push(...statementCompletions);
                if (!context.shouldPopulateBreak) {
                  replaceBreakStatementInBreakCompletion(statementCompletions, true);
                }
              }
              break;
            }
            if (i === paths.length - 1) {
              completions.push(...statementCompletions);
            } else {
              lastNormalCompletions = [];
              for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                const c = statementCompletions[i2];
                if (c.type === BREAK_COMPLETION) {
                  completions.push(c);
                }
                if (c.type === NORMAL_COMPLETION) {
                  lastNormalCompletions.push(c);
                }
              }
            }
          }
        } else if (paths.length) {
          for (let i = paths.length - 1; i >= 0; i--) {
            const pathCompletions = _getCompletionRecords(paths[i], context);
            if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
              completions.push(...pathCompletions);
              break;
            }
          }
        }
        return completions;
      }
      function _getCompletionRecords(path, context) {
        let records = [];
        if (path.isIfStatement()) {
          records = addCompletionRecords(path.get("consequent"), records, context);
          records = addCompletionRecords(path.get("alternate"), records, context);
        } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
          return addCompletionRecords(path.get("body"), records, context);
        } else if (path.isProgram() || path.isBlockStatement()) {
          return getStatementListCompletion(path.get("body"), context);
        } else if (path.isFunction()) {
          return _getCompletionRecords(path.get("body"), context);
        } else if (path.isTryStatement()) {
          records = addCompletionRecords(path.get("block"), records, context);
          records = addCompletionRecords(path.get("handler"), records, context);
        } else if (path.isCatchClause()) {
          return addCompletionRecords(path.get("body"), records, context);
        } else if (path.isSwitchStatement()) {
          return completionRecordForSwitch(path.get("cases"), records, context);
        } else if (path.isSwitchCase()) {
          return getStatementListCompletion(path.get("consequent"), {
            canHaveBreak: true,
            shouldPopulateBreak: false,
            inCaseClause: true
          });
        } else if (path.isBreakStatement()) {
          records.push(BreakCompletion(path));
        } else {
          records.push(NormalCompletion(path));
        }
        return records;
      }
      function getCompletionRecords() {
        const records = _getCompletionRecords(this, {
          canHaveBreak: false,
          shouldPopulateBreak: false,
          inCaseClause: false
        });
        return records.map((r) => r.path);
      }
      function getSibling(key) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: this.parent,
          container: this.container,
          listKey: this.listKey,
          key
        }).setContext(this.context);
      }
      function getPrevSibling() {
        return this.getSibling(this.key - 1);
      }
      function getNextSibling() {
        return this.getSibling(this.key + 1);
      }
      function getAllNextSiblings() {
        let _key = this.key;
        let sibling = this.getSibling(++_key);
        const siblings = [];
        while (sibling.node) {
          siblings.push(sibling);
          sibling = this.getSibling(++_key);
        }
        return siblings;
      }
      function getAllPrevSiblings() {
        let _key = this.key;
        let sibling = this.getSibling(--_key);
        const siblings = [];
        while (sibling.node) {
          siblings.push(sibling);
          sibling = this.getSibling(--_key);
        }
        return siblings;
      }
      function get(key, context = true) {
        if (context === true)
          context = this.context;
        const parts = key.split(".");
        if (parts.length === 1) {
          return this._getKey(key, context);
        } else {
          return this._getPattern(parts, context);
        }
      }
      function _getKey(key, context) {
        const node = this.node;
        const container = node[key];
        if (Array.isArray(container)) {
          return container.map((_, i) => {
            return _index.default.get({
              listKey: key,
              parentPath: this,
              parent: node,
              container,
              key: i
            }).setContext(context);
          });
        } else {
          return _index.default.get({
            parentPath: this,
            parent: node,
            container: node,
            key
          }).setContext(context);
        }
      }
      function _getPattern(parts, context) {
        let path = this;
        for (const part of parts) {
          if (part === ".") {
            path = path.parentPath;
          } else {
            if (Array.isArray(path)) {
              path = path[part];
            } else {
              path = path.get(part, context);
            }
          }
        }
        return path;
      }
      function getBindingIdentifiers(duplicates) {
        return _getBindingIdentifiers(this.node, duplicates);
      }
      function getOuterBindingIdentifiers(duplicates) {
        return _getOuterBindingIdentifiers(this.node, duplicates);
      }
      function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
        const path = this;
        const search = [path];
        const ids = /* @__PURE__ */ Object.create(null);
        while (search.length) {
          const id = search.shift();
          if (!id)
            continue;
          if (!id.node)
            continue;
          const keys = _getBindingIdentifiers.keys[id.node.type];
          if (id.isIdentifier()) {
            if (duplicates) {
              const _ids = ids[id.node.name] = ids[id.node.name] || [];
              _ids.push(id);
            } else {
              ids[id.node.name] = id;
            }
            continue;
          }
          if (id.isExportDeclaration()) {
            const declaration = id.get("declaration");
            if (isDeclaration(declaration)) {
              search.push(declaration);
            }
            continue;
          }
          if (outerOnly) {
            if (id.isFunctionDeclaration()) {
              search.push(id.get("id"));
              continue;
            }
            if (id.isFunctionExpression()) {
              continue;
            }
          }
          if (keys) {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const child = id.get(key);
              if (Array.isArray(child)) {
                search.push(...child);
              } else if (child.node) {
                search.push(child);
              }
            }
          }
        }
        return ids;
      }
      function getOuterBindingIdentifierPaths(duplicates = false) {
        return this.getBindingIdentifierPaths(duplicates, true);
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/comments.js
  var require_comments = __commonJS({
    "../node_modules/@babel/traverse/lib/path/comments.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addComment = addComment;
      exports.addComments = addComments;
      exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
      var _t = require_lib3();
      var {
        addComment: _addComment,
        addComments: _addComments
      } = _t;
      function shareCommentsWithSiblings() {
        if (typeof this.key === "string")
          return;
        const node = this.node;
        if (!node)
          return;
        const trailing = node.trailingComments;
        const leading = node.leadingComments;
        if (!trailing && !leading)
          return;
        const prev = this.getSibling(this.key - 1);
        const next = this.getSibling(this.key + 1);
        const hasPrev = Boolean(prev.node);
        const hasNext = Boolean(next.node);
        if (hasPrev && !hasNext) {
          prev.addComments("trailing", trailing);
        } else if (hasNext && !hasPrev) {
          next.addComments("leading", leading);
        }
      }
      function addComment(type, content, line) {
        _addComment(this.node, type, content, line);
      }
      function addComments(type, comments) {
        _addComments(this.node, type, comments);
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
  var require_virtual_types_validator = __commonJS({
    "../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isBindingIdentifier = isBindingIdentifier;
      exports.isBlockScoped = isBlockScoped;
      exports.isExistentialTypeParam = isExistentialTypeParam;
      exports.isExpression = isExpression;
      exports.isFlow = isFlow;
      exports.isForAwaitStatement = isForAwaitStatement;
      exports.isGenerated = isGenerated;
      exports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;
      exports.isPure = isPure;
      exports.isReferenced = isReferenced;
      exports.isReferencedIdentifier = isReferencedIdentifier;
      exports.isReferencedMemberExpression = isReferencedMemberExpression;
      exports.isRestProperty = isRestProperty;
      exports.isScope = isScope;
      exports.isSpreadProperty = isSpreadProperty;
      exports.isStatement = isStatement;
      exports.isUser = isUser;
      exports.isVar = isVar;
      var _t = require_lib3();
      var {
        isBinding,
        isBlockScoped: nodeIsBlockScoped,
        isExportDeclaration,
        isExpression: nodeIsExpression,
        isFlow: nodeIsFlow,
        isForStatement,
        isForXStatement,
        isIdentifier,
        isImportDeclaration,
        isImportSpecifier,
        isJSXIdentifier,
        isJSXMemberExpression,
        isMemberExpression,
        isRestElement: nodeIsRestElement,
        isReferenced: nodeIsReferenced,
        isScope: nodeIsScope,
        isStatement: nodeIsStatement,
        isVar: nodeIsVar,
        isVariableDeclaration,
        react
      } = _t;
      var {
        isCompatTag
      } = react;
      function isReferencedIdentifier(opts) {
        const {
          node,
          parent
        } = this;
        if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
          if (isJSXIdentifier(node, opts)) {
            if (isCompatTag(node.name))
              return false;
          } else {
            return false;
          }
        }
        return nodeIsReferenced(node, parent, this.parentPath.parent);
      }
      function isReferencedMemberExpression() {
        const {
          node,
          parent
        } = this;
        return isMemberExpression(node) && nodeIsReferenced(node, parent);
      }
      function isBindingIdentifier() {
        const {
          node,
          parent
        } = this;
        const grandparent = this.parentPath.parent;
        return isIdentifier(node) && isBinding(node, parent, grandparent);
      }
      function isStatement() {
        const {
          node,
          parent
        } = this;
        if (nodeIsStatement(node)) {
          if (isVariableDeclaration(node)) {
            if (isForXStatement(parent, {
              left: node
            }))
              return false;
            if (isForStatement(parent, {
              init: node
            }))
              return false;
          }
          return true;
        } else {
          return false;
        }
      }
      function isExpression() {
        if (this.isIdentifier()) {
          return this.isReferencedIdentifier();
        } else {
          return nodeIsExpression(this.node);
        }
      }
      function isScope() {
        return nodeIsScope(this.node, this.parent);
      }
      function isReferenced() {
        return nodeIsReferenced(this.node, this.parent);
      }
      function isBlockScoped() {
        return nodeIsBlockScoped(this.node);
      }
      function isVar() {
        return nodeIsVar(this.node);
      }
      function isUser() {
        return this.node && !!this.node.loc;
      }
      function isGenerated() {
        return !this.isUser();
      }
      function isPure(constantsOnly) {
        return this.scope.isPure(this.node, constantsOnly);
      }
      function isFlow() {
        const {
          node
        } = this;
        if (nodeIsFlow(node)) {
          return true;
        } else if (isImportDeclaration(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else if (isExportDeclaration(node)) {
          return node.exportKind === "type";
        } else if (isImportSpecifier(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else {
          return false;
        }
      }
      function isRestProperty() {
        return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
      }
      function isSpreadProperty() {
        return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
      }
      function isForAwaitStatement() {
        return isForStatement(this.node, {
          await: true
        });
      }
      function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      }
      function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/path/index.js
  var require_path = __commonJS({
    "../node_modules/@babel/traverse/lib/path/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
      var virtualTypes = require_virtual_types();
      var _debug = require_browser();
      var _index = require_lib13();
      var _scope = require_scope();
      var _t = require_lib3();
      var t2 = _t;
      var _cache = require_cache();
      var _generator = require_lib4();
      var NodePath_ancestry = require_ancestry();
      var NodePath_inference = require_inference();
      var NodePath_replacement = require_replacement();
      var NodePath_evaluation = require_evaluation();
      var NodePath_conversion = require_conversion();
      var NodePath_introspection = require_introspection();
      var NodePath_context = require_context();
      var NodePath_removal = require_removal();
      var NodePath_modification = require_modification();
      var NodePath_family = require_family();
      var NodePath_comments = require_comments();
      var NodePath_virtual_types_validator = require_virtual_types_validator();
      var {
        validate
      } = _t;
      var debug = _debug("babel");
      var REMOVED = 1 << 0;
      exports.REMOVED = REMOVED;
      var SHOULD_STOP = 1 << 1;
      exports.SHOULD_STOP = SHOULD_STOP;
      var SHOULD_SKIP = 1 << 2;
      exports.SHOULD_SKIP = SHOULD_SKIP;
      var NodePath = class {
        constructor(hub, parent) {
          this.contexts = [];
          this.state = null;
          this.opts = null;
          this._traverseFlags = 0;
          this.skipKeys = null;
          this.parentPath = null;
          this.container = null;
          this.listKey = null;
          this.key = null;
          this.node = null;
          this.type = null;
          this.parent = parent;
          this.hub = hub;
          this.data = null;
          this.context = null;
          this.scope = null;
        }
        static get({
          hub,
          parentPath,
          parent,
          container,
          listKey,
          key
        }) {
          if (!hub && parentPath) {
            hub = parentPath.hub;
          }
          if (!parent) {
            throw new Error("To get a node path the parent needs to exist");
          }
          const targetNode = container[key];
          let paths = _cache.path.get(parent);
          if (!paths) {
            paths = /* @__PURE__ */ new Map();
            _cache.path.set(parent, paths);
          }
          let path = paths.get(targetNode);
          if (!path) {
            path = new NodePath(hub, parent);
            if (targetNode)
              paths.set(targetNode, path);
          }
          path.setup(parentPath, container, listKey, key);
          return path;
        }
        getScope(scope) {
          return this.isScope() ? new _scope.default(this) : scope;
        }
        setData(key, val) {
          if (this.data == null) {
            this.data = /* @__PURE__ */ Object.create(null);
          }
          return this.data[key] = val;
        }
        getData(key, def) {
          if (this.data == null) {
            this.data = /* @__PURE__ */ Object.create(null);
          }
          let val = this.data[key];
          if (val === void 0 && def !== void 0)
            val = this.data[key] = def;
          return val;
        }
        hasNode() {
          return this.node != null;
        }
        buildCodeFrameError(msg, Error2 = SyntaxError) {
          return this.hub.buildError(this.node, msg, Error2);
        }
        traverse(visitor, state) {
          (0, _index.default)(this.node, visitor, this.scope, state, this);
        }
        set(key, node) {
          validate(this.node, key, node);
          this.node[key] = node;
        }
        getPathLocation() {
          const parts = [];
          let path = this;
          do {
            let key = path.key;
            if (path.inList)
              key = `${path.listKey}[${key}]`;
            parts.unshift(key);
          } while (path = path.parentPath);
          return parts.join(".");
        }
        debug(message) {
          if (!debug.enabled)
            return;
          debug(`${this.getPathLocation()} ${this.type}: ${message}`);
        }
        toString() {
          return (0, _generator.default)(this.node).code;
        }
        get inList() {
          return !!this.listKey;
        }
        set inList(inList) {
          if (!inList) {
            this.listKey = null;
          }
        }
        get parentKey() {
          return this.listKey || this.key;
        }
        get shouldSkip() {
          return !!(this._traverseFlags & SHOULD_SKIP);
        }
        set shouldSkip(v) {
          if (v) {
            this._traverseFlags |= SHOULD_SKIP;
          } else {
            this._traverseFlags &= ~SHOULD_SKIP;
          }
        }
        get shouldStop() {
          return !!(this._traverseFlags & SHOULD_STOP);
        }
        set shouldStop(v) {
          if (v) {
            this._traverseFlags |= SHOULD_STOP;
          } else {
            this._traverseFlags &= ~SHOULD_STOP;
          }
        }
        get removed() {
          return !!(this._traverseFlags & REMOVED);
        }
        set removed(v) {
          if (v) {
            this._traverseFlags |= REMOVED;
          } else {
            this._traverseFlags &= ~REMOVED;
          }
        }
      };
      Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
      {
        NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      }
      for (const type of t2.TYPES) {
        const typeKey = `is${type}`;
        const fn = t2[typeKey];
        NodePath.prototype[typeKey] = function(opts) {
          return fn(this.node, opts);
        };
        NodePath.prototype[`assert${type}`] = function(opts) {
          if (!fn(this.node, opts)) {
            throw new TypeError(`Expected node path of type ${type}`);
          }
        };
      }
      Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
      for (const type of Object.keys(virtualTypes)) {
        if (type[0] === "_")
          continue;
        if (!t2.TYPES.includes(type))
          t2.TYPES.push(type);
      }
      var _default = NodePath;
      exports.default = _default;
    }
  });

  // ../node_modules/@babel/traverse/lib/context.js
  var require_context2 = __commonJS({
    "../node_modules/@babel/traverse/lib/context.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _path = require_path();
      var _t = require_lib3();
      var {
        VISITOR_KEYS
      } = _t;
      var TraversalContext = class {
        constructor(scope, opts, state, parentPath) {
          this.queue = null;
          this.priorityQueue = null;
          this.parentPath = parentPath;
          this.scope = scope;
          this.state = state;
          this.opts = opts;
        }
        shouldVisit(node) {
          const opts = this.opts;
          if (opts.enter || opts.exit)
            return true;
          if (opts[node.type])
            return true;
          const keys = VISITOR_KEYS[node.type];
          if (!(keys != null && keys.length))
            return false;
          for (const key of keys) {
            if (node[key]) {
              return true;
            }
          }
          return false;
        }
        create(node, container, key, listKey) {
          return _path.default.get({
            parentPath: this.parentPath,
            parent: node,
            container,
            key,
            listKey
          });
        }
        maybeQueue(path, notPriority) {
          if (this.queue) {
            if (notPriority) {
              this.queue.push(path);
            } else {
              this.priorityQueue.push(path);
            }
          }
        }
        visitMultiple(container, parent, listKey) {
          if (container.length === 0)
            return false;
          const queue = [];
          for (let key = 0; key < container.length; key++) {
            const node = container[key];
            if (node && this.shouldVisit(node)) {
              queue.push(this.create(parent, container, key, listKey));
            }
          }
          return this.visitQueue(queue);
        }
        visitSingle(node, key) {
          if (this.shouldVisit(node[key])) {
            return this.visitQueue([this.create(node, node, key)]);
          } else {
            return false;
          }
        }
        visitQueue(queue) {
          this.queue = queue;
          this.priorityQueue = [];
          const visited = /* @__PURE__ */ new WeakSet();
          let stop = false;
          for (const path of queue) {
            path.resync();
            if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
              path.pushContext(this);
            }
            if (path.key === null)
              continue;
            const {
              node
            } = path;
            if (visited.has(node))
              continue;
            if (node)
              visited.add(node);
            if (path.visit()) {
              stop = true;
              break;
            }
            if (this.priorityQueue.length) {
              stop = this.visitQueue(this.priorityQueue);
              this.priorityQueue = [];
              this.queue = queue;
              if (stop)
                break;
            }
          }
          for (const path of queue) {
            path.popContext();
          }
          this.queue = null;
          return stop;
        }
        visit(node, key) {
          const nodes = node[key];
          if (!nodes)
            return false;
          if (Array.isArray(nodes)) {
            return this.visitMultiple(nodes, node, key);
          } else {
            return this.visitSingle(node, key);
          }
        }
      };
      exports.default = TraversalContext;
    }
  });

  // ../node_modules/@babel/traverse/lib/traverse-node.js
  var require_traverse_node = __commonJS({
    "../node_modules/@babel/traverse/lib/traverse-node.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.traverseNode = traverseNode;
      var _context = require_context2();
      var _t = require_lib3();
      var {
        VISITOR_KEYS
      } = _t;
      function traverseNode(node, opts, scope, state, path, skipKeys) {
        const keys = VISITOR_KEYS[node.type];
        if (!keys)
          return false;
        const context = new _context.default(scope, opts, state, path);
        for (const key of keys) {
          if (skipKeys && skipKeys[key])
            continue;
          if (context.visit(node, key)) {
            return true;
          }
        }
        return false;
      }
    }
  });

  // ../node_modules/@babel/traverse/lib/hub.js
  var require_hub = __commonJS({
    "../node_modules/@babel/traverse/lib/hub.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var Hub = class {
        getCode() {
        }
        getScope() {
        }
        addHelper() {
          throw new Error("Helpers are not supported by the default hub.");
        }
        buildError(node, msg, Error2 = TypeError) {
          return new Error2(msg);
        }
      };
      exports.default = Hub;
    }
  });

  // ../node_modules/@babel/traverse/lib/index.js
  var require_lib13 = __commonJS({
    "../node_modules/@babel/traverse/lib/index.js"(exports) {
      "use strict";
      init_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "Hub", {
        enumerable: true,
        get: function() {
          return _hub.default;
        }
      });
      Object.defineProperty(exports, "NodePath", {
        enumerable: true,
        get: function() {
          return _path.default;
        }
      });
      Object.defineProperty(exports, "Scope", {
        enumerable: true,
        get: function() {
          return _scope.default;
        }
      });
      exports.visitors = exports.default = void 0;
      var visitors = require_visitors();
      exports.visitors = visitors;
      var _t = require_lib3();
      var cache = require_cache();
      var _traverseNode = require_traverse_node();
      var _path = require_path();
      var _scope = require_scope();
      var _hub = require_hub();
      var {
        VISITOR_KEYS,
        removeProperties,
        traverseFast
      } = _t;
      function traverse2(parent, opts = {}, scope, state, parentPath) {
        if (!parent)
          return;
        if (!opts.noScope && !scope) {
          if (parent.type !== "Program" && parent.type !== "File") {
            throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
          }
        }
        if (!VISITOR_KEYS[parent.type]) {
          return;
        }
        visitors.explode(opts);
        (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath);
      }
      var _default = traverse2;
      exports.default = _default;
      traverse2.visitors = visitors;
      traverse2.verify = visitors.verify;
      traverse2.explode = visitors.explode;
      traverse2.cheap = function(node, enter) {
        return traverseFast(node, enter);
      };
      traverse2.node = function(node, opts, scope, state, path, skipKeys) {
        (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
      };
      traverse2.clearNode = function(node, opts) {
        removeProperties(node, opts);
        cache.path.delete(node);
      };
      traverse2.removeProperties = function(tree, opts) {
        traverseFast(tree, traverse2.clearNode, opts);
        return tree;
      };
      function hasDenylistedType(path, state) {
        if (path.node.type === state.type) {
          state.has = true;
          path.stop();
        }
      }
      traverse2.hasType = function(tree, type, denylistTypes) {
        if (denylistTypes != null && denylistTypes.includes(tree.type))
          return false;
        if (tree.type === type)
          return true;
        const state = {
          has: false,
          type
        };
        traverse2(tree, {
          noScope: true,
          denylist: denylistTypes,
          enter: hasDenylistedType
        }, null, state);
        return state.has;
      };
      traverse2.cache = cache;
    }
  });

  // src/playground.tsx
  init_inject();

  // node_modules/solid-js/web/dist/web.js
  init_inject();

  // node_modules/solid-js/dist/solid.js
  init_inject();
  var sharedConfig = {};
  function setHydrateContext(context) {
    sharedConfig.context = context;
  }
  function nextHydrateContext() {
    return {
      ...sharedConfig.context,
      id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
      count: 0
    };
  }
  var equalFn = (a, b) => a === b;
  var $PROXY = Symbol("solid-proxy");
  var $TRACK = Symbol("solid-track");
  var $DEVCOMP = Symbol("solid-dev-component");
  var signalOptions = {
    equals: equalFn
  };
  var ERROR = null;
  var runEffects = runQueue;
  var STALE = 1;
  var PENDING = 2;
  var UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  };
  var Owner = null;
  var Transition = null;
  var Scheduler = null;
  var ExternalSourceFactory = null;
  var Listener = null;
  var Updates = null;
  var Effects = null;
  var ExecCount = 0;
  var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
  function createRoot(fn, detachedOwner) {
    const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned && true ? UNOWNED : {
      owned: null,
      cleanups: null,
      context: null,
      owner: detachedOwner || owner
    }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
    Owner = root;
    Listener = null;
    try {
      return runUpdates(updateFn, true);
    } finally {
      Listener = listener;
      Owner = owner;
    }
  }
  function createSignal(value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const s = {
      value,
      observers: null,
      observerSlots: null,
      comparator: options.equals || void 0
    };
    const setter = (value2) => {
      if (typeof value2 === "function") {
        if (Transition && Transition.running && Transition.sources.has(s))
          value2 = value2(s.tValue);
        else
          value2 = value2(s.value);
      }
      return writeSignal(s, value2);
    };
    return [readSignal.bind(s), setter];
  }
  function createRenderEffect(fn, value, options) {
    const c = createComputation(fn, value, false, STALE);
    if (Scheduler && Transition && Transition.running)
      Updates.push(c);
    else
      updateComputation(c);
  }
  function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const c = createComputation(fn, value, true, 0);
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || void 0;
    if (Scheduler && Transition && Transition.running) {
      c.tState = STALE;
      Updates.push(c);
    } else
      updateComputation(c);
    return readSignal.bind(c);
  }
  function untrack(fn) {
    let result, listener = Listener;
    Listener = null;
    result = fn();
    Listener = listener;
    return result;
  }
  function onCleanup(fn) {
    if (Owner === null)
      ;
    else if (Owner.cleanups === null)
      Owner.cleanups = [fn];
    else
      Owner.cleanups.push(fn);
    return fn;
  }
  function startTransition(fn) {
    if (Transition && Transition.running) {
      fn();
      return Transition.done;
    }
    const l = Listener;
    const o = Owner;
    return Promise.resolve().then(() => {
      Listener = l;
      Owner = o;
      let t2;
      if (Scheduler || SuspenseContext) {
        t2 = Transition || (Transition = {
          sources: /* @__PURE__ */ new Set(),
          effects: [],
          promises: /* @__PURE__ */ new Set(),
          disposed: /* @__PURE__ */ new Set(),
          queue: /* @__PURE__ */ new Set(),
          running: true
        });
        t2.done || (t2.done = new Promise((res) => t2.resolve = res));
        t2.running = true;
      }
      runUpdates(fn, false);
      Listener = Owner = null;
      return t2 ? t2.done : void 0;
    });
  }
  function createContext(defaultValue) {
    const id = Symbol("context");
    return {
      id,
      Provider: createProvider(id),
      defaultValue
    };
  }
  function children(fn) {
    const children2 = createMemo(fn);
    const memo = createMemo(() => resolveChildren(children2()));
    memo.toArray = () => {
      const c = memo();
      return Array.isArray(c) ? c : c != null ? [c] : [];
    };
    return memo;
  }
  var SuspenseContext;
  function readSignal() {
    const runningTransition = Transition && Transition.running;
    if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {
      if (!runningTransition && this.state === STALE || runningTransition && this.tState === STALE)
        updateComputation(this);
      else {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(this), false);
        Updates = updates;
      }
    }
    if (Listener) {
      const sSlot = this.observers ? this.observers.length : 0;
      if (!Listener.sources) {
        Listener.sources = [this];
        Listener.sourceSlots = [sSlot];
      } else {
        Listener.sources.push(this);
        Listener.sourceSlots.push(sSlot);
      }
      if (!this.observers) {
        this.observers = [Listener];
        this.observerSlots = [Listener.sources.length - 1];
      } else {
        this.observers.push(Listener);
        this.observerSlots.push(Listener.sources.length - 1);
      }
    }
    if (runningTransition && Transition.sources.has(this))
      return this.tValue;
    return this.value;
  }
  function writeSignal(node, value, isComp) {
    let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
    if (!node.comparator || !node.comparator(current, value)) {
      if (Transition) {
        const TransitionRunning = Transition.running;
        if (TransitionRunning || !isComp && Transition.sources.has(node)) {
          Transition.sources.add(node);
          node.tValue = value;
        }
        if (!TransitionRunning)
          node.value = value;
      } else
        node.value = value;
      if (node.observers && node.observers.length) {
        runUpdates(() => {
          for (let i = 0; i < node.observers.length; i += 1) {
            const o = node.observers[i];
            const TransitionRunning = Transition && Transition.running;
            if (TransitionRunning && Transition.disposed.has(o))
              continue;
            if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
              if (o.pure)
                Updates.push(o);
              else
                Effects.push(o);
              if (o.observers)
                markDownstream(o);
            }
            if (TransitionRunning)
              o.tState = STALE;
            else
              o.state = STALE;
          }
          if (Updates.length > 1e6) {
            Updates = [];
            if (false)
              ;
            throw new Error();
          }
        }, false);
      }
    }
    return value;
  }
  function updateComputation(node) {
    if (!node.fn)
      return;
    cleanNode(node);
    const owner = Owner, listener = Listener, time = ExecCount;
    Listener = Owner = node;
    runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
    if (Transition && !Transition.running && Transition.sources.has(node)) {
      queueMicrotask(() => {
        runUpdates(() => {
          Transition && (Transition.running = true);
          runComputation(node, node.tValue, time);
        }, false);
      });
    }
    Listener = listener;
    Owner = owner;
  }
  function runComputation(node, value, time) {
    let nextValue;
    try {
      nextValue = node.fn(value);
    } catch (err) {
      if (node.pure)
        Transition && Transition.running ? node.tState = STALE : node.state = STALE;
      handleError(err);
    }
    if (!node.updatedAt || node.updatedAt <= time) {
      if (node.updatedAt != null && "observers" in node) {
        writeSignal(node, nextValue, true);
      } else if (Transition && Transition.running && node.pure) {
        Transition.sources.add(node);
        node.tValue = nextValue;
      } else
        node.value = nextValue;
      node.updatedAt = time;
    }
  }
  function createComputation(fn, init, pure, state = STALE, options) {
    const c = {
      fn,
      state,
      updatedAt: null,
      owned: null,
      sources: null,
      sourceSlots: null,
      cleanups: null,
      value: init,
      owner: Owner,
      context: null,
      pure
    };
    if (Transition && Transition.running) {
      c.state = 0;
      c.tState = state;
    }
    if (Owner === null)
      ;
    else if (Owner !== UNOWNED) {
      if (Transition && Transition.running && Owner.pure) {
        if (!Owner.tOwned)
          Owner.tOwned = [c];
        else
          Owner.tOwned.push(c);
      } else {
        if (!Owner.owned)
          Owner.owned = [c];
        else
          Owner.owned.push(c);
      }
    }
    if (ExternalSourceFactory) {
      const [track, trigger] = createSignal(void 0, {
        equals: false
      });
      const ordinary = ExternalSourceFactory(c.fn, trigger);
      onCleanup(() => ordinary.dispose());
      const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
      const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);
      c.fn = (x) => {
        track();
        return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
      };
    }
    return c;
  }
  function runTop(node) {
    const runningTransition = Transition && Transition.running;
    if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0)
      return;
    if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING)
      return lookUpstream(node);
    if (node.suspense && untrack(node.suspense.inFallback))
      return node.suspense.effects.push(node);
    const ancestors = [node];
    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
      if (runningTransition && Transition.disposed.has(node))
        return;
      if (!runningTransition && node.state || runningTransition && node.tState)
        ancestors.push(node);
    }
    for (let i = ancestors.length - 1; i >= 0; i--) {
      node = ancestors[i];
      if (runningTransition) {
        let top = node, prev = ancestors[i + 1];
        while ((top = top.owner) && top !== prev) {
          if (Transition.disposed.has(top))
            return;
        }
      }
      if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {
        updateComputation(node);
      } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(node, ancestors[0]), false);
        Updates = updates;
      }
    }
  }
  function runUpdates(fn, init) {
    if (Updates)
      return fn();
    let wait = false;
    if (!init)
      Updates = [];
    if (Effects)
      wait = true;
    else
      Effects = [];
    ExecCount++;
    try {
      const res = fn();
      completeUpdates(wait);
      return res;
    } catch (err) {
      if (!Updates)
        Effects = null;
      handleError(err);
    }
  }
  function completeUpdates(wait) {
    if (Updates) {
      if (Scheduler && Transition && Transition.running)
        scheduleQueue(Updates);
      else
        runQueue(Updates);
      Updates = null;
    }
    if (wait)
      return;
    let res;
    if (Transition && Transition.running) {
      if (Transition.promises.size || Transition.queue.size) {
        Transition.running = false;
        Transition.effects.push.apply(Transition.effects, Effects);
        Effects = null;
        setTransPending(true);
        return;
      }
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d of disposed)
          cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i = 0, len = v.owned.length; i < len; i++)
              cleanNode(v.owned[i]);
          }
          if (v.tOwned)
            v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      }, false);
    }
    const e = Effects;
    Effects = null;
    if (e.length)
      runUpdates(() => runEffects(e), false);
    if (res)
      res();
  }
  function runQueue(queue) {
    for (let i = 0; i < queue.length; i++)
      runTop(queue[i]);
  }
  function scheduleQueue(queue) {
    for (let i = 0; i < queue.length; i++) {
      const item = queue[i];
      const tasks = Transition.queue;
      if (!tasks.has(item)) {
        tasks.add(item);
        Scheduler(() => {
          tasks.delete(item);
          runUpdates(() => {
            Transition.running = true;
            runTop(item);
            if (!tasks.size) {
              Effects.push.apply(Effects, Transition.effects);
              Transition.effects = [];
            }
          }, false);
          Transition && (Transition.running = false);
        });
      }
    }
  }
  function lookUpstream(node, ignore) {
    const runningTransition = Transition && Transition.running;
    if (runningTransition)
      node.tState = 0;
    else
      node.state = 0;
    for (let i = 0; i < node.sources.length; i += 1) {
      const source = node.sources[i];
      if (source.sources) {
        if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {
          if (source !== ignore)
            runTop(source);
        } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING)
          lookUpstream(source, ignore);
      }
    }
  }
  function markDownstream(node) {
    const runningTransition = Transition && Transition.running;
    for (let i = 0; i < node.observers.length; i += 1) {
      const o = node.observers[i];
      if (!runningTransition && !o.state || runningTransition && !o.tState) {
        if (runningTransition)
          o.tState = PENDING;
        else
          o.state = PENDING;
        if (o.pure)
          Updates.push(o);
        else
          Effects.push(o);
        o.observers && markDownstream(o);
      }
    }
  }
  function cleanNode(node) {
    let i;
    if (node.sources) {
      while (node.sources.length) {
        const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
        if (obs && obs.length) {
          const n = obs.pop(), s = source.observerSlots.pop();
          if (index < obs.length) {
            n.sourceSlots[s] = index;
            obs[index] = n;
            source.observerSlots[index] = s;
          }
        }
      }
    }
    if (Transition && Transition.running && node.pure) {
      if (node.tOwned) {
        for (i = 0; i < node.tOwned.length; i++)
          cleanNode(node.tOwned[i]);
        delete node.tOwned;
      }
      reset(node, true);
    } else if (node.owned) {
      for (i = 0; i < node.owned.length; i++)
        cleanNode(node.owned[i]);
      node.owned = null;
    }
    if (node.cleanups) {
      for (i = 0; i < node.cleanups.length; i++)
        node.cleanups[i]();
      node.cleanups = null;
    }
    if (Transition && Transition.running)
      node.tState = 0;
    else
      node.state = 0;
    node.context = null;
  }
  function reset(node, top) {
    if (!top) {
      node.tState = 0;
      Transition.disposed.add(node);
    }
    if (node.owned) {
      for (let i = 0; i < node.owned.length; i++)
        reset(node.owned[i]);
    }
  }
  function castError(err) {
    if (err instanceof Error || typeof err === "string")
      return err;
    return new Error("Unknown error");
  }
  function handleError(err) {
    err = castError(err);
    const fns = ERROR && lookup(Owner, ERROR);
    if (!fns)
      throw err;
    for (const f of fns)
      f(err);
  }
  function lookup(owner, key) {
    return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
  }
  function resolveChildren(children2) {
    if (typeof children2 === "function" && !children2.length)
      return resolveChildren(children2());
    if (Array.isArray(children2)) {
      const results = [];
      for (let i = 0; i < children2.length; i++) {
        const result = resolveChildren(children2[i]);
        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
      }
      return results;
    }
    return children2;
  }
  function createProvider(id) {
    return function provider(props) {
      let res;
      createRenderEffect(() => res = untrack(() => {
        Owner.context = {
          [id]: props.value
        };
        return children(() => props.children);
      }));
      return res;
    };
  }
  var FALLBACK = Symbol("fallback");
  var hydrationEnabled = false;
  function createComponent(Comp, props) {
    if (hydrationEnabled) {
      if (sharedConfig.context) {
        const c = sharedConfig.context;
        setHydrateContext(nextHydrateContext());
        const r = untrack(() => Comp(props || {}));
        setHydrateContext(c);
        return r;
      }
    }
    return untrack(() => Comp(props || {}));
  }
  var SuspenseListContext = createContext();

  // node_modules/solid-js/web/dist/web.js
  var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
  var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
  function reconcileArrays(parentNode, a, b) {
    let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
    while (aStart < aEnd || bStart < bEnd) {
      if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
        continue;
      }
      while (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      }
      if (aEnd === aStart) {
        const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
        while (bStart < bEnd)
          parentNode.insertBefore(b[bStart++], node);
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart]))
            a[aStart].remove();
          aStart++;
        }
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        const node = a[--aEnd].nextSibling;
        parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
        parentNode.insertBefore(b[--bEnd], node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = /* @__PURE__ */ new Map();
          let i = bStart;
          while (i < bEnd)
            map.set(b[i], i++);
        }
        const index = map.get(a[aStart]);
        if (index != null) {
          if (bStart < index && index < bEnd) {
            let i = aStart, sequence = 1, t2;
            while (++i < aEnd && i < bEnd) {
              if ((t2 = map.get(a[i])) == null || t2 !== index + sequence)
                break;
              sequence++;
            }
            if (sequence > index - bStart) {
              const node = a[aStart];
              while (bStart < index)
                parentNode.insertBefore(b[bStart++], node);
            } else
              parentNode.replaceChild(b[bStart++], a[aStart++]);
          } else
            aStart++;
        } else
          a[aStart++].remove();
      }
    }
  }
  var $$EVENTS = "_$DX_DELEGATE";
  function render(code, element, init) {
    let disposer;
    createRoot((dispose) => {
      disposer = dispose;
      element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
    });
    return () => {
      disposer();
      element.textContent = "";
    };
  }
  function template(html, check, isSVG) {
    const t2 = document.createElement("template");
    t2.innerHTML = html;
    let node = t2.content.firstChild;
    if (isSVG)
      node = node.firstChild;
    return node;
  }
  function delegateEvents(eventNames, document2 = window.document) {
    const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
    for (let i = 0, l = eventNames.length; i < l; i++) {
      const name = eventNames[i];
      if (!e.has(name)) {
        e.add(name);
        document2.addEventListener(name, eventHandler);
      }
    }
  }
  function setAttribute(node, name, value) {
    if (value == null)
      node.removeAttribute(name);
    else
      node.setAttribute(name, value);
  }
  function className(node, value) {
    if (value == null)
      node.removeAttribute("class");
    else
      node.className = value;
  }
  function insert(parent, accessor, marker, initial) {
    if (marker !== void 0 && !initial)
      initial = [];
    if (typeof accessor !== "function")
      return insertExpression(parent, accessor, initial, marker);
    createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
  }
  function eventHandler(e) {
    const key = `$$${e.type}`;
    let node = e.composedPath && e.composedPath()[0] || e.target;
    if (e.target !== node) {
      Object.defineProperty(e, "target", {
        configurable: true,
        value: node
      });
    }
    Object.defineProperty(e, "currentTarget", {
      configurable: true,
      get() {
        return node || document;
      }
    });
    if (sharedConfig.registry && !sharedConfig.done) {
      sharedConfig.done = true;
      document.querySelectorAll("[id^=pl-]").forEach((elem) => elem.remove());
    }
    while (node !== null) {
      const handler = node[key];
      if (handler && !node.disabled) {
        const data = node[`${key}Data`];
        data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
        if (e.cancelBubble)
          return;
      }
      node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;
    }
  }
  function insertExpression(parent, value, current, marker, unwrapArray) {
    if (sharedConfig.context && !current)
      current = [...parent.childNodes];
    while (typeof current === "function")
      current = current();
    if (value === current)
      return current;
    const t2 = typeof value, multi = marker !== void 0;
    parent = multi && current[0] && current[0].parentNode || parent;
    if (t2 === "string" || t2 === "number") {
      if (sharedConfig.context)
        return current;
      if (t2 === "number")
        value = value.toString();
      if (multi) {
        let node = current[0];
        if (node && node.nodeType === 3) {
          node.data = value;
        } else
          node = document.createTextNode(value);
        current = cleanChildren(parent, current, marker, node);
      } else {
        if (current !== "" && typeof current === "string") {
          current = parent.firstChild.data = value;
        } else
          current = parent.textContent = value;
      }
    } else if (value == null || t2 === "boolean") {
      if (sharedConfig.context)
        return current;
      current = cleanChildren(parent, current, marker);
    } else if (t2 === "function") {
      createRenderEffect(() => {
        let v = value();
        while (typeof v === "function")
          v = v();
        current = insertExpression(parent, v, current, marker);
      });
      return () => current;
    } else if (Array.isArray(value)) {
      const array = [];
      const currentArray = current && Array.isArray(current);
      if (normalizeIncomingArray(array, value, current, unwrapArray)) {
        createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
        return () => current;
      }
      if (sharedConfig.context) {
        if (!array.length)
          return current;
        for (let i = 0; i < array.length; i++) {
          if (array[i].parentNode)
            return current = array;
        }
      }
      if (array.length === 0) {
        current = cleanChildren(parent, current, marker);
        if (multi)
          return current;
      } else if (currentArray) {
        if (current.length === 0) {
          appendNodes(parent, array, marker);
        } else
          reconcileArrays(parent, current, array);
      } else {
        current && cleanChildren(parent);
        appendNodes(parent, array);
      }
      current = array;
    } else if (value instanceof Node) {
      if (sharedConfig.context && value.parentNode)
        return current = multi ? [value] : value;
      if (Array.isArray(current)) {
        if (multi)
          return current = cleanChildren(parent, current, marker, value);
        cleanChildren(parent, current, null, value);
      } else if (current == null || current === "" || !parent.firstChild) {
        parent.appendChild(value);
      } else
        parent.replaceChild(value, parent.firstChild);
      current = value;
    } else
      ;
    return current;
  }
  function normalizeIncomingArray(normalized, array, current, unwrap) {
    let dynamic = false;
    for (let i = 0, len = array.length; i < len; i++) {
      let item = array[i], prev = current && current[i];
      if (item instanceof Node) {
        normalized.push(item);
      } else if (item == null || item === true || item === false)
        ;
      else if (Array.isArray(item)) {
        dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
      } else if (typeof item === "function") {
        if (unwrap) {
          while (typeof item === "function")
            item = item();
          dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], prev) || dynamic;
        } else {
          normalized.push(item);
          dynamic = true;
        }
      } else {
        const value = String(item);
        if (prev && prev.nodeType === 3 && prev.data === value) {
          normalized.push(prev);
        } else
          normalized.push(document.createTextNode(value));
      }
    }
    return dynamic;
  }
  function appendNodes(parent, array, marker) {
    for (let i = 0, len = array.length; i < len; i++)
      parent.insertBefore(array[i], marker);
  }
  function cleanChildren(parent, current, marker, replacement) {
    if (marker === void 0)
      return parent.textContent = "";
    const node = replacement || document.createTextNode("");
    if (current.length) {
      let inserted = false;
      for (let i = current.length - 1; i >= 0; i--) {
        const el = current[i];
        if (node !== el) {
          const isParent = el.parentNode === parent;
          if (!inserted && !i)
            isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
          else
            isParent && el.remove();
        } else
          inserted = true;
      }
    } else
      parent.insertBefore(node, marker);
    return [node];
  }

  // ../index.js
  init_inject();
  var is = String.raw;

  // src/App.tsx
  init_inject();

  // ../src/index.browser.ts
  init_inject();

  // ../src/core/index.ts
  init_inject();

  // ../src/core/cssify.ts
  init_inject();
  var groupToMap = (array, keySelector) => {
    const map = /* @__PURE__ */ new Map();
    for (const element of array) {
      const key = keySelector(element);
      const values = map.get(key);
      values ? values.push(element) : map.set(key, [element]);
    }
    return map;
  };
  var joinGroup = (separator, array, groupKeySelector, joinedValueSelector) => {
    const grouped = groupToMap(array, groupKeySelector);
    return [...grouped.keys()].sort().map((key) => joinedValueSelector(key, grouped.get(key))).join(separator);
  };
  var mediaSelector = (c) => c.media ?? "";
  var layerSelector = (c) => c.layer;
  var selectorSelector = (c) => `.${CSS.escape(c.className)}${":not(#\\ )".repeat(c.specificity ?? 0)}${c.selector ?? ""}`;
  var propertySelector = (c) => `${c.property}:${c.value}${c.important ? "!important" : ""}`;
  var cssify = (classes2, options) => {
    const [singleIndent, newline] = options?.pretty ? ["  ", "\n"] : ["", ""];
    return joinGroup(newline, classes2, mediaSelector, (media, mediaRecords) => {
      const indent1 = media ? singleIndent : "";
      const content = joinGroup(newline, mediaRecords, layerSelector, (layer, layerRecords) => {
        const hasLayer = layer !== void 0;
        const indent2 = indent1 + (hasLayer ? singleIndent : "");
        const content2 = joinGroup(newline, layerRecords, propertySelector, (propertyList, selectorRecords) => {
          const selector = selectorRecords.sort().map(selectorSelector).join(`,${newline}${indent2}`);
          return `${indent2}${selector}{${newline}${indent2}${singleIndent}${propertyList}${newline}${indent2}}${newline}`;
        });
        return hasLayer ? `${indent1}@layer${layer ? " " : ""}${layer}{${newline}${content2}${indent1}}${newline}` : content2;
      });
      return media ? `@media${media.startsWith("(") ? "" : " "}${media}{${newline}${content}}${newline}` : content;
    });
  };

  // ../src/core/parseClass.ts
  init_inject();
  var import_known_css_properties = __toESM(require_known_css_properties(), 1);
  var knownCssPropertySet = new Set(import_known_css_properties.all);
  var unescapeBackslash = (s) => s.replace(/\\(.)/g, "$1");
  var unescapeWhitespace = (s) => s.replace(/(^|[^\\])(\\\\)*_/g, "$1$2 ");
  var replaceTokens = (source, replacement, tokenPattern) => {
    if (!replacement) {
      return source;
    }
    if (Array.isArray(replacement)) {
      if (replacement[0] instanceof RegExp) {
        return source.replace(replacement[0], replacement[1]);
      } else {
        return replacement.reduce((s, r) => replaceTokens(s, r, tokenPattern), source);
      }
    }
    return source.replaceAll(tokenPattern, (token) => replacement[token] ?? token);
  };
  var replaceProperty = (property, replacement) => {
    if (!replacement) {
      return property;
    }
    if (Array.isArray(replacement)) {
      if (replacement[0] instanceof RegExp) {
        return property.replace(replacement[0], replacement[1]);
      } else {
        return replacement.reduce(replaceProperty, property);
      }
    }
    return replacement[property] || property;
  };
  var transformMedia = (media, replacements) => {
    media = replaceTokens(media, replacements, /[\w$#-]+/g);
    media = unescapeWhitespace(media);
    media = media.replace(/(^| )([^ ()]+\b[^ ()]+)($| )/g, "$1($2)$3");
    return unescapeBackslash(media);
  };
  var transformSelector = (selector, replacements) => {
    selector = replaceTokens(selector, replacements, /([:>+~_]|::)[\w$#-]+/g);
    selector = unescapeWhitespace(selector);
    return unescapeBackslash(selector);
  };
  var transformValue = (value, replacements) => {
    value = replaceTokens(value, replacements, /[\w$#-]+/g);
    value = unescapeWhitespace(value);
    value = value.replace(/\$([_a-zA-Z0-9-]*[a-zA-Z0-9])/g, "var(--$1)");
    return unescapeBackslash(value);
  };
  var transformProperty = (property, replacements) => {
    if (property.startsWith("--")) {
      return property;
    }
    property = replaceProperty(property, replacements);
    if (knownCssPropertySet.has(property)) {
      return property;
    }
  };
  var parseClass = (className2, options) => {
    const replacements = options?.replacements;
    const match = className2.match(
      /^(?:@((?:[^/\\]|\\.)+?)\/)?(?:((?:[^/\\]|\\.)+?)\/)?([^:]+?):(.+?)(\**)(!?)(\??)$/
    );
    const property = match && transformProperty(match[3], replacements?.property);
    return property ? {
      className: className2,
      media: match[1] ? transformMedia(match[1], replacements?.media) : void 0,
      layer: match[7] === "?" ? "" : void 0,
      selector: match[2] ? transformSelector(match[2], replacements?.selector) : void 0,
      property,
      value: transformValue(match[4], replacements?.value),
      specificity: (match[7] === "?" ? 0 : 1) + match[5].length,
      important: match[6] === "!" || void 0
    } : void 0;
  };

  // ../src/core/parseHtml.ts
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/index.js
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/Parser.js
  init_inject();

  // ../node_modules/htmlparser2/lib/esm/Tokenizer.js
  init_inject();

  // ../node_modules/entities/lib/esm/decode.js
  init_inject();

  // ../node_modules/entities/lib/esm/generated/decode-data-html.js
  init_inject();
  var decode_data_html_default = new Uint16Array(
    '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
  );

  // ../node_modules/entities/lib/esm/generated/decode-data-xml.js
  init_inject();
  var decode_data_xml_default = new Uint16Array(
    "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
  );

  // ../node_modules/entities/lib/esm/decode_codepoint.js
  init_inject();
  var _a;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  function decodeCodePoint(codePoint) {
    return fromCodePoint(replaceCodePoint(codePoint));
  }

  // ../node_modules/entities/lib/esm/decode.js
  var CharCodes;
  (function(CharCodes3) {
    CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
    CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
    CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
    CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
    CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
    CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
    CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
    CharCodes3[CharCodes3["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
  })(CharCodes || (CharCodes = {}));
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function getDecoder(decodeTree) {
    return function decodeHTMLBinary(str, strict) {
      let ret = "";
      let lastIdx = 0;
      let strIdx = 0;
      while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
        ret += str.slice(lastIdx, strIdx);
        lastIdx = strIdx;
        strIdx += 1;
        if (str.charCodeAt(strIdx) === CharCodes.NUM) {
          let start = strIdx + 1;
          let base = 10;
          let cp = str.charCodeAt(start);
          if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
            base = 16;
            strIdx += 1;
            start += 1;
          }
          do
            cp = str.charCodeAt(++strIdx);
          while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);
          if (start !== strIdx) {
            const entity = str.substring(start, strIdx);
            const parsed = parseInt(entity, base);
            if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
              strIdx += 1;
            } else if (strict) {
              continue;
            }
            ret += decodeCodePoint(parsed);
            lastIdx = strIdx;
          }
          continue;
        }
        let resultIdx = 0;
        let excess = 1;
        let treeIdx = 0;
        let current = decodeTree[treeIdx];
        for (; strIdx < str.length; strIdx++, excess++) {
          treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
          if (treeIdx < 0)
            break;
          current = decodeTree[treeIdx];
          const masked = current & BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
              resultIdx = treeIdx;
              excess = 0;
            }
            const valueLength = (masked >> 14) - 1;
            if (valueLength === 0)
              break;
            treeIdx += valueLength;
          }
        }
        if (resultIdx !== 0) {
          const valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
          ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
          lastIdx = strIdx - excess + 1;
        }
      }
      return ret + str.slice(lastIdx);
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  var htmlDecoder = getDecoder(decode_data_html_default);
  var xmlDecoder = getDecoder(decode_data_xml_default);

  // ../node_modules/htmlparser2/lib/esm/Tokenizer.js
  var CharCodes2;
  (function(CharCodes3) {
    CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
    CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
    CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
    CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes3[CharCodes3["Space"] = 32] = "Space";
    CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes3[CharCodes3["Num"] = 35] = "Num";
    CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
    CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
    CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
    CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
    CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
    CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
    CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
    CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
    CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
    CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
    CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
    CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
    CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
    CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
    CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
    CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
    CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
    CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
    CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes2 || (CharCodes2 = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  function isWhitespace(c) {
    return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
  }
  function isEndOfTagSection(c) {
    return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
  }
  function isNumber(c) {
    return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
  }
  function isASCIIAlpha(c) {
    return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
  }
  function isHexDigit(c) {
    return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
  var Tokenizer = class {
    constructor({ xmlMode = false, decodeEntities = true }, cbs) {
      this.cbs = cbs;
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.isSpecial = false;
      this.running = true;
      this.offset = 0;
      this.sequenceIndex = 0;
      this.trieIndex = 0;
      this.trieCurrent = 0;
      this.entityResult = 0;
      this.entityExcess = 0;
      this.xmlMode = xmlMode;
      this.decodeEntities = decodeEntities;
      this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
    }
    reset() {
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.currentSequence = void 0;
      this.running = true;
      this.offset = 0;
    }
    write(chunk) {
      this.offset += this.buffer.length;
      this.buffer = chunk;
      this.parse();
    }
    end() {
      if (this.running)
        this.finish();
    }
    pause() {
      this.running = false;
    }
    resume() {
      this.running = true;
      if (this.index < this.buffer.length + this.offset) {
        this.parse();
      }
    }
    getIndex() {
      return this.index;
    }
    getSectionStart() {
      return this.sectionStart;
    }
    stateText(c) {
      if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = State.BeforeTagName;
        this.sectionStart = this.index;
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.state = State.BeforeEntity;
      }
    }
    stateSpecialStartSequence(c) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
      if (!isMatch) {
        this.isSpecial = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
    stateInSpecialTag(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === CharCodes2.Gt || isWhitespace(c)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.isSpecial = false;
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd) {
          if (this.decodeEntities && c === CharCodes2.Amp) {
            this.state = State.BeforeEntity;
          }
        } else if (this.fastForwardTo(CharCodes2.Lt)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === CharCodes2.Lt);
      }
    }
    stateCDATASequence(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = State.InDeclaration;
        this.stateInDeclaration(c);
      }
    }
    fastForwardTo(c) {
      while (++this.index < this.buffer.length + this.offset) {
        if (this.buffer.charCodeAt(this.index - this.offset) === c) {
          return true;
        }
      }
      this.index = this.buffer.length + this.offset - 1;
      return false;
    }
    stateInCommentLike(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index, 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index, 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = State.Text;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    isTagStartChar(c) {
      return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    }
    startSpecial(sequence, offset) {
      this.isSpecial = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
      this.state = State.SpecialStartSequence;
    }
    stateBeforeTagName(c) {
      if (c === CharCodes2.ExclamationMark) {
        this.state = State.BeforeDeclaration;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.Questionmark) {
        this.state = State.InProcessingInstruction;
        this.sectionStart = this.index + 1;
      } else if (this.isTagStartChar(c)) {
        const lower = c | 32;
        this.sectionStart = this.index;
        if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
          this.startSpecial(Sequences.TitleEnd, 3);
        } else {
          this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
        }
      } else if (c === CharCodes2.Slash) {
        this.state = State.BeforeClosingTagName;
      } else {
        this.state = State.Text;
        this.stateText(c);
      }
    }
    stateInTagName(c) {
      if (isEndOfTagSection(c)) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateBeforeClosingTagName(c) {
      if (isWhitespace(c)) {
      } else if (c === CharCodes2.Gt) {
        this.state = State.Text;
      } else {
        this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterClosingTagName;
        this.stateAfterClosingTagName(c);
      }
    }
    stateAfterClosingTagName(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttributeName(c) {
      if (c === CharCodes2.Gt) {
        this.cbs.onopentagend(this.index);
        if (this.isSpecial) {
          this.state = State.InSpecialTag;
          this.sequenceIndex = 0;
        } else {
          this.state = State.Text;
        }
        this.baseState = this.state;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.Slash) {
        this.state = State.InSelfClosingTag;
      } else if (!isWhitespace(c)) {
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c) {
      if (c === CharCodes2.Gt) {
        this.cbs.onselfclosingtag(this.index);
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
        this.isSpecial = false;
      } else if (!isWhitespace(c)) {
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateInAttributeName(c) {
      if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterAttributeName;
        this.stateAfterAttributeName(c);
      }
    }
    stateAfterAttributeName(c) {
      if (c === CharCodes2.Eq) {
        this.state = State.BeforeAttributeValue;
      } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (!isWhitespace(c)) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateBeforeAttributeValue(c) {
      if (c === CharCodes2.DoubleQuote) {
        this.state = State.InAttributeValueDq;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes2.SingleQuote) {
        this.state = State.InAttributeValueSq;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c)) {
        this.sectionStart = this.index;
        this.state = State.InAttributeValueNq;
        this.stateInAttributeValueNoQuotes(c);
      }
    }
    handleInAttributeValue(c, quote) {
      if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
        this.state = State.BeforeAttributeName;
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    }
    stateInAttributeValueDoubleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
    }
    stateInAttributeValueSingleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes2.SingleQuote);
    }
    stateInAttributeValueNoQuotes(c) {
      if (isWhitespace(c) || c === CharCodes2.Gt) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(QuoteType.Unquoted, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (this.decodeEntities && c === CharCodes2.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    }
    stateBeforeDeclaration(c) {
      if (c === CharCodes2.OpeningSquareBracket) {
        this.state = State.CDATASequence;
        this.sequenceIndex = 0;
      } else {
        this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
      }
    }
    stateInDeclaration(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.ondeclaration(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c) {
      if (c === CharCodes2.Dash) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = State.InDeclaration;
      }
    }
    stateInSpecialComment(c) {
      if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
        this.cbs.oncomment(this.sectionStart, this.index, 0);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c) {
      const lower = c | 32;
      if (lower === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (lower === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c);
      }
    }
    stateBeforeEntity(c) {
      this.entityExcess = 1;
      this.entityResult = 0;
      if (c === CharCodes2.Num) {
        this.state = State.BeforeNumericEntity;
      } else if (c === CharCodes2.Amp) {
      } else {
        this.trieIndex = 0;
        this.trieCurrent = this.entityTrie[0];
        this.state = State.InNamedEntity;
        this.stateInNamedEntity(c);
      }
    }
    stateInNamedEntity(c) {
      this.entityExcess += 1;
      this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
      if (this.trieIndex < 0) {
        this.emitNamedEntity();
        this.index--;
        return;
      }
      this.trieCurrent = this.entityTrie[this.trieIndex];
      const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
          this.trieIndex += valueLength;
        } else {
          const entityStart = this.index - this.entityExcess + 1;
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.entityResult = this.trieIndex;
          this.trieIndex += valueLength;
          this.entityExcess = 0;
          this.sectionStart = this.index + 1;
          if (valueLength === 0) {
            this.emitNamedEntity();
          }
        }
      }
    }
    emitNamedEntity() {
      this.state = this.baseState;
      if (this.entityResult === 0) {
        return;
      }
      const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
      switch (valueLength) {
        case 1:
          this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
          break;
        case 2:
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          break;
        case 3: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
        }
      }
    }
    stateBeforeNumericEntity(c) {
      if ((c | 32) === CharCodes2.LowerX) {
        this.entityExcess++;
        this.state = State.InHexEntity;
      } else {
        this.state = State.InNumericEntity;
        this.stateInNumericEntity(c);
      }
    }
    emitNumericEntity(strict) {
      const entityStart = this.index - this.entityExcess - 1;
      const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
      if (numberStart !== this.index) {
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.sectionStart = this.index + Number(strict);
        this.emitCodePoint(replaceCodePoint(this.entityResult));
      }
      this.state = this.baseState;
    }
    stateInNumericEntity(c) {
      if (c === CharCodes2.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    }
    stateInHexEntity(c) {
      if (c === CharCodes2.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
        this.entityExcess++;
      } else if (isHexDigit(c)) {
        this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    }
    allowLegacyEntity() {
      return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    }
    cleanup() {
      if (this.running && this.sectionStart !== this.index) {
        if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    shouldContinue() {
      return this.index < this.buffer.length + this.offset && this.running;
    }
    parse() {
      while (this.shouldContinue()) {
        const c = this.buffer.charCodeAt(this.index - this.offset);
        if (this.state === State.Text) {
          this.stateText(c);
        } else if (this.state === State.SpecialStartSequence) {
          this.stateSpecialStartSequence(c);
        } else if (this.state === State.InSpecialTag) {
          this.stateInSpecialTag(c);
        } else if (this.state === State.CDATASequence) {
          this.stateCDATASequence(c);
        } else if (this.state === State.InAttributeValueDq) {
          this.stateInAttributeValueDoubleQuotes(c);
        } else if (this.state === State.InAttributeName) {
          this.stateInAttributeName(c);
        } else if (this.state === State.InCommentLike) {
          this.stateInCommentLike(c);
        } else if (this.state === State.InSpecialComment) {
          this.stateInSpecialComment(c);
        } else if (this.state === State.BeforeAttributeName) {
          this.stateBeforeAttributeName(c);
        } else if (this.state === State.InTagName) {
          this.stateInTagName(c);
        } else if (this.state === State.InClosingTagName) {
          this.stateInClosingTagName(c);
        } else if (this.state === State.BeforeTagName) {
          this.stateBeforeTagName(c);
        } else if (this.state === State.AfterAttributeName) {
          this.stateAfterAttributeName(c);
        } else if (this.state === State.InAttributeValueSq) {
          this.stateInAttributeValueSingleQuotes(c);
        } else if (this.state === State.BeforeAttributeValue) {
          this.stateBeforeAttributeValue(c);
        } else if (this.state === State.BeforeClosingTagName) {
          this.stateBeforeClosingTagName(c);
        } else if (this.state === State.AfterClosingTagName) {
          this.stateAfterClosingTagName(c);
        } else if (this.state === State.BeforeSpecialS) {
          this.stateBeforeSpecialS(c);
        } else if (this.state === State.InAttributeValueNq) {
          this.stateInAttributeValueNoQuotes(c);
        } else if (this.state === State.InSelfClosingTag) {
          this.stateInSelfClosingTag(c);
        } else if (this.state === State.InDeclaration) {
          this.stateInDeclaration(c);
        } else if (this.state === State.BeforeDeclaration) {
          this.stateBeforeDeclaration(c);
        } else if (this.state === State.BeforeComment) {
          this.stateBeforeComment(c);
        } else if (this.state === State.InProcessingInstruction) {
          this.stateInProcessingInstruction(c);
        } else if (this.state === State.InNamedEntity) {
          this.stateInNamedEntity(c);
        } else if (this.state === State.BeforeEntity) {
          this.stateBeforeEntity(c);
        } else if (this.state === State.InHexEntity) {
          this.stateInHexEntity(c);
        } else if (this.state === State.InNumericEntity) {
          this.stateInNumericEntity(c);
        } else {
          this.stateBeforeNumericEntity(c);
        }
        this.index++;
      }
      this.cleanup();
    }
    finish() {
      if (this.state === State.InNamedEntity) {
        this.emitNamedEntity();
      }
      if (this.sectionStart < this.index) {
        this.handleTrailingData();
      }
      this.cbs.onend();
    }
    handleTrailingData() {
      const endIndex = this.buffer.length + this.offset;
      if (this.state === State.InCommentLike) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex, 0);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex, 0);
        }
      } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
      } else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitPartial(start, endIndex) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribdata(start, endIndex);
      } else {
        this.cbs.ontext(start, endIndex);
      }
    }
    emitCodePoint(cp) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribentity(cp);
      } else {
        this.cbs.ontextentity(cp);
      }
    }
  };

  // ../node_modules/htmlparser2/lib/esm/Parser.js
  var formTags = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  var pTag = /* @__PURE__ */ new Set(["p"]);
  var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
  var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
  var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
  var openImpliesClose = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  var voidElements = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
  var htmlIntegrationElements = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  var reNameEnd = /\s|\//;
  var Parser = class {
    constructor(cbs, options = {}) {
      var _a2, _b, _c, _d, _e;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
      this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    ontext(start, endIndex) {
      var _a2, _b;
      const data = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
      this.startIndex = endIndex;
    }
    ontextentity(cp) {
      var _a2, _b;
      const idx = this.tokenizer.getSectionStart();
      this.endIndex = idx - 1;
      (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
      this.startIndex = idx;
    }
    isVoidElement(name) {
      return !this.options.xmlMode && voidElements.has(name);
    }
    onopentagname(start, endIndex) {
      this.endIndex = endIndex;
      let name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      this.emitOpenTag(name);
    }
    emitOpenTag(name) {
      var _a2, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name;
      const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          const el = this.stack.pop();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, el, true);
        }
      }
      if (!this.isVoidElement(name)) {
        this.stack.push(name);
        if (foreignContextElements.has(name)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
      if (this.cbs.onopentag)
        this.attribs = {};
    }
    endOpenTag(isImplied) {
      var _a2, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    }
    onopentagend(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    }
    onclosetag(start, endIndex) {
      var _a2, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      let name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name)) {
        const pos = this.stack.lastIndexOf(name);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            let count = this.stack.length - pos;
            while (count--) {
              this.cbs.onclosetag(this.stack.pop(), count !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name === "br") {
        (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    }
    onselfclosingtag(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    }
    closeCurrentTag(isOpenImplied) {
      var _a2, _b;
      const name = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name) {
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
        this.stack.pop();
      }
    }
    onattribname(start, endIndex) {
      this.startIndex = start;
      const name = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    }
    onattribdata(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    }
    onattribentity(cp) {
      this.attribvalue += fromCodePoint(cp);
    }
    onattribend(quote, endIndex) {
      var _a2, _b;
      this.endIndex = endIndex;
      (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    }
    getInstructionName(value) {
      const idx = value.search(reNameEnd);
      let name = idx < 0 ? value : value.substr(0, idx);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      return name;
    }
    ondeclaration(start, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    onprocessinginstruction(start, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    oncomment(start, endIndex, offset) {
      var _a2, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    }
    oncdata(start, endIndex, offset) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      const value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    }
    onend() {
      var _a2, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (let i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
          ;
      }
      (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
    }
    reset() {
      var _a2, _b, _c, _d;
      (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    }
    parseComplete(data) {
      this.reset();
      this.end(data);
    }
    getSlice(start, end) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      let str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
      while (end - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        str += this.buffers[0].slice(0, end - this.bufferOffset);
      }
      return str;
    }
    shiftBuffer() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    }
    write(chunk) {
      var _a2, _b;
      if (this.ended) {
        (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    }
    end(chunk) {
      var _a2, _b;
      if (this.ended) {
        (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    }
    pause() {
      this.tokenizer.pause();
    }
    resume() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    }
    parseChunk(chunk) {
      this.write(chunk);
    }
    done(chunk) {
      this.end(chunk);
    }
  };

  // ../node_modules/domhandler/lib/esm/index.js
  init_inject();

  // ../node_modules/domelementtype/lib/esm/index.js
  init_inject();
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  var Root = ElementType.Root;
  var Text = ElementType.Text;
  var Directive = ElementType.Directive;
  var Comment = ElementType.Comment;
  var Script = ElementType.Script;
  var Style = ElementType.Style;
  var Tag = ElementType.Tag;
  var CDATA = ElementType.CDATA;
  var Doctype = ElementType.Doctype;

  // ../node_modules/domhandler/lib/esm/node.js
  init_inject();

  // ../node_modules/domutils/lib/esm/index.js
  init_inject();

  // ../node_modules/domutils/lib/esm/stringify.js
  init_inject();

  // ../node_modules/dom-serializer/lib/esm/index.js
  init_inject();

  // ../node_modules/entities/lib/esm/index.js
  init_inject();

  // ../node_modules/entities/lib/esm/encode.js
  init_inject();

  // ../node_modules/entities/lib/esm/generated/encode-html.js
  init_inject();
  function restoreDiff(arr) {
    for (let i = 1; i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  }
  var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

  // ../node_modules/entities/lib/esm/escape.js
  init_inject();
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
  function getEscaper(regex, map) {
    return function escape2(data) {
      let match;
      let lastIdx = 0;
      let result = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  }
  var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));

  // ../node_modules/entities/lib/esm/index.js
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  })(DecodingMode || (DecodingMode = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode || (EncodingMode = {}));

  // ../node_modules/dom-serializer/lib/esm/foreignNames.js
  init_inject();
  var elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((val) => [val.toLowerCase(), val]));
  var attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((val) => [val.toLowerCase(), val]));

  // ../node_modules/domutils/lib/esm/traversal.js
  init_inject();

  // ../node_modules/domutils/lib/esm/manipulation.js
  init_inject();

  // ../node_modules/domutils/lib/esm/querying.js
  init_inject();

  // ../node_modules/domutils/lib/esm/legacy.js
  init_inject();

  // ../node_modules/domutils/lib/esm/helpers.js
  init_inject();
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));

  // ../node_modules/domutils/lib/esm/feeds.js
  init_inject();

  // ../src/core/parseHtml.ts
  var parseHtml = (content, options, collectTo = /* @__PURE__ */ new Map()) => {
    new Parser({
      onattribute(name, value) {
        if (name === "class") {
          value.split(" ").forEach((className2) => {
            const parsed = !collectTo.has(className2) && parseClass(className2, options);
            parsed && collectTo.set(className2, parsed);
          });
        }
      }
    }).end(content);
    return collectTo;
  };

  // ../src/core/transformTaggedTemplates.ts
  init_inject();
  var import_generator = __toESM(require_lib4(), 1);
  var import_parser = __toESM(require_lib5(), 1);
  var import_traverse = __toESM(require_lib13(), 1);
  var t = __toESM(require_lib3(), 1);
  var generate = typeof import_generator.default === "object" && typeof import_generator.default.default === "function" ? import_generator.default.default : import_generator.default;
  var traverse = typeof import_traverse.default === "object" && typeof import_traverse.default.default === "function" ? import_traverse.default.default : import_traverse.default;
  var nthWordSequence = (chars) => (n) => {
    let s = "";
    while (n >= 0) {
      s = chars[n % chars.length] + s;
      n = Math.floor(n / chars.length) - 1;
    }
    return s;
  };
  var compressClassName = nthWordSequence("abcdefghijklmnopqrstuvwxyz0123456789_");

  // ../src/core/types.ts
  init_inject();

  // ../src/replacements/index.ts
  init_inject();

  // ../src/replacements/default.ts
  init_inject();

  // ../src/replacements/merge.ts
  init_inject();
  var mergeReplacements = (...replacements) => {
    const rs = [].concat(...replacements);
    return {
      media: rs.map((r) => r.media),
      selector: rs.map((r) => r.selector),
      property: rs.map((r) => r.property),
      value: rs.map((r) => r.value)
    };
  };

  // ../src/replacements/default.ts
  var mediaOperatorReplacements = {
    media: [
      [/!/g, "not "],
      [/&/g, " and "],
      [/\|/g, " or "]
    ]
  };
  var abbreviationReplacements = {
    media: {
      h: "height",
      "min-h": "min-height",
      "max-h": "max-height",
      w: "width",
      "min-w": "min-width",
      "max-w": "max-width"
    },
    property: [
      {
        b: "border",
        bg: "background",
        c: "color",
        d: "display",
        h: "height",
        m: "margin",
        p: "padding",
        pos: "position",
        w: "width",
        z: "z-index"
      },
      [/^b-/, "border-"],
      [/^bg-/, "background-"],
      [/^m-/, "margin-"],
      [/^p-/, "padding-"],
      [/-b$/, "-bottom"],
      [/-c$/, "-color"],
      [/-h$/, "-height"],
      [/-l$/, "-left"],
      [/-r$/, "-right"],
      [/-t$/, "-top"],
      [/-pos$/, "-position"],
      [/-w$/, "-width"],
      [/-b-/, "-bottom-"],
      [/-l-/, "-left-"],
      [/-r-/, "-right-"],
      [/-t-/, "-top-"]
    ]
  };
  var defaultReplacements = mergeReplacements(mediaOperatorReplacements, abbreviationReplacements);

  // src/sample.html
  var sample_default = '<form onsubmit="arguments[0].preventDefault()">\n  <label class="cursor:pointer user-select:none d:inline-flex align-items:center gap:4px :has(>:checked)/c:rebeccapurple :has(>:checked)/accent-c:rebeccapurple">\n    <input type="checkbox" class="cursor:inherit" />\n    Checkbox\n  </label>\n\n  <button class="--H:210 --S:100% --L:50% p:4px_8px @w>=768px/p:8px_16px b-radius:8px c:white b:3px_solid_hsl($H,$S,80%) bg:hsl($H,$S,$L) :hover/--L:60% :active/--L:40%* @hover:hover/:hover/scale:1.1">\n    Submit\n  </button>\n</form>\n';

  // src/App.tsx
  var _tmpl$ = /* @__PURE__ */ template(`<header><h1>isaaccss</h1><h2>playground</h2></header>`, 6);
  var _tmpl$2 = /* @__PURE__ */ template(`<details><summary></summary><div></div></details>`, 6);
  var _tmpl$3 = /* @__PURE__ */ template(`<textarea rows="10"></textarea>`, 2);
  var _tmpl$4 = /* @__PURE__ */ template(`<textarea rows="10" readonly></textarea>`, 2);
  var _tmpl$5 = /* @__PURE__ */ template(`<iframe></iframe>`, 2);
  var _tmpl$6 = /* @__PURE__ */ template(`<main></main>`, 2);
  var Header = () => (() => {
    const _el$ = _tmpl$.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    className(_el$, is`p-b:1em font-family:logo d:inline-flex flex-direction:column align-items:center`);
    className(_el$2, is`font-size:2.5rem font-style:oblique`);
    className(_el$3, is`font-size:1rem c:gray letter-spacing:0.375em`);
    return _el$;
  })();
  var Details = ({
    open,
    summary,
    children: children2
  }) => (() => {
    const _el$4 = _tmpl$2.cloneNode(true), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;
    className(_el$4, is`p:0.5rem box-shadow:0_0_4px_#bbb,_0_2px_8px_#bbb`);
    _el$4.open = open;
    className(_el$5, is`cursor:pointer user-select:none font-weight:bold`);
    insert(_el$5, summary);
    className(_el$6, is`b-w:1px b-c:#ccc`);
    insert(_el$6, children2);
    return _el$4;
  })();
  var Main = () => (() => {
    const _el$7 = _tmpl$6.cloneNode(true);
    className(_el$7, is`d:flex flex-direction:column gap:1rem _textarea/font-family:'Source_Code_Pro',monospace _textarea/font-size:0.9375rem`);
    insert(_el$7, createComponent(Details, {
      summary: "HTML",
      open: true,
      get children() {
        const _el$8 = _tmpl$3.cloneNode(true);
        _el$8.$$input = (e) => setHtmlContent(e.currentTarget.value);
        createRenderEffect(() => _el$8.value = htmlContent());
        return _el$8;
      }
    }), null);
    insert(_el$7, createComponent(Details, {
      summary: "Parsed Classes",
      get children() {
        const _el$9 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$9.value = classesJson());
        return _el$9;
      }
    }), null);
    insert(_el$7, createComponent(Details, {
      summary: "CSS",
      get children() {
        const _el$10 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$10.value = css());
        return _el$10;
      }
    }), null);
    insert(_el$7, createComponent(Details, {
      summary: "Pretty CSS",
      open: true,
      get children() {
        const _el$11 = _tmpl$4.cloneNode(true);
        createRenderEffect(() => _el$11.value = beautifiedCss());
        return _el$11;
      }
    }), null);
    insert(_el$7, createComponent(Details, {
      summary: "Preview",
      open: true,
      get children() {
        const _el$12 = _tmpl$5.cloneNode(true);
        createRenderEffect(() => setAttribute(_el$12, "srcdoc", `<html><head><style>${css()}</style></head><body>${htmlContent()}</body></html>`));
        return _el$12;
      }
    }), null);
    return _el$7;
  })();
  var [htmlContent, setHtmlContent] = createSignal(sample_default);
  var classes = createMemo(() => parseHtml(htmlContent(), {
    replacements: defaultReplacements
  }));
  var classesJson = createMemo(() => JSON.stringify([...classes().values()], void 0, 2));
  var css = createMemo(() => cssify(classes().values()));
  var beautifiedCss = createMemo(() => cssify(classes().values(), {
    pretty: true
  }));
  var App = () => [createComponent(Header, {}), createComponent(Main, {})];
  delegateEvents(["input"]);

  // src/playground.tsx
  document.body.className = is`p:1rem`;
  render(() => createComponent(App, {}), document.body);
})();
